/******/ (function(modules) { // webpackBootstrap
/******/ 	// install a JSONP callback for chunk loading
/******/ 	function webpackJsonpCallback(data) {
/******/ 		var chunkIds = data[0];
/******/ 		var moreModules = data[1];
/******/
/******/
/******/ 		// add "moreModules" to the modules object,
/******/ 		// then flag all "chunkIds" as loaded and fire callback
/******/ 		var moduleId, chunkId, i = 0, resolves = [];
/******/ 		for(;i < chunkIds.length; i++) {
/******/ 			chunkId = chunkIds[i];
/******/ 			if(Object.prototype.hasOwnProperty.call(installedChunks, chunkId) && installedChunks[chunkId]) {
/******/ 				resolves.push(installedChunks[chunkId][0]);
/******/ 			}
/******/ 			installedChunks[chunkId] = 0;
/******/ 		}
/******/ 		for(moduleId in moreModules) {
/******/ 			if(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {
/******/ 				modules[moduleId] = moreModules[moduleId];
/******/ 			}
/******/ 		}
/******/ 		if(parentJsonpFunction) parentJsonpFunction(data);
/******/
/******/ 		while(resolves.length) {
/******/ 			resolves.shift()();
/******/ 		}
/******/
/******/ 	};
/******/
/******/
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// object to store loaded and loading chunks
/******/ 	// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 	// Promise = chunk loading, 0 = chunk loaded
/******/ 	var installedChunks = {
/******/ 		"main": 0
/******/ 	};
/******/
/******/
/******/
/******/ 	// script path function
/******/ 	function jsonpScriptSrc(chunkId) {
/******/ 		return __webpack_require__.p + "" + ({"swan_modules/debug":"swan_modules/debug","swan_modules/http":"swan_modules/http","swan_modules/json":"swan_modules/json","swan_modules/list":"swan_modules/list","swan_modules/math":"swan_modules/math","swan_modules/text":"swan_modules/text","vendors~swan_modules/markdown":"vendors~swan_modules/markdown","swan_modules/markdown":"swan_modules/markdown"}[chunkId]||chunkId) + ".bundle.js"
/******/ 	}
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/ 	// This file contains only the entry chunk.
/******/ 	// The chunk loading function for additional chunks
/******/ 	__webpack_require__.e = function requireEnsure(chunkId) {
/******/ 		var promises = [];
/******/
/******/
/******/ 		// JSONP chunk loading for javascript
/******/
/******/ 		var installedChunkData = installedChunks[chunkId];
/******/ 		if(installedChunkData !== 0) { // 0 means "already installed".
/******/
/******/ 			// a Promise means "currently loading".
/******/ 			if(installedChunkData) {
/******/ 				promises.push(installedChunkData[2]);
/******/ 			} else {
/******/ 				// setup Promise in chunk cache
/******/ 				var promise = new Promise(function(resolve, reject) {
/******/ 					installedChunkData = installedChunks[chunkId] = [resolve, reject];
/******/ 				});
/******/ 				promises.push(installedChunkData[2] = promise);
/******/
/******/ 				// start chunk loading
/******/ 				var script = document.createElement('script');
/******/ 				var onScriptComplete;
/******/
/******/ 				script.charset = 'utf-8';
/******/ 				script.timeout = 120;
/******/ 				if (__webpack_require__.nc) {
/******/ 					script.setAttribute("nonce", __webpack_require__.nc);
/******/ 				}
/******/ 				script.src = jsonpScriptSrc(chunkId);
/******/
/******/ 				// create error before stack unwound to get useful stacktrace later
/******/ 				var error = new Error();
/******/ 				onScriptComplete = function (event) {
/******/ 					// avoid mem leaks in IE.
/******/ 					script.onerror = script.onload = null;
/******/ 					clearTimeout(timeout);
/******/ 					var chunk = installedChunks[chunkId];
/******/ 					if(chunk !== 0) {
/******/ 						if(chunk) {
/******/ 							var errorType = event && (event.type === 'load' ? 'missing' : event.type);
/******/ 							var realSrc = event && event.target && event.target.src;
/******/ 							error.message = 'Loading chunk ' + chunkId + ' failed.\n(' + errorType + ': ' + realSrc + ')';
/******/ 							error.name = 'ChunkLoadError';
/******/ 							error.type = errorType;
/******/ 							error.request = realSrc;
/******/ 							chunk[1](error);
/******/ 						}
/******/ 						installedChunks[chunkId] = undefined;
/******/ 					}
/******/ 				};
/******/ 				var timeout = setTimeout(function(){
/******/ 					onScriptComplete({ type: 'timeout', target: script });
/******/ 				}, 120000);
/******/ 				script.onerror = script.onload = onScriptComplete;
/******/ 				document.head.appendChild(script);
/******/ 			}
/******/ 		}
/******/ 		return Promise.all(promises);
/******/ 	};
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// on error function for async loading
/******/ 	__webpack_require__.oe = function(err) { console.error(err); throw err; };
/******/
/******/ 	var jsonpArray = window["webpackJsonp"] = window["webpackJsonp"] || [];
/******/ 	var oldJsonpFunction = jsonpArray.push.bind(jsonpArray);
/******/ 	jsonpArray.push = webpackJsonpCallback;
/******/ 	jsonpArray = jsonpArray.slice();
/******/ 	for(var i = 0; i < jsonpArray.length; i++) webpackJsonpCallback(jsonpArray[i]);
/******/ 	var parentJsonpFunction = oldJsonpFunction;
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "../../browser.js":
/*!************************************************!*\
  !*** /home/marcello/mdb/Code/olojs/browser.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("\nconst olojs = window.olojs = module.exports = {};\n\nolojs.expression  = __webpack_require__(/*! ./lib/expression */ \"../../lib/expression.js\");\nolojs.document    = __webpack_require__(/*! ./lib/document */ \"../../lib/document.js\");\n\nolojs.Store       = __webpack_require__(/*! ./lib/store */ \"../../lib/store.js\");\nolojs.MemoryStore = __webpack_require__(/*! ./lib/memory-store */ \"../../lib/memory-store.js\");\nolojs.HTTPStore   = __webpack_require__(/*! ./lib/http-store */ \"../../lib/http-store.js\");\nolojs.Router      = __webpack_require__(/*! ./lib/router */ \"../../lib/router.js\");\n\nolojs.Viewer      = __webpack_require__(/*! ./lib/viewer */ \"../../lib/viewer.js\");\n\n\n//# sourceURL=webpack:////home/marcello/mdb/Code/olojs/browser.js?");

/***/ }),

/***/ "../../lib/document.js":
/*!*****************************************************!*\
  !*** /home/marcello/mdb/Code/olojs/lib/document.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n *  olojs.document\n *  ============================================================================\n *  This module contains functions to parse, evaluate and render olojs\n *  documents.\n *\n *  ```js\n *  source = \"Twice x is <% 2*x %>!\";\n *  evaluate = olojs.document.parse(source);\n *  context = olojs.document.createContext({x:10});\n *  namespace = await evaluate(context);    // {x:10}\n *  text = await context.str(namespace);    // \"Twice x is 20\"\n *  ```\n */\n\nconst swan = __webpack_require__(/*! ./expression */ \"../../lib/expression.js\");\n\n\n\n/**\n *  olojs.document.parse - function\n *  ----------------------------------------------------------------------------\n *  Compiles a document source into an `evaluate` function that takes as input\n *  a document context object and returns the document namespace object.\n *\n *  ```js\n *  evaluate = olojs.document.parse(source);\n *  namespace = await evaluate(context);\n *  ```\n *\n *  - `source` is a string containing the source of an olojs document\n *  - `evaluate` is an asynchronous function that evaluates the document and\n *    returns its namespace\n *  - `namespace` is an object containing all the names defined by the inline\n *    expressions of the document.\n *\n *  The document namespace stringifies to a text obtained by replacing every\n *  inline expression with its value, therefore in javascript\n *  `await context.str(namespace)` will return the rendered document.\n */\nconst parseDocument = exports.parse = function (source) {\n    source = String(source);\n\n    // // Parse fragments\n    // source = source.replace(/<\\s*def:([a-z_A-Z]+[a-z_A-Z0-9]*)\\s+(.*)>(.*)<\\s*\\/def:\\1\\s*>/g, (match, identifier, attributes, content) => {\n    //     return \"\";\n    // });    \n\n    // Find all the swan expressions in the source, store them in an array and\n    // replace them with a placeholder.\n    const parsedExpressions = [];\n    source = source.replace(/<%([\\s\\S]+?)%>/g, (match, expressionSource) => {\n        let i = parsedExpressions.length;\n        let parsedExpression = swan.parse(expressionSource);\n        parsedExpression.source = expressionSource;\n        parsedExpressions.push( parsedExpression );\n        return `<%%>`;\n    });\n    const textChunks = source.split('<%%>');\n    const $text = Symbol(\"Rendered document\");\n\n    // The returned `evaluate` function\n    return async (context) => {\n        // Create a copy ot the context\n        context = Object.assign(Object.create(Object.getPrototypeOf(context)), context);\n        \n        // Evaluate each expression in the given context and replace the\n        // expression source with the stringified expression value\n        context.__str__ = textChunks[0] || \"\";\n        for (let i=0; i<parsedExpressions.length; i++) {\n            let evaluateExpression = parsedExpressions[i];\n            try {\n                var value = await evaluateExpression(context);\n            } catch (error) {\n                // in case of error returns an Undefined failure value\n                var value = await context.undefined('failure', error);\n            }\n            context.__str__ += await context.str(value) + textChunks[i+1];\n        }\n        \n        // Extract the document namespace,\n        // discarding the global context variables.\n        return Object.assign({}, context);\n    };\n}\n\n\n\n\n/**\n *  olojs.document.createContext - function\n *  ----------------------------------------------------------------------------\n *  Creates a custom document evaluation context, by adding to the basic\n *  context all the names defined in the passed namespace.\n *\n *  ```js\n *  context = olojs.document.createContext(...namespaces)\n *  ```\n *  - `namespaces`: list of objects; each of them, from left to right, will be\n *    mixed-in to the basic document context\n *  - `context`: an object containing all the named values and functions that\n *    will be visible to the document inline expressions.\n */\nexports.createContext = function (...namespaces) {\n    return swan.createContext(documentGlobals, ...namespaces);\n}\n\nconst documentGlobals = {};\n\n\n//# sourceURL=webpack:////home/marcello/mdb/Code/olojs/lib/document.js?");

/***/ }),

/***/ "../../lib/expression.js":
/*!*******************************************************!*\
  !*** /home/marcello/mdb/Code/olojs/lib/expression.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const swan = __webpack_require__(/*! @onlabsorg/swan-js */ \"../../node_modules/@onlabsorg/swan-js/index.js\");\n\nconst Lexer = __webpack_require__(/*! @onlabsorg/swan-js/lib/lexer */ \"../../node_modules/@onlabsorg/swan-js/lib/lexer.js\");\nLexer.matchIdentifier = identifier => /^[a-z_A-Z]+[a-z_A-Z0-9]*$/.test(identifier);\n\nswan.defineModule(\"markdown\" , () => Promise.all(/*! import() | swan_modules/markdown */[__webpack_require__.e(\"vendors~swan_modules/markdown\"), __webpack_require__.e(\"swan_modules/markdown\")]).then(__webpack_require__.t.bind(null, /*! ./swan_modules/markdown.js */ \"../../lib/swan_modules/markdown.js\", 7)));\n\nmodule.exports = swan;\n\n\n//# sourceURL=webpack:////home/marcello/mdb/Code/olojs/lib/expression.js?");

/***/ }),

/***/ "../../lib/http-store.js":
/*!*******************************************************!*\
  !*** /home/marcello/mdb/Code/olojs/lib/http-store.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("__webpack_require__(/*! isomorphic-fetch */ \"../../node_modules/isomorphic-fetch/fetch-npm-browserify.js\");\nconst pathlib = __webpack_require__(/*! path */ \"../../node_modules/path-browserify/index.js\");\nconst Store = __webpack_require__(/*! ./store */ \"../../lib/store.js\");\n\n\nconst isObject = obj => obj && typeof obj === 'object' && !Array.isArray(obj);\n\n\n/**\n *  HTTPStore\n *  ============================================================================\n *  This store handles read/write operations on remote olo-documents\n *  via HTTP(S).\n *  \n *  ```js\n *  httpStore = new HTTPStore(rootURL, options)\n *  ```\n *  \n *  - `rootURL` is the base URL that will be prepended to the paths passed to\n *    the `read`, `list`, `write` and `delete` methods.\n *  - `options.headers` are custom headers that will be added to every HTTP\n *    request.\n *  - `httpStore` is a [olojs.Store](./store.md) object\n */\nclass HTTPStore extends Store {\n\n    constructor (rootURL, options={}) {\n        super();\n        if (rootURL.slice(0,6).toLowerCase() === 'http:/') {\n            this.rootURL = 'http:/' + pathlib.normalize(`/${rootURL.slice(6)}/`);\n        } else if (rootURL.slice(0,7).toLowerCase() === 'https:/') {\n            this.rootURL = 'https:/' + pathlib.normalize(`/${rootURL.slice(7)}/`);\n        } else {\n            throw new Error(`Invalid http URL: ${rootURL}`)\n        }\n        this.headers = isObject(options.headers) ? options.headers : {};\n    }\n\n    resolveURL (path) {\n        return this.rootURL + pathlib.normalize(`/${path}`).slice(1);\n    }\n\n\n    /**\n     *  httpStore.read - async method\n     *  ------------------------------------------------------------------------\n     *  Retrieves a remote olo-document via HTTP GET (HTTPS GET).\n     *  \n     *  ```js\n     *  source = await httpStore.read(\"/path/to/doc\")\n     *  ```\n     *  \n     *  - On 200 status code, returns the response body as string\n     *  - On 403 status code, throws a `HTTPStore.ReadPermissionDeniedError`\n     *  - On 404 status code, return an empty string\n     *  - On 405 status code, throws a `HTTPStore.ReadOperationNotAllowedError`\n     *  - On any other status code, throws a generic error\n     */\n    async read (path) {\n        const url = this.resolveURL(path);\n\n        const response = await fetch(url, {\n            method: 'get',\n            headers: Object.assign({}, this.headers, {\n                'Accept': 'text/*',\n            }),\n        });\n\n        switch (response.status) {\n            case 200:\n                return await response.text();\n            case 403:\n                throw new this.constructor.ReadPermissionDeniedError(url);\n            case 404:\n                return \"\";\n            case 405:\n                throw new this.constructor.ReadOperationNotAllowedError(url);\n            default:\n                let message = await response.text();\n                throw new Error(message);\n        }\n    }\n\n\n    /**\n     *  httpStore.list - async method\n     *  ------------------------------------------------------------------------\n     *  Retrieves a remote directory content via an HTTP GET requests that\n     *  accepts only JSON as response.\n     *  \n     *  ```js\n     *  entries = await httpStore.list(\"/path/to/doc\")\n     *  ```\n     *  \n     *  - On 200 status code, returns the response body as json array\n     *  - On 403 status code, throws a `HTTPStore.ReadPermissionDeniedError`\n     *  - On 404 status code, return an empty array\n     *  - On 405 status code, throws a `HTTPStore.ReadOperationNotAllowedError`\n     *  - On any other status code, throws a generic error\n     */\n    async list (path) {\n        const url = this.resolveURL(path);\n\n        const response = await fetch(url, {\n            method: 'get',\n            headers: Object.assign({}, this.headers, {\n                'Accept': 'application/json',\n            }),\n        });\n\n        switch (response.status) {\n            case 200:\n                const entries = await response.json();\n                if (!Array.isArray(entries)) throw new Error('Array json response expected');\n                return entries;\n            case 403:\n                throw new this.constructor.ReadPermissionDeniedError(url);\n            case 404:\n                return [];\n            case 405:\n                throw new this.constructor.ReadOperationNotAllowedError(url);\n            default:\n                let message = await response.text();\n                throw new Error(message);\n        }\n    }\n\n\n    /**\n     *  httpStore.write - async method\n     *  ------------------------------------------------------------------------\n     *  Modifies a remote olo-document via HTTP PUT (HTTPS PUT).\n     *  \n     *  ```js\n     *  await httpStore.write(\"/path/to/doc\", source)\n     *  ```\n     *  \n     *  - On 200 and 201 status code, returns\n     *  - On 403 status code, throws a `HTTPStore.WritePermissionDeniedError`\n     *  - On 405 status code, throws a `HTTPStore.WriteOperationNotAllowedError`\n     *  - On any other status code, throws a generic error\n     */\n    async write (path, source) {\n        const url = this.resolveURL(path);\n\n        const response = await fetch(url, {\n            method: 'put',\n            headers: Object.assign({}, this.headers, {\n                'Accept': 'text/*',\n                'Content-Type': 'text/plain',\n            }),\n            body: String(source)\n        });\n\n        switch (response.status) {\n            case 200:\n            case 201:\n                break;\n            case 403:\n                throw new this.constructor.WritePermissionDeniedError(url);\n            case 405:\n                throw new this.constructor.WriteOperationNotAllowedError(url);\n            default:\n                let message = await response.text();\n                throw new Error(message);\n        }\n    }\n\n\n    /**\n     *  httpStore.delete - async method\n     *  ------------------------------------------------------------------------\n     *  Modifies a remote olo-document via HTTP DELETE (HTTPS DELETE).\n     *  \n     *  ```js\n     *  await httpStore.delete(\"/path/to/doc\")\n     *  ```\n     *  \n     *  - On 200 status code, returns\n     *  - On 403 status code, throws a `HTTPStore.WritePermissionDeniedError`\n     *  - On 405 status code, throws a `HTTPStore.WriteOperationNotAllowedError`\n     *  - On any other status code, throws a generic error\n     */\n    async delete (path) {\n        const url = this.resolveURL(path);\n\n        const response = await fetch(url, {\n            method: 'delete',\n            headers: Object.assign({}, this.headers, {\n                'Accept': 'text/*',\n                'Content-Type': 'text/plain',\n            })\n        });\n\n        switch (response.status) {\n            case 200:\n                break;\n            case 403:\n                throw new this.constructor.WritePermissionDeniedError(url);\n            case 405:\n                throw new this.constructor.WriteOperationNotAllowedError(url);\n            default:\n                let message = await response.text();\n                throw new Error(message);\n        }\n    }\n\n\n    /**\n     *  httpStore.deleteAll - async method\n     *  ------------------------------------------------------------------------\n     *  Modifies a remote `text/direcotry` resource via HTTP DELETE (HTTPS DELETE)\n     *  that accepts `text/directory` as MimeType.\n     *  \n     *  ```js\n     *  await httpStore.deleteAll(\"/path/to/dir\")\n     *  ```\n     *  \n     *  - On 200 status code, returns\n     *  - On 403 status code, throws a `HTTPStore.WritePermissionDeniedError`\n     *  - On 405 status code, throws a `HTTPStore.WriteOperationNotAllowedError`\n     *  - On any other status code, throws a generic error\n     */\n    async deleteAll (path) {\n        const url = this.resolveURL(path);\n\n        const response = await fetch(url, {\n            method: 'delete',\n            headers: Object.assign({}, this.headers, {\n                'Accept': 'text/*',\n                'Content-Type': 'text/directory',\n            })\n        });\n\n        switch (response.status) {\n            case 200:\n                break;\n            case 403:\n                throw new this.constructor.WritePermissionDeniedError(url);\n            case 405:\n                throw new this.constructor.WriteOperationNotAllowedError(url);\n            default:\n                let message = await response.text();\n                throw new Error(message);\n        }\n    }\n}\n\n\nmodule.exports = HTTPStore;\n\n\n//# sourceURL=webpack:////home/marcello/mdb/Code/olojs/lib/http-store.js?");

/***/ }),

/***/ "../../lib/memory-store.js":
/*!*********************************************************!*\
  !*** /home/marcello/mdb/Code/olojs/lib/memory-store.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const pathlib = __webpack_require__(/*! path */ \"../../node_modules/path-browserify/index.js\");\nconst Store = __webpack_require__(/*! ./store */ \"../../lib/store.js\");\n\n\n\n/**\n *  MemoryStore\n *  ============================================================================\n *  This store handles read/write operations on an in-memory map object.\n *\n *  ```js\n *  memStore = new MemoryStore(documents)\n *  ```\n *\n *  Where `documents` is an optional object containing path-document pairs that\n *  will be added to the store upon creation.\n *  \n *  The MemoryStore inherits the `load` method and the Error static properties\n *  from the parent `Store` class.\n */\nclass MemoryStore extends Store {\n\n    constructor (documents={}) {\n        super();\n        this._content = new Map();\n        for (let path in documents) {\n            this._content.set(this.normalizePath(path), String(documents[path]));\n        }\n    }\n\n    /**\n     *  memStore.read - method\n     *  ------------------------------------------------------------------------\n     *  Retrieves the in-memory document source mapped to the given path.\n     *\n     *  ```js\n     *  const source = await memStore.read(\"/path/to/doc\");\n     *  ```\n     *  \n     *  - When requesting `path/to/x/../doc`, the content of `/path/to/doc` will\n     *    be returned\n     *  - When requesting an entry that doesn't exist, and empty string will be\n     *    returned\n     */\n    read (path) {\n        const normPath = this.normalizePath(path);\n        return this._content.get(normPath) || \"\";\n    }\n\n\n    /**\n     *  memStore.list - method\n     *  ------------------------------------------------------------------------\n     *  Returns the list of the children of a path.\n     *\n     *  ```\n     *  entries = await memStore.list('/path/to/dir/');\n     *  ```\n     *  \n     *  If the meomry store contains the following paths ...\n     *  \n     *  - `/path/to/dir/doc1`\n     *  - `/path/to/dir/doc2`\n     *  - `/path/to/dir/subdir/doc3`\n     *  - `/path/to/dir/subdir/doc4`\n     *  - `/path/to/otherdir/doc5`\n     *  \n     *  ... then `entries` is `[\"doc1\", \"doc2\", \"subdir/\"]`.\n     *  \n     *  If the passed path doesn't exist, it returns `[]`.\n     */\n     list (path) {\n         const normPath = this.normalizePath(`${path}/`);\n         const items = [];\n         for (let key of this._content.keys()) {\n             if (key.indexOf(normPath) === 0) {\n                 const subPath = key.slice(normPath.length);\n                 const slashIndex = subPath.indexOf('/');\n                 const item = slashIndex === -1 ? subPath : subPath.slice(0, slashIndex+1);\n                 if (items.indexOf(item) === -1) items.push(item);\n             }\n         }\n         return items;\n     }\n\n\n    /**\n     *  memStore.write - method\n     *  ------------------------------------------------------------------------\n     *  Maps a document path to a source, in memory.\n     *  \n     *  ```js\n     *  await memStore.write(\"/path/to/doc\", source);\n     *  ```\n     *  \n     *  - If path is `path/to/x/../doc`, the content of `/path/to/doc` will\n     *    be modified with the passed source\n     *  - `source` will be always converted to string\n     */\n    write (path, source) {\n        const normPath = this.normalizePath(path);\n        return this._content.set(normPath, String(source));\n    }\n\n\n    /**\n     *  memStore.delete - method\n     *  ------------------------------------------------------------------------\n     *  Erases the doc source mapped in memory to the given path.\n     *  \n     *  ```js\n     *  await memStore.delete(\"/path/to/doc\");\n     *  ```\n     *  \n     *  - If path is `path/to/x/../doc`, the entry `/path/to/doc` will be deleted\n     */\n    delete (path) {\n        const normPath = this.normalizePath(path);\n        return this._content.delete(normPath);\n    }\n\n\n    /**\n     *  memStore.deleteAll - method\n     *  ------------------------------------------------------------------------\n     *  Erases all the docs whos path starts with the given path.\n     *  \n     *  ```js\n     *  await memStore.deleteAll(\"/path/to/\");\n     *  ```\n     *  \n     *  - If path is `path/to/x/../dir`, the entres starting by `/path/to/dir/` \n     *    will be deleted\n     */\n    deleteAll (path) {\n        const normPath = this.normalizePath(`${path}/`);\n        for (let docPath of this._content.keys()) {\n            if (docPath.indexOf(normPath) === 0) {\n                this.delete(docPath);\n            }\n        }\n    }\n}\n\nmodule.exports = MemoryStore;\n\n\n//# sourceURL=webpack:////home/marcello/mdb/Code/olojs/lib/memory-store.js?");

/***/ }),

/***/ "../../lib/router.js":
/*!***************************************************!*\
  !*** /home/marcello/mdb/Code/olojs/lib/router.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("\nconst document = __webpack_require__(/*! ./document */ \"../../lib/document.js\");\nconst pathlib = __webpack_require__(/*! path */ \"../../node_modules/path-browserify/index.js\");\nconst Store = __webpack_require__(/*! ./store */ \"../../lib/store.js\");\n\n\n\n/**\n *  Router\n *  ============================================================================\n *  This store is a container for other stores and routes the `read`, `list`,\n *  `write` and `delete` requests to the store best matching the path.\n *  \n *  ```js\n *  routes = {\n *      \"/path/to/store_1/\": store_1,\n *      \"/path/to/store_2/\": store_2,\n *      ...\n *  };\n *  \n *  router = new Router(routes);\n *  ```\n *  \n *  Every time a `read`, `list`, `write`, `delete` or `deleteAll` method is\n *  called on a `path`, the router delegates to the corresponding method of\n *  the store matching the path. For example, with reference to the router \n *  declaration above:\n *  \n *  - `router.read('/path/to/store_1/path/to/doc')` will result in a call to\n *    `store_1.read('/path/to/doc')`\n *  - `router.read('/path/to/store_2/path/to/doc')` will result in a call to\n *    `store_2.read('/path/to/doc')`\n *  \n *  If no match is found, it will behave as empty store, which is: `read` will\n *  return an empty string, `list` will return an empty array, `write`,\n *  `delete` and `deleteAll` will throw a `WriteOperationNotAllowed` error.\n *  \n *  The constructor will ignore the properties of the `routes` object which are \n *  not valid stores, that is objects that do not have any of the methods \n *  `read`, `list`, `write`, `delete`, `deleteAll`, `createContext`, `load`.\n *  The easiest way to create a valid store is by extending the `Store` class.\n */\nclass Router extends Store {\n\n    constructor (routes) {\n        super();\n\n        // Initialize routes\n        const validRoutes = filterObject(isStore, routes);\n        const normalizedRoutes = renameKeys(normalizeDirPath, validRoutes);\n        this._routes = sortObject(normalizedRoutes);\n    }\n\n    *_iterMatches (path) {\n        const normPath = this.normalizePath(path);\n        for (let [routeId, store] of this._routes.entries()) {\n            if (normPath.indexOf(routeId) === 0) {\n                const subPath = normPath.slice(routeId.length-1);\n                yield [store, subPath];\n            }\n        }\n    }\n\n\n    // Finds the route that best matches the given document path and returns\n    // the corresponding store and the path relative to the matching route\n    match (path) {\n        const matches = this._iterMatches(path);\n        return matches.next().value || [null, path];\n    }\n\n\n    /**\n     *  router.read - async method\n     *  ------------------------------------------------------------------------\n     *  Retrieves an olo-document from the matching sub-store.\n     *  \n     *  ```js\n     *  router = new Router({\n     *      \"/path/to/store_1/\": store_1,\n     *      \"/path/to/store_2/\": store_2,\n     *      ...\n     *  })\n     *  \n     *  source = await router.read(\"/path/to/store_i/sub/path/to/doc\");\n     *  ```\n     *  \n     *  - When requesting `/path/to/store_i/sub/path/to/doc`, it returns\n     *    `await store_i.read('/sub/path/to/doc')`.\n     *  - When no store is mounted on `/path/to/store_i/`, it returns an empty\n     *    string\n     */\n    async read (path) {\n        const [store, subPath] = this.match(path);\n        return store ? await store.read(subPath) : await super.read(path);\n    }\n\n\n    /**\n     *  router.list - async method\n     *  ------------------------------------------------------------------------\n     *  Returns the list of entry names under the passed path, considering all\n     *  the mount points.\n     *  \n     *  ```js\n     *  router = new Router({\n     *      \"/path/to/\": store0,\n     *      \"/path/to/a/s1\": store1,\n     *      \"/path/to/b/s2\": store2,\n     *      \"/path/to/s3\": store3\n     *  });\n     *  \n     *  entries = await router.list(\"/path/to\");\n     *  ```\n     *  In the given example, the array `entries` will contain `[\"a/\", \"b/\",\n     *  \"s2\"]`, plus all the items returned by `await store0.list(\"/\")`.\n     *  \n     *  If no mounted stores matches the given path, then an empty array is\n     *  returned.\n     */\n    async list (path) {\n        const dirPath = normalizeDirPath(path);\n        const entries = [];\n        for (let [store, subPath] of this._iterMatches(dirPath)) {\n            mergeLists(entries, await store.list(subPath));\n        }\n        for (let [routePath, store] of this._routes.entries()) {\n            if (routePath !== dirPath && routePath.indexOf(dirPath) === 0) {\n                const subPath = routePath.slice(dirPath.length);\n                const entry = subPath.slice(0, subPath.indexOf('/')+1);\n                pushIfMissing(entries, entry);\n            }\n        }\n        return entries;\n    }\n\n\n    /**\n     *  router.write - async method\n     *  ------------------------------------------------------------------------\n     *  Modifies an olo-document contained in the matching sub-store.\n     *  \n     *  ```js\n     *  router = new Router({\n     *      \"/path/to/store_1/\": store_1,\n     *      \"/path/to/store_2/\": store_2,\n     *      ...\n     *  })\n     *  \n     *  await router.write(\"/path/to/store_i/sub/path/to/doc\", source);\n     *  ```\n     *  \n     *  - When `/path/to/store_i/sub/path/to/doc` is passed, it calls\n     *    `await store_i.write('/sub/path/to/doc', source)`.\n     *  - When no store is mounted on `/path/to/store_i`, it throws a\n     *    `Router.WriteOperationNotAllowedError`.\n     */\n    async write (path, source) {\n        const [store, subPath] = this.match(path);\n        return store ? await store.write(subPath, source) : await super.write(path, source);\n    }\n\n\n    /**\n     *  router.delete - async method\n     *  ------------------------------------------------------------------------\n     *  Deletes an olo-document contained in the matching sub-store.\n     *  \n     *  ```js\n     *  router = new Router({\n     *      \"/path/to/store_1/\": store_1,\n     *      \"/path/to/store_2/\": store_2,\n     *      ...\n     *  })\n     *  \n     *  await router.delete(\"/path/to/store_i/sub/path/to/doc\");\n     *  ```\n     *  \n     *  - When `/path/to/store_i/sub/path/to/doc` is passed, it calls\n     *    `await store_i.delete('/sub/path/to/doc')`.\n     *  - When no store is mounted on `/path/to/store_i/`, it throws a\n     *    `Router.WriteOperationNotAllowedError`.\n     */\n    async delete (path) {\n        const [store, subPath] = this.match(path);\n        return store ? await store.delete(subPath) : await super.delete(path);\n    }\n\n\n    /**\n     *  router.deleteAll - async method\n     *  ------------------------------------------------------------------------\n     *  Deletes all the documents matching the given path.\n     *  \n     *  ```js\n     *  router = new Router({\n     *      \"/path/to/store_1/\": store_1,\n     *      \"/path/to/store_2/\": store_2,\n     *      ...\n     *  })\n     *  \n     *  await router.deleteAll(\"/path/to/store_i/sub/path/to/doc\");\n     *  ```\n     *  \n     *  - When `/path/to/store_i/sub/path/to/doc` is passed, it calls\n     *    `await store_i.deleteAll('/sub/path/to/doc')`.\n     *  - When no store is mounted on `/path/to/store_i/`, it throws a\n     *    `Router.WriteOperationNotAllowedError`.\n     */\n    async deleteAll (path) {\n        const [store, subPath] = this.match(path);\n        return store ? await store.deleteAll(subPath) : await super.deleteAll(path);\n    }\n}\n\nmodule.exports = Router;\n\n\n\n// -----------------------------------------------------------------------------\n//  SERVICE FUNCTIONS\n// -----------------------------------------------------------------------------\n\nconst isStore = obj => {\n    if (typeof obj.read !== \"function\") return false;\n    if (typeof obj.list !== \"function\") return false;\n    if (typeof obj.write !== \"function\") return false;\n    if (typeof obj.delete !== \"function\") return false;\n    if (typeof obj.deleteAll !== \"function\") return false;\n    if (typeof obj.createContext !== \"function\") return false;\n    if (typeof obj.load !== \"function\") return false;\n    return true;\n};\n\nconst renameKeys = (ren, obj) => {\n    const newObj = {};\n    for (let key in obj) newObj[ren(key)] = obj[key];\n    return newObj;\n}\n\nconst sortObject = obj => {\n    const keys = Object.keys(obj).sort().reverse();\n    const map = new Map();\n    for (let key of keys) map.set(key, obj[key]);\n    return map;\n}\n\nconst filterObject = (test, obj) => {\n    const newObj = {};\n    for (let key in obj) if (test(obj[key])) newObj[key] = obj[key];\n    return newObj;\n}\n\nconst pushIfMissing = (list, item) => {\n    if (list.indexOf(item) === -1) list.push(item);\n}\n\nconst mergeLists = (list1, list2) => {\n    for (let item of list2) pushIfMissing(list1, item);\n}\n\nconst normalizeDirPath = path => Router.prototype.normalizePath(`${path}/`);\n\n\n//# sourceURL=webpack:////home/marcello/mdb/Code/olojs/lib/router.js?");

/***/ }),

/***/ "../../lib/store.js":
/*!**************************************************!*\
  !*** /home/marcello/mdb/Code/olojs/lib/store.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const pathlib = __webpack_require__(/*! path */ \"../../node_modules/path-browserify/index.js\");\nconst isDirectory = path => path.slice(-1) === '/';\nconst document = __webpack_require__(/*! ./document */ \"../../lib/document.js\");\n\nconst isValidName = name => typeof name === 'string' && /^[a-z_A-Z]+[a-z_A-Z0-9]*$/.test(name);\n\n\n/**\n *  Store\n *  ============================================================================\n *  This is the base class to be used to create olojs document stores.\n *  When instantiatete directly it behaves like a read-only empty store.\n *\n *  ```js\n *  // A read-only empty store\n *  store = new Store();\n *  \n *  // A store implementation\n *  class ChildStore extends Store {\n *      async read (path) { ... }\n *      async list (path) { ... }\n *      async write (path, source) { ... }\n *      async delete (path) { ... }\n *      async deleteAll (path) { ... }\n *  ```\n */\nclass Store {\n\n    constructor () {\n        const store = this;\n\n        this.globals = {\n\n            async import (docId) {\n                const targetId = resolveId(this.__path__, docId);\n                const targetContext = store.createContext(targetId);\n                const targetPath = targetContext.__path__;\n                if (!this.$cache.has(targetPath)) {\n                    const source = await store.read(targetPath);\n                    const evaluate = document.parse(source);\n                    this.$cache.set(targetPath, [source, evaluate]);\n                }\n                const [targetSource, evaluateTarget] = this.$cache.get(targetPath);\n                return await evaluateTarget(targetContext);\n            }\n        };\n    }\n\n    /**\n     *  store.read - async method\n     *  ------------------------------------------------------------------------\n     *  Returns the source of the document mapped in this store to the given\n     *  path.\n     *\n     *  ```js\n     *  source = await store.read(\"/path/to/doc\");\n     *  ```\n     *\n     *  Every implmenentation of this method should behave according to the\n     *  following standard:\n     *\n     *  - It should return a string\n     *  - It should throw `Store.ReadPermissionDeniedError` if the store\n     *    instance has no read permission on the given path.\n     *\n     *  When instantiated directly, the base store `read` method returns always\n     *  an empty string.\n     */\n    async read (path) {\n        return \"\";\n    }\n\n\n    /**\n     *  store.list - async method\n     *  ------------------------------------------------------------------------\n     *  Returns the names of the items contained under the given path.\n     *\n     *  ```js\n     *  items = await store.list(\"/path/to\");\n     *  ```\n     *\n     *  Every implmenentation of this method should behave according to the\n     *  following standard:\n     *\n     *  - It should returns an array of strings, each containing the name of a\n     *    child item (a document or a container) of the given path; container\n     *    names differ from document names in that they end with a `/`.\n     *  - It should throw `Store.ReadPermissionDeniedError` if the store\n     *    instance has no read permission on the given path.\n     *  - It should throw `Store.ReadOperationNotAllowedError` if the store\n     *    doesn't implement listing.\n     *  \n     *  For example, if `store` contains the following documents:\n     *  \n     *  - /path/to/doc1\n     *  - /path/to/doc2\n     *  - /path/to/dir/doc3\n     *  \n     *  then then `srotes.list('/path/to')` resolves `['doc1', 'doc2', 'dir/']`.\n     *  \n     *  When instantiated directly, the base store `list` method returns always\n     *  an empty array.\n     */\n    async list (path) {\n        return [];\n    }\n\n\n    /**\n     *  store.write - async method\n     *  ------------------------------------------------------------------------\n     *  Changes the source of the document at the given path.\n     *  \n     *  ```js\n     *  await store.write(\"/path/to/doc\", \"This is the doc content.\");\n     *  ```\n     *  \n     *  Every implmenentation of this method should behave according to the\n     *  following standard:\n     *  \n     *  - After calling this method on `path`, then `store.read(path)` should\n     *    return the new source.\n     *  - It should throw `Store.WritePermissionDeniedError` if the store\n     *    instance has no write permission on the given path.\n     *  - It should throw `Store.WriteOperationNotAllowedError` if the store\n     *    is read-only.\n     *  \n     *  When instantiated directly, the base store `write` method always throws\n     *  `Store.WriteOperationNotAllowedError`.\n     */\n    async write (path, source) {\n        throw new this.constructor.WriteOperationNotAllowedError(this.normalizePath(path));\n    }\n\n\n    /**\n     *  store.delete - async method\n     *  ------------------------------------------------------------------------\n     *  Removes a document from the store.\n     *  \n     *  ```js\n     *  await store.delete(\"/path/to/doc\");\n     *  ```\n     *  \n     *  Every implmenentation of this method should behave according to the\n     *  following standard:\n     *\n     *  - After calling this method on `path`, then `store.read(path)` should\n     *    return an empty string and `store.list` should not return the name\n     *    of the removed document.\n     *  - It should throw `Store.WritePermissionDeniedError` if the store\n     *    instance has no write permission on the given path.\n     *  - It should throw `Store.WriteOperationNotAllowedError` if the store\n     *    is read-only.\n     *  \n     *  When instantiated directly, the base store `delete` method always throws\n     *  `Store.WriteOperationNotAllowedError`.\n     */\n    async delete (path) {\n        throw new this.constructor.WriteOperationNotAllowedError(this.normalizePath(path));\n    }\n\n\n    /**\n     *  store.deleteAll - async method\n     *  ------------------------------------------------------------------------\n     *  Removes all the documents whose path starts with a given path.\n     *\n     *  ```\n     *  await store.deleteAll(\"/path/to/\");\n     *  ```\n     *\n     *  Every implmenentation of this method should behave according to the\n     *  following standard:\n     *\n     *  - After calling this method on `/path/to`, then `store.read(\"/path/to/any/doc\")`\n     *    should return an empty string and `store.list` should not return the name\n     *    of any of the removed documents.\n     *  - It should throw `Store.WritePermissionDeniedError` if the store\n     *    instance has no write permission on the given path.\n     *  - It should throw `Store.WriteOperationNotAllowedError` if the store\n     *    is read-only.\n     *  \n     *  When instantiated directly, the base store `deleteAll` method always throws\n     *  `Store.WriteOperationNotAllowedError`.\n     */\n    async deleteAll (path) {\n        throw new this.constructor.WriteOperationNotAllowedError(this.normalizePath(path));\n    }\n\n\n    /**\n     *  store.createContext - method\n     *  ------------------------------------------------------------------------\n     *  Creates a document context specific to a given store document.\n     *\n     *  ```js\n     *  context = store.createContext(docId);\n     *  ```\n     *\n     *  - `docId` is a combination of a path and a query string (e.g.\n     *    `/path/to/doc?x=10;y=20;z=30`)\n     *  - `context` is a valid document context\n     *  - `context.__path__` contains the path portion of `docId`\n     *  - `context.argns` contains the namespace passed as query string with\n     *    `docId`. For example, if `docId = /path/to/doc?x=10;y=20;z=30`, then\n     *    the `argns` namespace will be `{x:10, y:20, z:30}`.\n     *  - `context.import` is a function that returns a store document namespace\n     *    given its id. If the path portion of the id is a relative path, it\n     *    will be resolved agains `context.__path__`.\n     *  \n     *  The `createContext` method is not meant to be overridden.\n     */\n    createContext (docId) {\n        const {path, argns} = Store.parseId(docId);\n        return document.createContext(\n            this.globals,\n            {$cache: new Map()},\n            {__path__: path, argns: argns}\n        );\n    }\n\n\n    /**\n     *  store.load - async method\n     *  ------------------------------------------------------------------------\n     *  Reads, evaluates and renders the document identified by the passed id.\n     *\n     *  ```js\n     *  {source, context, namespace, text} = await store.load(docId);\n     *  ```\n     *\n     *  - `docId` is a combination of a path and a query string (e.g.\n     *    `/path/to/doc?x=10;y=20;z=30`)\n     *  - `source` is the document source returned by `store.read`\n     *  - `context` is the document context returned by `store.createContext`\n     *  - `namespace` is the document namespace evaluated in `context`\n     *  - `text` is the document rendered content\n     *  \n     *  The `load` method is not meant to be overridden.\n     */\n    async load (docId) {\n        const doc = {};\n        doc.context = this.createContext(docId);\n        doc.source = await this.read(doc.context.__path__);\n        const evaluate = document.parse(doc.source);\n        doc.namespace = await evaluate(doc.context);\n        doc.text = await doc.context.str(doc.namespace);\n        return doc;\n    }\n\n\n    normalizePath (path) {\n        return pathlib.normalize(`/${path}`);\n    }\n}\n\n\n// Parses the given id string into its a store name (uri scheme), a path\n// (uri authority + uri path) and a query (uri query)\nStore.parseId = id => {\n    const queryIndex = id.indexOf('?');\n    const path = queryIndex === -1 ? id : id.slice(0, queryIndex);\n    const query = queryIndex === -1 ? \"\" : id.slice(queryIndex+1);\n    return {\n        path: pathlib.normalize(`/${path}`),\n        argns: parseParameters(...iterQuery(query))\n    }\n}\n\n\n// Given a list of argument ['par1=val1', 'par2=val2', 'par3=val3', ...],\n// converts it to an object ontaining the ke-value pair contained in the list\nfunction parseParameters (...keyValuePairs) {\n    const argns = {};\n    for (let keyValuePair of keyValuePairs) {\n        const separatorIndex = keyValuePair.indexOf(\"=\");\n        if (separatorIndex === -1) {\n            let name = keyValuePair.trim();\n            if (isValidName(name)) argns[name] = true;\n        } else {\n            let name = keyValuePair.slice(0, separatorIndex).trim();\n            if (isValidName(name)) {\n                let string = keyValuePair.slice(separatorIndex+1).trim();\n                let number = Number(string);\n                argns[name] = isNaN(number) ? string : number;\n            }\n        }\n    }\n    return argns;\n}\n\n// Iterates over all the key-value pairs contained in the query, considering\n// both `&` and `;` as separators.\nfunction *iterQuery (query) {\n    for (let ampParam of query.split('&')) {\n        for (let param of ampParam.split(';')) {\n            yield param;\n        }\n    }\n}\n\n\n\n// Base class for Store.ReadPermissionDeniedError and\n// Store.WritePermissionDeniedError.\nclass PermissionDeniedError extends Error {\n\n    constructor (operation, path) {\n        super(`Permission denied: ${operation} ${path}`);\n    }\n}\n\n/**\n *  Store.ReadPermissionDeniedError - class\n *  ----------------------------------------------------------------------------\n *  Error thrown when attempting a read operation for which the store instance\n *  has no read access.\n *\n *  ```js\n *  throw new Store.ReadPermissionDeniedError('/path/to/doc');\n *  ```\n */\nStore.ReadPermissionDeniedError = class extends PermissionDeniedError {\n\n    constructor (path) {\n        super(\"READ\", path);\n    }\n}\n\n/**\n *  Store.WritePermissionDeniedError - class\n *  ----------------------------------------------------------------------------\n *  Error thrown when attempting a write operation for which the store instance\n *  has no write access.\n *\n *  ```js\n *  throw new Store.WritePermissionDeniedError('/path/to/doc');\n *  ```\n */\nStore.WritePermissionDeniedError = class extends PermissionDeniedError {\n\n    constructor (path) {\n        super(\"WRITE\", path);\n    }\n}\n\n\n\n// Base class for Store.ReadOperationNotAllowedError and\n// Store.WriteOperationNotAllowedError.\nclass OperationNotAllowedError extends Error {\n\n    constructor (operation, path) {\n        super(`Operation not allowed: ${operation} ${path}`);\n    }\n}\n\n/**\n *  Store.ReadOperationNotAllowedError - class\n *  ----------------------------------------------------------------------------\n *  Error thrown when the read operation is not defined on the store.\n *\n *  ```js\n *  throw new Store.ReadOperationNotAllowedError('/path/to/doc');\n *  ```\n */\nStore.ReadOperationNotAllowedError = class extends OperationNotAllowedError {\n\n    constructor (path) {\n        super(\"READ\", path);\n    }\n}\n\n/**\n *  Store.WriteOperationNotAllowedError - class\n *  ----------------------------------------------------------------------------\n *  Error thrown when the write operation is not defined on the store.\n *\n *  ```js\n *  throw new Store.WriteOperationNotAllowedError('/path/to/doc');\n *  ```\n */\nStore.WriteOperationNotAllowedError = class extends OperationNotAllowedError {\n\n    constructor (path) {\n        super(\"WRITE\", path);\n    }\n}\n\n\n\nmodule.exports = Store;\n\n\nfunction resolveId (basePath, relativeId) {\n    const relativePath = relativeId.split('?')[0];\n    const query = relativeId.slice(relativePath.length);\n    if (relativePath[0] === '/') {\n        return pathlib.normalize(relativePath) + query;\n    } else {\n        const baseDirPath = basePath.slice(-1) === '/' ? basePath : pathlib.resolve(basePath, '..');\n        return pathlib.join(baseDirPath, relativePath) + query;\n    }\n}\n\n\n//# sourceURL=webpack:////home/marcello/mdb/Code/olojs/lib/store.js?");

/***/ }),

/***/ "../../lib/viewer.js":
/*!***************************************************!*\
  !*** /home/marcello/mdb/Code/olojs/lib/viewer.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const DOMPurify = __webpack_require__(/*! dompurify */ \"../../node_modules/dompurify/dist/purify.js\");\n\n\n\n/**\n *  Viewer - function\n *  ============================================================================\n *  The Viewer function takes a DOM element and an olojs Store as input and\n *  binds the `innerHTML` content of the element to the rendering of the document \n *  identified by the `src` attribute in the given store. For example:\n *  \n *  ```html\n *  \n *  <!-- This is the element that will contain the document rendering -->\n *  <div id=\"viewer-id\" src=\"/path/to/doc\"></div>\n *  \n *  <script>\n *      \n *      <!-- retrieve the host element and create a store -->\n *      domElement = document.querySelector(\"#viewer-id\");\n *      store = new olojs.HTTPStore(\"http://store-hostname\");\n *      \n *      <!-- bind the host element to the store -->\n *      viewer = olojs.Viewer(domElement, store);\n *      \n *  </store>\n *  ```\n *  \n *  Once the binding is created by calling the `Viewer` constructor, the\n *  document identified by the `src` attribute (`/path/to/doc` in the example)\n *  will be loaded from the given store, then rendered, sanitized and injected\n *  as `innerHTML` in the host element.\n *  \n *  Every time the `src` attribute changes, the host element content will be\n *  automatically updated. \n *  \n *  The Viewer constructor returns the [MutationObserver](https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver)\n *  used to react to `src` attribute changes.\n */\nmodule.exports = function (element, store) {\n    \n    const observer = new MutationObserver(async mutations => {\n        for (let mutation of mutations) {\n            if (mutation.type === \"attributes\" && mutation.attributeName === \"src\") {\n                const docId = mutation.target.getAttribute('src');\n                const {text} = await store.load(docId);\n                mutation.target.innerHTML = DOMPurify.sanitize(text);\n            }\n        }\n    });\n    \n    observer.observe(element, {\n        attributes: true, \n        attributeFilter: ['src']\n    });\n    \n    return observer;\n}\n\n\n//# sourceURL=webpack:////home/marcello/mdb/Code/olojs/lib/viewer.js?");

/***/ }),

/***/ "../../node_modules/@onlabsorg/swan-js/index.js":
/*!******************************************************************************!*\
  !*** /home/marcello/mdb/Code/olojs/node_modules/@onlabsorg/swan-js/index.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n *  swan\n *  ============================================================================\n *  The swan JavaScript API include a `parse` function and a `createContext`\n *  function to parse and evaluate expressions. \n *  Furthermore, it contains a `defineModule` to add custom javascript modules \n *  to the swan standard library and the types `Tuple` and `Undefined` which\n *  are the only two swan types that do not correspond to a javascript negative\n *  type.\n */\n \nconst {Tuple, Undefined, parse, context} = __webpack_require__(/*! ./lib/interpreter */ \"../../node_modules/@onlabsorg/swan-js/lib/interpreter.js\");\nconst modules = __webpack_require__(/*! ./lib/modules */ \"../../node_modules/@onlabsorg/swan-js/lib/modules.js\");\ncontext.require = modules.require;\n\n\n\n/**\n *  swan.parse - function\n *  ----------------------------------------------------------------------------\n *  Parses a swan expression and returns a function that maps a context to an\n *  expression value.\n *  \n *  ```js\n *  evaluate = swan.parse(expression);\n *  value = await evaluate(context);\n *  ```\n *  - `espression` is a string containing any valid swan expression\n *  - `context` is a valid swan expression context\n *  - `value` is the value that expression result has in the given context\n */\n\nexports.parse = function (expression) {\n    const evaluate = parse(expression);\n    return async (ctx) => {\n        if (!context.isPrototypeOf(ctx)) {\n            throw new Error(\"Invalid context!\");\n        }\n        const value = await evaluate(ctx);\n        return Tuple(value).normalize();\n    }\n}\n\n\n\n/**\n *  swan.createContext - function\n *  ----------------------------------------------------------------------------\n *  Creates a valid expression context.\n *  ```js\n *  context = swan.createContext(...namespaces)\n *  ```\n *  - `namespaces` is a list of objects `ns1, ns2, ns3, ...` that will be merged\n *    to the core swan context\n *  - `context` is an object containing all the core context properties, plus\n *    all the properties of the passed namespace, added in order.\n */\nexports.createContext = function (...namespaces) {\n    \n    if (namespaces.length === 0) {\n        return context.$extend({});\n    }\n    \n    let ctx = context;\n    for (let namespace of namespaces) {\n        ctx = ctx.$extend(namespace);\n    }\n    return ctx;\n}\n\n\n\n/**\n *  swan.defineModule - function\n *  ----------------------------------------------------------------------------\n *  Adds a module to the swan library. The module can be then loaded with\n *  the built-in `require` function.\n *  ```js\n *  swan.defineModule(modulePath, moduleLoader)\n *  ```\n *  - `modulePath` a `/-separated` path that identifies the module\n *  - `moduleLoader` an asynchronous function that returns the module\n */\nexports.defineModule = modules.define;\n\n\n\n/**\n *  swan.Tuple - function\n *  ----------------------------------------------------------------------------\n *  This function creates a swan tuple object.\n *  ```js\n *  tuple = Tuple(item1, item2, ...)\n *  tuple instanceof Tuple      // true\n *  ```\n */\nexports.Tuple = Tuple;\n\n\n\n/**\n *  swan.Undefined - function\n *  ----------------------------------------------------------------------------\n *  This function creates a swan undefined object.\n *  ```js\n *  undef = Undefined(...args)\n *  undef instanceof Undefined      // true\n *  ```\n */\nexports.Undefined = function (...args) {\n    return new Undefined(...args);\n}\nexports.Undefined.prototype = Undefined.prototype;\n\n\n//# sourceURL=webpack:////home/marcello/mdb/Code/olojs/node_modules/@onlabsorg/swan-js/index.js?");

/***/ }),

/***/ "../../node_modules/@onlabsorg/swan-js/lib/interpreter.js":
/*!****************************************************************************************!*\
  !*** /home/marcello/mdb/Code/olojs/node_modules/@onlabsorg/swan-js/lib/interpreter.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n *  SWAN INTERPRETER MODULE\n *  ============================================================================\n *   \n *  This module exposes a `parse` function that takes a text containin a swan \n *  expression and returns an `evaluate` function that, once run returns the \n *  value of the original expression.\n *  \n *      evaluate = interpreter.parse(\"2 + 3 * 4\");\n *     value = await evaluate(context);    // -> 24\n *  \n *  The context object passed to the `evaluate` function must have \n *  `interpreter.context` as prototype. \n *  \n *     context = interpreter.context.$extend({pi:3.14, double: x => 2*x})\n *  \n *  All the properties added to the context (e.g. `pi` and `double` in the \n *  example above) can be referenced in the expression.\n *\n *  ----------------------------------------------------------------------------\n *  \n *  Besides the two core exports `interpreter.parse` and `interpreter.context`,\n *  this module exports also the following two calsses:\n *  \n *  - interpreter.Tuple\n *  - interpreter.Undefined\n *  \n *  Tuple and Undefined are the only two swan type that do not already exist in \n *  javascript.\n *  \n *  `Tuple` is the swan product type (item1, item2, ...). The elements of a tuple \n *  are called `items`. Each item can also be seen as a tuple made of only one\n *  element. Tuples are flattened, therefore a tuple cannot contain nested tuples; \n *  in other words, the tuple (i1, (i2, i3), i4) is equivalent to the tuple \n *  (i1, i2, i3, i4).\n *  \n *  The empty tuple () is the unit type of swan and it is used to represent \n *  the concept of nothingness. It is therefore also called `NOTHING`.\n *  \n *  `Undefined` is the value an expression returns when the results of the \n *  expression is not defined. For example the division of number by NOTHING is \n *  not defined in swan, therefore the expression `3 / ()` will return an \n *  instance of undefined.\n *  \n *  swan doesn't have the concept of Exception: where other languages throw an\n *  exception, swan returns an Undefined value. The Undefined objects contain \n *  also information that can help the swan user to trace back the origin of the \n *  undefined value (think at it as a sort of error stack).\n *  \n *  ----------------------------------------------------------------------------\n *\n *  Besides the Tuple product type and the Undefined item type, swan has the\n *  following item types. Each of them corresponds to a JavaScript type.\n *  \n *  - Boolean       (equivalent to the JavaScript Boolean type)\n *  - Number        (equivalent to the JavaScript Number type)\n *  - String        (equivalent to the JavaScript String type)\n *  - List          (equivalent to the JavaScript Array type)\n *  - Namespace     (equivalent to the JavaScript Object type)\n *  - Function      (equivalent to the JavaScript Function type)\n */\n\n\n\n\n\n// -----------------------------------------------------------------------------\n//  TYPE DETECTION\n// -----------------------------------------------------------------------------\n\n// This function takes an item as input and returns its type name\nfunction detectItemType (item) {\n        \n    // if primitive\n    switch (typeof item) {\n        case \"boolean\"  : return \"Boolean\";\n        case \"number\"   : return \"Number\";\n        case \"string\"   : return \"String\";\n        case \"function\" : return \"Function\";\n    }    \n    \n    // It must be an object!\n    \n    // if a List\n    if (Array.isArray(item)) return \"List\";\n    \n    // if undefined\n    if (item instanceof Undefined) return \"Undefined\";\n    \n    // if a primitive object\n    switch (Object.prototype.toString.call(item)) {\n        case '[object Boolean]'  : return \"Boolean\";\n        case '[object Number]'   : return \"Number\";\n        case '[object String]'   : return \"String\";\n        case '[object Function]' : return \"Function\";\n    }\n    \n    // It is a Namespace!\n    return \"Namespace\";        \n}\n\n// The following functions return true or false if the passed item matches a certain type\nconst isNothing = x => x === null || x === undefined || Number.isNaN(x);\nconst isBoolean = x => typeof x === 'boolean' || (typeof x === 'object' && Object.prototype.toString.call(x) === '[object Boolean]')\nconst isNumber = x => typeof x === 'number' || (typeof x === 'object' && Object.prototype.toString.call(x) === '[object Number]')\nconst isFunction = x => typeof x === 'function' || (typeof x === 'object' && Object.prototype.toString.call(x) === '[object Function]')\nconst isString = x => typeof x === 'string' || (typeof x === 'object' && Object.prototype.toString.call(x) === '[object String]');\nconst isList = x => x && Array.isArray(x);\nconst isNamespace = x => detectItemType(x) === 'Namespace';\n\n// The following function checks if a string is a valid swan identifier\nconst isName = x => isString(x) && /^[a-z_A-Z]+[a-z_A-Z0-9]*$/.test(x);\n\n// This function takes two items as input and returns the concatenation of \n// their type names. For example `detectType(1,[])` returns \"Number,List\".\n// This is mostly used by binary operation handlers to decide at runtime how\n// to reduce the two operators, based on their type.\nfunction detectPairType (value1, value2) {\n    return `${detectItemType(value1)},${detectItemType(value2)}`;\n}\n\n\n\n\n\n// -----------------------------------------------------------------------------\n//  TYPE CASTING\n// -----------------------------------------------------------------------------\n\n// This functions defines the boolean type casting behaviour of swan\nfunction convertItemToBoolean (item) {\n    switch (detectItemType(item)) {\n        \n        case \"Boolean\"  : return item;                              // A boolean is already a boolean\n        case \"Number\"   : return item !== 0;                        // A number is false only if it is 0\n        case \"String\"   : return item !== \"\";                       // A string is false only if it is empty\n        case \"List\"     : return item.length !== 0;                 // A list is false only if it is empty\n        case \"Namespace\": return countNamespaceNames(item) !== 0;   // A namespace is false only if it is empty\n        case \"Function\" : return true;                              // A function is always true\n        \n        // The following should never run!\n        default         : throw new Error(`Cannot convert ${item} to boolean`);\n    }                \n}\n\n\n\n\n\n// -----------------------------------------------------------------------------\n//  TUPLES\n// -----------------------------------------------------------------------------\n\n// Shortcut for `new TupleObject`. In addition to that, this function will not\n// create a new tuple if the passed parameter is already a TupleObject.\nfunction Tuple (...items) {\n    if (items.length === 1 && items[0] instanceof TupleObject) return items[0];\n    return new TupleObject(...items);\n}\n\n// This class defines the behaviour of a the swan product type. Since every\n// value in swan is a Tuple, this class is very important and you see it used\n// a lot in this module.\nclass TupleObject {\n\n    // Creates an Tuple instance given a sequence of values. The passed values\n    // can items and/or tuples. The iterator function will take care of flattening\n    // the tuple, so that `new TupleObject(a, new TupleObject(b, c))` is\n    // equivalent to `new TupleObject(a, b, c)`.\n    constructor (...items) {\n        this._items = items;\n    }\n    \n    // Yields one by one all the items contained in the tuple instance, flattening\n    // nested tuple. In particular, NOTHING values are ignored, because (a,(),b) \n    // should consistently be flattened to (a,b).\n    *[Symbol.iterator] () {\n        for (let item of this._items) {\n            if (item instanceof this.constructor) {\n                for (let subItem of item) yield subItem;\n            } else if (!isNothing(item)) {\n                yield item;\n            }\n        }\n    }\n    \n    // This method returns true if the Tuple instance has no elements\n    isEmpty () {\n        let iterator = this[Symbol.iterator]();\n        let first = iterator.next();\n        return first.done;\n    }\n    \n    // Applies synchronously the passed function to each item of this tuple\n    // and returns the resulting tuple.\n    mapSync (f) {\n        let image = new this.constructor();\n        for (let item of this) {\n            image = new this.constructor(image, f(item));\n        }\n        return image;\n    }\n\n    // Applies asynchronously the passed function to each item of this tuple\n    // and returns the resulting tuple.\n    async mapAsync (f) {\n        let image = new this.constructor();\n        for (let item of this) {\n            image = new this.constructor(image, await f(item));\n        }\n        return image;\n    }\n    \n    // If this tuple is empty it returns `null` (JavaScript equivalent to NOTHING);\n    // if this tuple contains only one item, it returns the tuple;\n    // if this tuple contains two or more items, it returns this tuple itself.\n    normalize () {\n        let iterator = this[Symbol.iterator]();\n        let first = iterator.next();\n        if (first.done) return null;\n        return iterator.next().done ? first.value : this;\n    }\n}\n\n// Make sure that a tuple created with the Tuple function is recognized as\n// `instanceof` the Tuple function.\nTuple.prototype = TupleObject.prototype;\n\n// This function takes two tuples (x1, x2, ...) and (y1, y2, ...) as argument\n// and yields the pairs [x1, y1], [x2, y2], etc. If one of the tuples is\n// shorter that the other, the missing items are replaced by null (NOTHING).\n// For example (x1, x2, x3) and (y1, y2) pair to [x1,y1], [x2,y2], [x3,null].\nfunction *iterPairs (x, y) {\n    const iX = Tuple(x)[Symbol.iterator]();\n    const iY = Tuple(y)[Symbol.iterator]();\n    while (true) {\n        let x = iX.next();\n        let y = iY.next();\n        if (x.done && y.done) break;\n        yield [x.value, y.value];\n    }    \n}\n\n// This function takes two tuples (x1, x2, ...) and (y1, y2, ...) as argument\n// and returns the tuple (map(x1,y1), map(x2,y2), ...).\n// This function is often used by binary operation which normally operates on\n// each pair individually; for example (x1,x2) + (y1,y2) = (x1+y1, x2+y2).\nfunction mapPairs (x, y, map) {\n    const pairsMapping = [];\n    for (let [xItem, yItem] of iterPairs(x,y)) {\n        pairsMapping.push( map(xItem, yItem) );\n    }\n    return Tuple(...pairsMapping).normalize();\n}\n\n\n\n\n// -----------------------------------------------------------------------------\n//  NAMESPACES\n// -----------------------------------------------------------------------------\n//  A swan namespace is a subset of a JavaScript object. The keys are called\n//  `names` and all the keys that are not valid identifiers (see isName function),\n//  are ignored.\n// -----------------------------------------------------------------------------\n\n// This function returns an array of all the valid names contained in the \n// passed namespace.\nfunction listNamespaceNames (namespace) {\n    const names = [];\n    for (let name in namespace) {\n        if (isName(name)) names.push(name);\n    }\n    return names;\n}\n\n// This function returns the number of valid names contained in the passed\n// namespace.\nfunction countNamespaceNames (namespace) {\n    let count = 0;\n    for (let name in namespace) {\n        if (isName(name)) count++;\n    }\n    return count;\n}\n\n// This function returns the value mapped to the given name in the given\n// namespace. If the name doesn't exist or it is not a valid name, it returns\n// null (NOTHING). If the name is a core JavaScript Object name, it also\n// returns null (NOTHING); this behaviour is meant to sandbox swan.\nfunction getNamespaceAttribute (namespace, name) {\n    if (!isName(name)) return null;\n    const value = namespace[name];\n    return (value !== undefined && value !== Object.prototype[name]) ? value : null;\n}\n\n\n\n\n\n// -----------------------------------------------------------------------------\n//  SEQUENCES\n// -----------------------------------------------------------------------------\n//  The following functions help manipulate Strings and Lists (Arrays)\n// -----------------------------------------------------------------------------\n\n// Given a sequence (String or List) and a number, it returns the corresponding\n// character (if a String) or item (if a List). This function accept negative\n// indexes and consider them as relative to the length of the sequence.\n// If the index is out of range, the given defaultValue is returned.\nfunction getSequenceItem (sequence, index, defaultValue) {\n    if (!isNumber(index)) return defaultValue;\n    index = index < 0 ? sequence.length + index : index;\n    return (0 <= index && index < sequence.length) ? sequence[Math.trunc(index)] : defaultValue;\n}\n\n// This function implements the JavaScript String.prototype.repeat on lists.\nfunction repeatList (list, n) {\n    var product = [];\n    for (let i=1; i<=n; i++) product = product.concat(list);\n    return product;    \n}\n\n\n\n\n\n// -----------------------------------------------------------------------------\n//  NUMBERS\n// -----------------------------------------------------------------------------\n\n// This function returns the list of integers between 0 and n.\nfunction* aritmeticSequence1 (n) {\n    if (n > 0) {\n        for (let i=0; i<n; i++) yield i;\n    } else if (n < 0) {\n        for (let i=0; i>n; i--) yield i;\n    }\n}\n\n\n\n\n\n// -----------------------------------------------------------------------------\n//  UNDEFINED\n// -----------------------------------------------------------------------------\n\n// The swan undefined data type is used as a result value of operations that are \n// not defined. For example `10 < \"abc\"` returns an Undefined instance.\n// Swan does not implement Error/Exceptions; where other languages would throw\n// an exception, swan returns an Undefined value.\n// In order to not loose information, any Undefined instance contains the name\n// of the undefined operation and all its operands. These informations allow\n// to trace back the chain of undefined operations.\nclass Undefined {\n    \n    // The constructor accepts as parameters the name of the undefined operation\n    // and all the operator values.\n    constructor (...args) {\n        this.args = Tuple(...args);\n    }\n}\n\n\n\n\n\n// -----------------------------------------------------------------------------\n//  COMPARISON\n// -----------------------------------------------------------------------------\n\n// Returns true if two tuples have the same items (uses isSameItem function).\nfunction isSameTuple (tuple1, tuple2) {\n    for (let [item1, item2] of iterPairs(tuple1, tuple2)) {\n        if (!isSameItem(item1, item2)) return false;\n    }\n    return true;\n}\n\n// Runs a deep comparison of the two namespaces and returns true if the two\n// namespaces have the same items. Non-valid names are ignored.\nfunction isSameNamespace (namespace1, namespace2) {\n    const nameList1 = listNamespaceNames(namespace1);   // only valid names\n    const nameList2 = listNamespaceNames(namespace2);   // only valid names\n    if (nameList1.length !== nameList2.length) return false;\n    for (let name of nameList1) {\n        const value1 = getNamespaceAttribute(namespace1, name);\n        const value2 = getNamespaceAttribute(namespace2, name);\n        if (!isSameTuple(value1, value2)) return false;     // in the most general case, the two items are tuples\n    }\n    return true;\n}\n\n// Returns true if two items are equal. This function defined the swan\n// concept of item equality.\nfunction isSameItem (item1, item2) {\n    \n    // NOTHING is equal only to itself\n    if (isNothing(item1) && !isNothing(item2)) return false;\n    if (isNothing(item2)) return false;    \n    \n    switch (detectPairType(item1, item2)) {\n        case \"List,List\"          : return isSameList(item1, item2);        // lists are equal if all their items are equal\n        case \"Namespace,Namespace\": return isSameNamespace(item1, item2);   // namespaces are equal if all their items are equal\n        default                   : return item1 === item2;                 // all the other item types are equal according to the JavaScript definition of equality\n    }    \n}\n\n// Returns true if the two lists have the same items\nfunction isSameList (list1, list2) {\n    if (list1.length !== list2.length) return false;\n    for (let i=0; i<list1.length; i++) {\n        if(!isSameTuple(list1[i], list2[i])) return false;\n    }\n    return true;\n}\n\n// Runs a lexicographycal comparison of the two tuples and returns \n// -1 (for <), 0 (for ==) or +1 (for >).\nfunction compareTuples (tuple1, tuple2) {\n    for (let [item1, item2] of iterPairs(tuple1, tuple2)) {\n        let cmp = compareItems(item1, item2);\n        if (cmp !== 0) return cmp;\n    }\n    return 0;   \n}\n\n// Compare two items and returns -1 (for <), 0 (for ==) or +1 (for >).\n// It throws an exception if the comparison is not defined. This exception will\n// be catched and turned into an Undefined instance.\nfunction compareItems (item1, item2) {\n    \n    // NOTHING is equal to itself and less than anything else\n    if (isNothing(item1)) return isNothing(item2) ? 0 : -1;\n    if (isNothing(item2)) return +1;\n    \n    switch (detectPairType(item1, item2)) {\n        case \"Boolean,Boolean\": return item1 === item2 ? 0 : (item1 ? +1 : -1);         // FALSE == FALSE < TRUE == TRUE\n        case \"Number,Number\"  : return item1 === item2 ? 0 : (item1<item2 ? -1 : +1);   // As per JavaScript number comparison\n        case \"String,String\"  : return item1.localeCompare(item2);                      // Alphabetical comparison\n        case \"List,List\"      : return lexCompareLists(item1, item2);                   // Lexicographical comparison\n        \n        // this exception will be catched by the proper context handler and turned into an Undefined instance\n        default               : throw new Error(`Comparison operation not defined`);        \n    }    \n}\n\n// Runs a lexicographycal comparison of the two lists and returns \n//  -1 if tuple1 < tuple2; \n//  +1 if tuple1 > tuple2; \n//  0 if tuple1 == tuple2.\nfunction lexCompareLists (list1, list2) {\n    const maxLength = Math.max(list1.length, list2.length);\n    for (let i=0; i<maxLength; i++) {\n        const cmp = compareTuples(list1[i], list2[i]);\n        if (cmp !== 0) return cmp;\n    }\n    return 0;\n}\n\n\n\n\n\n// -----------------------------------------------------------------------------\n//  PARSER\n// -----------------------------------------------------------------------------\n// The `parse` function takes a swan expression string as input and returns an \n// `evaluate` function as output.\n//\n// The `evaluate` function takes a context object as input and returns the value \n// of the swan expression as output. The evaluation of each single operation\n// is delegated to a handler attached to the context object. The handlers\n// names are defined in the configuration parameter passed to the `Parser`\n// factory. For example the `*` operation is handled by `context.$mul`.\n//\n// Each handler gets called with two parameters (for binary operations) or with\n// one parameter (for non-binary operations). Each parameter is an evaluate\n// function that returns an operand. For example, in the expression \"(3+2)*(5-1)\",\n// the `evaluate` function will return `context.$mul(X,Y)`, where: \n//  `X` is a function that takes `context` as argument and returns `(3+2)`;\n//  `Y` is a function that takes `context` as argument and returns `(5-1)`.\n//\n// More details about the parser can be found in the `parser` module.\n// -----------------------------------------------------------------------------\n\nconst Parser = __webpack_require__(/*! ./parser */ \"../../node_modules/@onlabsorg/swan-js/lib/parser.js\");\n\nconst parser = new Parser({\n\n     binaryOperations: {\n         \",\"  : {precedence:10, handler:\"$pair\"    },\n         \":\"  : {precedence:12, handler:\"$label\"   },\n         \"=\"  : {precedence:12, handler:\"$set\"     },\n         \"=>\" : {precedence:13, handler:\"$tmap\"    },\n         \"?>\" : {precedence:13, handler:\"$umap\"   },\n         \">>\" : {precedence:14, handler:\"$pipe\" },\n         \"<<\" : {precedence:14, handler:\"$compose\", right:true},\n         \"->\" : {precedence:15, handler:\"$def\",     right:true},\n\n         \";\"  : {precedence:21, handler:\"$else\"},\n         \"?\"  : {precedence:22, handler:\"$if\"  },\n         \"|\"  : {precedence:23, handler:\"$or\"  },\n         \"&\"  : {precedence:23, handler:\"$and\" },\n         \"==\" : {precedence:24, handler:\"$eq\"  },\n         \"!=\" : {precedence:24, handler:\"$ne\"  },\n         \"<\"  : {precedence:24, handler:\"$lt\"  },\n         \"<=\" : {precedence:24, handler:\"$le\"  },\n         \">\"  : {precedence:24, handler:\"$gt\"  },\n         \">=\" : {precedence:24, handler:\"$ge\"  },\n         \"+\"  : {precedence:25, handler:\"$add\" },\n         \"-\"  : {precedence:25, handler:\"$sub\" },\n         \"*\"  : {precedence:26, handler:\"$mul\" },\n         \"/\"  : {precedence:26, handler:\"$div\" },\n         \"%\"  : {precedence:26, handler:\"$mod\" },\n         \"^\"  : {precedence:27, handler:\"$pow\" },\n\n         \".\"  : {precedence:30, handler:\"$dot\" },\n         \"@\"  : {precedence:30, handler:\"$at\" },\n         \"\"   : {precedence:30, handler:\"$apply\" },\n     },\n     \n     unaryOperations: {\n        \"+\": \"$id\",\n        \"-\": \"$neg\"\n     },\n\n     voidHandler        : \"$nothing\",\n     nameHandler        : \"$name\",\n     stringHandler1     : \"$str1\",\n     stringHandler2     : \"$str2\",\n     stringHandler3     : \"$strt\",\n     numberHandler      : \"$numb\",\n     squareGroupHandler : \"$list\",\n     curlyGroupHandler  : \"$namespace\",\n     \n     errorHandler       : \"$error\"\n});\n\nconst parse = source => parser.parse(source);\n\n\n\n\n\n// -----------------------------------------------------------------------------\n//  CONTEXT\n// -----------------------------------------------------------------------------\n\nconst context = {\n\n    \n    //:::  CORE HANDLERS  ::::::::::::::::::::::::::::::::::::::::::::::::::::::\n\n    // Nothing value handler\n    $nothing () {\n        return null;\n    },\n\n    // Single quote string value handler\n    $str1 (value) {\n        return value;\n    },\n\n    // Double quote string value handler\n    $str2 (value) {\n        return value;\n    },\n\n    // Template string handler\n    async $strt (value) {\n        const expressions = [];\n        value = value.replace(/\\${([\\s\\S]+?)}/g, (match, expression) => {\n            const i = expressions.length;\n            expressions.push( parse(expression) );\n            return \"${\" + i + \"}\";\n        });\n        for (let i=0; i<expressions.length; i++) {\n            const evaluateXp = expressions[i];\n            const xpVal = await evaluateXp(this);\n            const xpStr = await this.str(xpVal);\n            value = value.replace(\"${\" + i + \"}\", xpStr);\n        }\n        return value;\n    },\n\n    // Numeric value handler\n    $numb (value) {\n        return value;\n    },\n    \n    // Pairing operation handler: X,Y\n    async $pair (X, Y) {\n        return Tuple(await X(this), await Y(this));\n    },\n\n    // Square brackets grouping handler: [X]\n    async $list (X) {\n        const x = await X(this);\n        return Array.from(Tuple(x));\n    },\n\n    // Identifier handler\n    async $name (name) {\n        return getNamespaceAttribute(this, name);\n    },\n\n    // Labelling operation handler: X: Y\n    async $label (X, Y) {\n        const x = await X({\n            $$parser: this.$$parser,\n            $nothing: this.$nothing,\n            $name: name => name,\n            $pair: this.$pair,\n            $error: this.$error.bind(this)\n        });\n        const names = Array.from(Tuple(x)).filter(isName);\n\n        const y = await Y(this);        \n        const values = Array.from(Tuple(y));\n        \n        if (values.length > names.length) {\n            values[names.length-1] = Tuple(...values.slice(names.length-1)).normalize();\n        }\n        for (var i=0; i<names.length; i++) {\n            this[names[i]] = i < values.length ? values[i] : null;\n        }    \n        \n        return y;\n    },\n\n    // Assignment handler: X = Y\n    async $set (X, Y) {\n        await this.$label(X, Y);\n        return null;\n    },\n\n    // Curly braces grouping handler: {X}\n    async $namespace (X) {\n        const context = Object.create(this);\n        await X(context);\n        return Object.assign({}, context);\n    },\n\n    // Function definition operation handler: X -> Y\n    $def (params, expression) {\n        return async (...args) => {\n            const functionContext = Object.create(this);\n            await functionContext.$set(params, () => Tuple(...args).normalize());\n            return await expression(functionContext);\n        }\n    },\n    \n    // Application operation handler: X Y\n    async $apply (F, X, pos) {\n        const f = await F(this);\n        const x = Tuple(await X(this));\n        \n        return await Tuple(f).mapAsync(async fItem => {\n            \n            switch (detectItemType(fItem)) {\n                \n                case \"Function\":\n                    try {\n                        return await fItem.call(this, ...x);\n                    } catch (error) {\n                        return await this.$error(error, pos);\n                    }    \n                    \n                case \"Namespace\":\n                    if (isFunction(fItem.__apply__)) {\n                        try {\n                            return await fItem.__apply__.call(this, ...x);\n                        } catch (error) {\n                            return await this.$error(error, pos);\n                        }                            \n                    }\n                \n                default:\n                    return this.undefined('application', fItem, pos);\n            }\n        }).then(tuple => tuple.normalize());\n    },\n\n    // Referencing operation handler: X @ Y\n    async $at (X, Y, pos) {\n        const x = await X(this);\n        const y = await Y(this);\n        \n        return await Tuple(x).mapAsync(async xItem => {\n            \n            const xItemType = detectItemType(xItem);\n            switch (xItemType) {\n                case \"Namespace\": return Tuple(y).mapSync(name => getNamespaceAttribute(xItem, name)).normalize();\n                case \"List\"     : return Tuple(y).mapSync(i => getSequenceItem(xItem, i, null)).normalize();\n                case \"String\"   : return Tuple(y).mapSync(i => getSequenceItem(xItem, i, \"\")).normalize();\n                default         : return this.undefined('referencing', xItem, y, pos);\n            }\n            \n        }).then(tuple => tuple.normalize());\n    },\n\n    // Mapping operation handler: X => Y\n    async $tmap (X, F) {\n        const x = await X(this);\n        return await Tuple(x)\n                .mapAsync(item => this.$apply(F, ()=>item))\n                .then(tuple => tuple.normalize());\n    },\n\n    // Selective undefined mapping operation handler: X ?> Y\n    async $umap (X, F) {\n        const x = await X(this);\n        return await Tuple(x).mapAsync(async item => {\n            if (item instanceof Undefined) {\n                return await this.$apply(F, () => Tuple(...item.args));\n            } else {\n                return item;\n            }\n        }).then(tuple => tuple.normalize());\n    },\n    \n    // Subcontexting operation handler: X.Y\n    async $dot (X, Y, pos) {\n        const x = await X(this);\n        return await Tuple(x).mapAsync(async xItem => {\n            \n            if (!isNamespace(xItem)) {\n                return this.undefined('subcontexting', xItem, pos);\n            }\n            const childNamespace = this.$extend(xItem);\n            return await Y(childNamespace);\n            \n        }).then(tuple => tuple.normalize());\n    },\n    \n    // Hanldes all errors occurring during evaluation\n    $error (error, pos) {\n        return this.undefined('failure', error, pos);\n    },\n\n\n    //:::  UNARY OPERATION HANDLERS  :::::::::::::::::::::::::::::::::::::::::::\n\n    // Unary operation: +X\n    async $id (X) {\n        return await X(this);\n    },\n    \n    // Unary operation: -X\n    async $neg (X, pos) {\n        const x = await X(this);\n        return Tuple(x).mapSync(item => {\n            return isNumber(item) ? -item : this.undefined('negation', item, pos);\n        });\n    },\n\n\n    //:::  LOGIC OPERATION HANDLERS  :::::::::::::::::::::::::::::::::::::::::::\n\n    // OR operation handler: X | Y\n    async $or (X, Y) {\n        const x = await X(this);\n        const bool_x = await this.bool(x);\n        if (bool_x instanceof Undefined) return bool_x;\n        return bool_x ? x : await Y(this);\n    },\n\n    // AND operation handler: X & Y\n    async $and (X, Y) {\n        const x = await X(this);\n        const bool_x = await this.bool(x);\n        if (bool_x instanceof Undefined) return bool_x;\n        return bool_x ? await Y(this) : x;\n    },\n\n    // Conditional operation handler: X ? Y\n    async $if (X, Y) {\n        const x = await X(this);\n        const bool_x = await this.bool(x);\n        if (bool_x instanceof Undefined) return bool_x;\n        return bool_x ? await Y(this) : null;\n    },\n\n    // Alternative operation handler: X ; Y\n    async $else (X, Y) {\n        const x = await X(this);\n        return Tuple(x).isEmpty() ? await Y(this) : x;\n    },\n\n\n\n    //:::  ARITHMETIC OPERATION HANDLERS  ::::::::::::::::::::::::::::::::::::::\n    \n    // Sum operation handler: X + Y\n    async $add (X, Y, pos) {\n        const xTuple = await X(this);\n        const yTuple = await Y(this);\n        return await mapPairs(xTuple, yTuple, (x, y) => {\n            if (isNothing(x)) return y;\n            if (isNothing(y)) return x;\n            switch (detectPairType(x, y)) {\n                case \"Boolean,Boolean\"    : return x || y;\n                case \"Number,Number\"      : return x + y;\n                case \"String,String\"      : return x + y;\n                case \"List,List\"          : return x.concat(y);\n                case \"Namespace,Namespace\": return Object.assign({}, x, y);\n                default                   : return this.undefined('sum', x, y, pos);\n            }\n        });\n    },\n\n    // Subtraction operation handler: X - Y\n    async $sub (X, Y, pos) {\n        const xTuple = await X(this);\n        const yTuple = await Y(this);\n        return await mapPairs(xTuple, yTuple, (x, y) => {\n            if (isNothing(y)) return x;\n            switch (detectPairType(x, y)) {\n                case \"Number,Number\" : return x - y;\n                default              : return this.undefined('subtraction', x, y, pos);\n            }\n        });\n    },\n\n    // Product operation handler: X * Y\n    async $mul (X, Y, pos) {\n        const xTuple = await X(this);\n        const yTuple = await Y(this);\n        return await mapPairs(xTuple, yTuple, (x, y) => {\n            if (isNothing(x)) return null;\n            if (isNothing(y)) return null;\n            switch (detectPairType(x, y)) {\n                case \"Boolean,Boolean\"    : return x && y;\n                case \"Number,Number\"      : return x * y;\n                case \"Number,String\"      : return x < 0 ? \"\" : y.repeat(x);\n                case \"String,Number\"      : return y < 0 ? \"\" : x.repeat(y);\n                case \"Number,List\"        : return repeatList(y, x);\n                case \"List,Number\"        : return repeatList(x, y);\n                default                   : return this.undefined('product', x, y, pos);\n            }\n        });\n    },\n\n    // Division operation handler: X / Y\n    async $div (X, Y, pos) {\n        const xTuple = await X(this);\n        const yTuple = await Y(this);\n        return await mapPairs(xTuple, yTuple, (x, y) => {\n            if (isNothing(x)) return null;\n            switch (detectPairType(x, y)) {\n                case \"Number,Number\" : return x / y;\n                default              : return this.undefined('division', x, y, pos);\n            }\n        });\n    },\n\n    // Modulo operation handler: X % Y\n    async $mod (X, Y, pos) {\n        const xTuple = await X(this);\n        const yTuple = await Y(this);\n        return await mapPairs(xTuple, yTuple, (x, y) => {\n            if (isNothing(x)) return null;\n            switch (detectPairType(x, y)) {\n                case \"Number,Number\" : return x % y;\n                default              : return this.undefined('modulo', x, y, pos);\n            }\n        });\n    },\n\n    // Exponentiation operation handler: X ^ Y\n    async $pow (X, Y, pos) {\n        const xTuple = await X(this);\n        const yTuple = await Y(this);\n        return await mapPairs(xTuple, yTuple, (x, y) => {\n            if (isNothing(x)) return null;\n            switch (detectPairType(x, y)) {\n                case \"Number,Number\" : return x ** y;\n                default              : return this.undefined('exponentiation', x, y, pos);\n            }\n        });\n    },\n    \n\n    \n    //:::  COMPARISON OPERATION HANDLERS  ::::::::::::::::::::::::::::::::::::::\n\n    // Equal: X == Y\n    async $eq (X, Y) {\n        const x = await X(this);\n        const y = await Y(this);\n        return isSameTuple(x, y);\n    },\n\n    // Not equal: X != Y\n    async $ne (X, Y) {\n        return !(await this.$eq(X, Y));\n    },\n\n    // Less than: X < Y\n    async $lt (X, Y, pos) {\n        const x = await X(this);\n        const y = await Y(this);\n        try {\n            return compareTuples(x, y) < 0;\n        } catch (error) {\n            return this.undefined('comparison', x, y, pos);\n        }\n    },\n\n    // Greater than or equal to: X >= Y\n    async $ge (X, Y, pos) {\n        const x = await X(this);\n        const y = await Y(this);\n        try {\n            return compareTuples(x, y) >= 0;\n        } catch (error) {\n            return this.undefined('comparison', x, y, pos);\n        }\n    },\n\n    // Greater than: X > Y\n    async $gt (X, Y, pos) {\n        const x = await X(this);\n        const y = await Y(this);\n        try {\n            return compareTuples(x, y) > 0;\n        } catch (error) {\n            return this.undefined('comparison', x, y, pos);\n        }\n    },\n\n    // Less than or equal to: X < Y\n    async $le (X, Y, pos) {\n        const x = await X(this);\n        const y = await Y(this);\n        try {\n            return compareTuples(x, y) <= 0;\n        } catch (error) {\n            return this.undefined('comparison', x, y, pos);\n        }\n    },\n    \n\n\n    //:::  FUNCTION COMPOSITION  :::::::::::::::::::::::::::::::::::::::::::::::\n    \n    // Function composition operation handler: G << F\n    $compose (G, F) {\n        return (...args) => this.$apply(G, () => this.$apply(F, () => Tuple(...args)));\n    },\n    \n    // Function piping operation handler: F >> G\n    $pipe (F, G) {\n        return this.$compose(G, F);\n    },\n    \n    \n    \n    //:::  BUILT-IN CONSTANTS  :::::::::::::::::::::::::::::::::::::::::::::::::\n    \n    TRUE    : true,\n    FALSE   : false,\n    INFINITY: Infinity,\n\n\n\n    //::: BUILT-IN FUNCTIONS  ::::::::::::::::::::::::::::::::::::::::::::::::::\n    \n    // Returns an Undefined instance\n    undefined (...args) {\n        return new Undefined(...args);\n    },\n\n    // Converts a tuple to boolean\n    bool (...items) {\n        for (let item of Tuple(...items)) {\n            if (item instanceof Undefined) {\n                return this.undefined('booleanization', item);\n            }\n            if (convertItemToBoolean(item) !== false) return true;\n        }\n        return false;\n    },\n    \n    // Returns NOT bool(X)\n    not (...items) {\n        const bool = this.bool(...items);\n        return bool instanceof Undefined ? bool : !bool;\n    },\n    \n    // Converts a tuple to string\n    str (...items) {\n        return Array.from(Tuple(...items)).map(\n            item => this[`$stringify${detectItemType(item)}`](item)\n        ).join(\"\");\n    },\n    \n    $stringifyBoolean   : item => item ? \"TRUE\" : \"FALSE\",\n    $stringifyNumber    : item => String(item),\n    $stringifyFunction  : item => \"[[Function]]\",\n    $stringifyString    : item => item,\n    $stringifyList      : item => `[[List of ${item.length} items]]`,\n    $stringifyNamespace : item => isString(item.__str__) ? item.__str__ : `[[Namespace of ${countNamespaceNames(item)} items]]`,\n    $stringifyUndefined (item) {\n        const argstr = item.args.mapSync(arg => {\n            if (arg instanceof Error) {\n                return `[[Error: ${arg.message}]]`\n            } else if (arg instanceof Parser.Position) {\n                return String(arg);\n            } else {\n                return this[`$stringify${detectItemType(arg)}`](arg);\n            }\n        });\n        return `[[Undefined: ${Array.from(argstr).join(', ')}]]`;\n    },\n    \n    // Enumerates an enumerable item\n    enum (...items) {\n        return Tuple(...items).mapAsync(async item => {\n            \n            switch (detectItemType(item)) {\n                case \"Number\"   : return Tuple(...aritmeticSequence1(item));\n                case \"String\"   : return Tuple(...item);\n                case \"List\"     : return Tuple(...item);\n                case \"Namespace\": return Tuple(...listNamespaceNames(item));\n                default         : return this.undefined('enumeration', item);\n            }\n            \n        }).then(tuple => tuple.normalize());\n    },\n    \n    // Returns the type names of a tuble\n    type (...items) {\n        return Tuple(...items).mapSync(detectItemType).normalize();\n    },\n    \n    // Returns the number of item of a container (String, List or Namespace)\n    size (...items) {\n        return Tuple(...items).mapSync(item => {\n            \n            switch (detectItemType(item)) {\n                case \"String\"   : return item.length;\n                case \"List\"     : return item.length;\n                case \"Namespace\": return countNamespaceNames(item);\n                default         : return this.undefined('size', item);\n            }\n            \n        }).normalize();\n    },\n    \n    \n    \n    //:::  CONTEXT PROPERTIES  :::::::::::::::::::::::::::::::::::::::::::::::::\n    \n    // Expose the swan custom types to javascript\n    $Tuple: Tuple,\n    $Undefined: Undefined,\n    \n    // Extends the current context with new names\n    $extend (namespace={}) {\n        const context = Object.create(this);\n        for (let name in namespace) {\n            context[name] = namespace[name];\n        }\n        return context;\n    }\n};\n\n\n\n\n\n// -----------------------------------------------------------------------------\n//  EXPORTS\n// -----------------------------------------------------------------------------\n\nmodule.exports = {Tuple, Undefined, parse, context};\n\n//# sourceURL=webpack:////home/marcello/mdb/Code/olojs/node_modules/@onlabsorg/swan-js/lib/interpreter.js?");

/***/ }),

/***/ "../../node_modules/@onlabsorg/swan-js/lib/lexer.js":
/*!**********************************************************************************!*\
  !*** /home/marcello/mdb/Code/olojs/node_modules/@onlabsorg/swan-js/lib/lexer.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("\nclass Lexer {\n    \n    constructor (options) {\n        this.binaryOperators = new Set(options.binaryOperators);\n        this.unaryOperators = new Set(options.unaryOperators);\n        \n        const isSymbol = operator => !this.matchIdentifierStart(operator);\n        this.SYMBOLS = new Set( ['{', '[', '(', ')', ']', '}']\n                .concat(options.binaryOperators.filter(isSymbol)) \n                .concat(options.unaryOperators.filter(isSymbol)));\n    }\n\n    matchSpace           (char) { return char && char.match(/^\\s$/)           }\n    matchQuote           (char) { return char && char.match(/^[\"'`]$/)        }\n    matchIdentifierStart (char) { return char && char.match(/^[a-z_A-Z]$/)    }\n    matchIdentifierPart  (char) { return char && char.match(/^[a-z_A-Z0-9]$/) }\n    matchDecimalDigit    (char) { return char && char.match(/^[0-9]$/)        }\n    matchSign            (char) { return char === \"+\" || char === \"-\"         }\n    matchCommentStart    (sym)  { return sym === \"#\"                          }\n    matchSymbol          (sym)  { return this.SYMBOLS.has(sym)                }\n    \n    * tokenize (source) {\n        \n        const createToken = (type, value, index) => \n                new this.constructor.Token(this, type, value, new this.constructor.Position(source, index));\n                \n        const createSyntaxError = (message, index) => \n                new this.constructor.SyntaxError(message, source, index);\n        \n        var i = 0, len = source.length;\n        while (true) {\n            while (this.matchSpace(source[i])) i++;\n            if (i >= len) break;\n\n            // if string literal\n            if (this.matchQuote(source[i])) {\n                let value = \"\";            \n                let quoteSymbol = source[i]; i++;\n                while (source[i] !== quoteSymbol) {\n                    if (i >= len) throw createSyntaxError(\"Closing quote expected\", i);\n                    value += source[i]; i++;\n                }\n                let token = createToken(Token.STRING, value, i);\n                token.quoteSymbol = quoteSymbol;\n                yield token; i++;\n            }\n            \n            // if identifier\n            else if (this.matchIdentifierStart(source[i])) {\n                let value = source[i]; i++;\n                while (this.matchIdentifierPart(source[i])) {\n                    value += source[i]; i++;\n                }\n                yield createToken(Token.IDENTIFIER, value, i);\n            }\n\n            // if number literal\n            else if (this.matchDecimalDigit(source[i])) {\n                let numStr = source[i]; i++;\n                \n                while (this.matchDecimalDigit(source[i])) {\n                    numStr += source[i]; i++;\n                }\n\n                if (source[i] === \".\") {\n                    numStr += source[i]; i++;\n                    while (this.matchDecimalDigit(source[i])) {\n                        numStr += source[i]; i++;\n                    }        \n                }\n                \n                if (source[i] === 'e' || source[i] === 'E') {\n                    numStr += 'E'; i++;\n                    if (source[i] === '+' || source[i] === '-') { // exponent sign\n                        numStr += source[i]; i++;\n                    }\n                    if (!this.matchDecimalDigit(source[i])) {\n                        throw createSyntaxError(`Expected exponent value`, i);                    \n                    }\n                    numStr += source[i]; i++;\n                    while (this.matchDecimalDigit(source[i])) {\n                        numStr += source[i]; i++;\n                    }        \n                }\n                \n                if (this.matchIdentifierStart(source[i])) {\n                    throw createSyntaxError(`Invalid number`, i-1);\n                } else if (source[i] === \".\") {\n                    throw createSyntaxError('Unexpected period', i);\n                }\n\n                yield createToken(Token.NUMBER, Number(numStr), i);\n            }\n            \n            else if (this.matchCommentStart(source[i])) {\n                i++; while (source[i] !== \"\\n\" && i < len) i++;\n            }\n            \n            else if (this.matchSymbol( source[i]+source[i+1] )) {\n                yield createToken(Token.SYMBOL, source[i]+source[i+1], i); i+=2;\n            } \n            \n            else if (this.matchSymbol( source[i] )) {\n                yield createToken(Token.SYMBOL, source[i], i); i++;\n            } \n\n            else {\n                throw createSyntaxError(`Unexpected character '${source[i]}'`, i);\n            }\n        }        \n    }\n    \n    static get Position    () { return Position    }\n    static get SyntaxError () { return SyntaxError }\n    static get Token       () { return Token       }\n}\n\n\n\nclass Token {\n    \n    constructor (lexer, type, value, pos) {\n        this.lexer = lexer;\n        this.type = type;\n        this.value = value;\n        this.position = pos;\n    }    \n    \n    matchSymbol (sym) {\n        return this.type === Token.SYMBOL && this.value === sym;\n    }\n    \n    matchSign () {\n        return this.matchSymbol(\"+\") || this.matchSymbol(\"-\");\n    }\n    \n    matchIdentifier () {\n        return this.type === Token.IDENTIFIER && !this.lexer.binaryOperators.has(this.value);\n    }\n    \n    matchBinaryOperator () {\n        return (this.type === Token.SYMBOL || this.type === Token.IDENTIFIER) && \n                this.lexer.binaryOperators.has(this.value);\n    }\n    \n    matchUnaryOperator () {\n        return (this.type === Token.SYMBOL || this.type === Token.IDENTIFIER) && \n                this.lexer.unaryOperators.has(this.value);\n    }\n\n    matchOpenBracket () {\n        return this.matchSymbol('(') || this.matchSymbol('[');\n    }\n    \n    matchNumberLiteral () {\n        return this.type === Token.NUMBER;\n    }\n    \n    matchStringLiteral () {\n        return this.type === Token.STRING;\n    }\n\n    matchLiteral () {\n        return this.type === Token.NUMBER || this.type === Token.STRING;\n    }\n}\n\n// Token types\nToken.SYMBOL = 0;\nToken.NUMBER = 1;\nToken.STRING = 2;\nToken.IDENTIFIER = 3;\n\n\n\nclass Position {\n\n    constructor (source, index) {\n        this.source = source;\n        this.index = index;\n    }\n    \n    getLocation () {\n        const lines = this.source.slice(0, this.index).split('\\n');\n        const row = lines.length;\n        const col = lines.pop().length;\n        return [row, col];\n    }\n    \n    toString () {\n        const [row, col] = this.getLocation();\n        return `@${row}:${col}`;\n    }    \n}\n\n\n\nclass SyntaxError extends Error {\n    \n    constructor (message, source, index) {\n        const position = new Position(source, index);\n        super(`${message} ${position}`);\n        this.position = position;\n    }\n}\n\n\n\nmodule.exports = Lexer;\n\n\n//# sourceURL=webpack:////home/marcello/mdb/Code/olojs/node_modules/@onlabsorg/swan-js/lib/lexer.js?");

/***/ }),

/***/ "../../node_modules/@onlabsorg/swan-js/lib/modules.js":
/*!************************************************************************************!*\
  !*** /home/marcello/mdb/Code/olojs/node_modules/@onlabsorg/swan-js/lib/modules.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const pathlib = __webpack_require__(/*! path */ \"../../node_modules/path-browserify/index.js\");\n\nfunction normPath (path) {\n    return pathlib.normalize(`/${path}`);\n}\n\n\n\nconst modules = {};\n\nexports.require = async function (modulePath) {\n    const module = await modules[normPath(modulePath)]();\n    return module.default || module;\n}\n\nconst define = exports.define = function (modulePath, load) {\n    modules[normPath(modulePath)] = load;\n}\n\ndefine(\"date\"     , () => Promise.resolve(/*! import() */).then(__webpack_require__.t.bind(null, /*! ./modules/date.js */ \"../../node_modules/@onlabsorg/swan-js/lib/modules/date.js\", 7)));\ndefine(\"http\"     , () => __webpack_require__.e(/*! import() | swan_modules/http */ \"swan_modules/http\").then(__webpack_require__.t.bind(null, /*! ./modules/http.js */ \"../../node_modules/@onlabsorg/swan-js/lib/modules/http.js\", 7)));\ndefine(\"json\"     , () => __webpack_require__.e(/*! import() | swan_modules/json */ \"swan_modules/json\").then(__webpack_require__.t.bind(null, /*! ./modules/json.js */ \"../../node_modules/@onlabsorg/swan-js/lib/modules/json.js\", 7)));\ndefine(\"list\"     , () => __webpack_require__.e(/*! import() | swan_modules/list */ \"swan_modules/list\").then(__webpack_require__.t.bind(null, /*! ./modules/list.js */ \"../../node_modules/@onlabsorg/swan-js/lib/modules/list.js\", 7)));\ndefine(\"math\"     , () => __webpack_require__.e(/*! import() | swan_modules/math */ \"swan_modules/math\").then(__webpack_require__.t.bind(null, /*! ./modules/math.js */ \"../../node_modules/@onlabsorg/swan-js/lib/modules/math.js\", 7)));\ndefine(\"path\"     , () => Promise.resolve(/*! import() */).then(__webpack_require__.t.bind(null, /*! ./modules/path.js */ \"../../node_modules/@onlabsorg/swan-js/lib/modules/path.js\", 7)));\ndefine(\"text\"     , () => __webpack_require__.e(/*! import() | swan_modules/text */ \"swan_modules/text\").then(__webpack_require__.t.bind(null, /*! ./modules/text.js */ \"../../node_modules/@onlabsorg/swan-js/lib/modules/text.js\", 7)));\ndefine(\"debug\"    , () => __webpack_require__.e(/*! import() | swan_modules/debug */ \"swan_modules/debug\").then(__webpack_require__.t.bind(null, /*! ./modules/debug.js */ \"../../node_modules/@onlabsorg/swan-js/lib/modules/debug.js\", 7)));\n\n\n\n//# sourceURL=webpack:////home/marcello/mdb/Code/olojs/node_modules/@onlabsorg/swan-js/lib/modules.js?");

/***/ }),

/***/ "../../node_modules/@onlabsorg/swan-js/lib/modules/date.js":
/*!*****************************************************************************************!*\
  !*** /home/marcello/mdb/Code/olojs/node_modules/@onlabsorg/swan-js/lib/modules/date.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n *  date - swan stdlib module\n *  ============================================================================\n *  Contains functions to handle date and time.\n */\n\n\nmodule.exports = {\n\n    /**\n     *  date.\\_\\_apply\\_\\_ - function\n     *  ------------------------------------------------------------------------\n     *  Creates a date given all the date components expressed in the local\n     *  timezone.\n     *  ```\n     *  dt = date(y, m, d, h, min, s, ms)\n     *  ```\n     *  - `y` is the year in the local timezone\n     *  - `m` is the month in the local timezone (1:January, ..., 12:December)\n     *  - `d` is the day in the local timezone\n     *  - `h` is the hour in the local timezone\n     *  - `min` is the minute in the local timezone\n     *  - `s` is the number of seconds\n     *  - `ms` is the number of milliseconds\n     *  - `dt` is the number of milliseconds from the epoch (Jan 1, 1970)\n     */\n    __apply__: (y, m=1, d=1, h=0, min=0, s=0, ms=0) => Number(new Date(y, m-1, d, h, min, s, ms)),\n\n\n    /**\n     *  date.timezone - number\n     *  ------------------------------------------------------------------------\n     *  It contains the current time zone in hours. For example in UTC+1 it\n     *  will hold the value +1.\n     */\n    timezone: -(new Date()).getTimezoneOffset()/60,\n\n\n    /**\n     *  date.parse - function\n     *  ------------------------------------------------------------------------\n     *  Creates a date given its string representation.\n     *  ```\n     *  dt = date.parse(dstr)\n     *  ```\n     *  - `dstr` is a string rapresentation of the date to be created (e.g. `'2021-02-27T10:30:45.327'`)\n     *  - `dt` is the number of milliseconds from the epoch (Jan 1, 1970)\n     */\n    parse: str => Number(Date.parse(str)),\n\n\n    /**\n     *  date.stringify - function\n     *  ------------------------------------------------------------------------\n     *  Given a date in ms, it returns its ISO string representation\n     *  ```\n     *  dstr = date.stringify(dt)\n     *  ```\n     */\n    stringify: date => D(date).toISOString(),\n\n\n    /**\n     *  date.now - function\n     *  ------------------------------------------------------------------------\n     *  It returns the current date in ms from the epoch.\n     *  ```\n     *  dt = date.now()\n     *  ```\n     */\n    now: () => Date.now(),\n\n\n    /**\n     *  date.year - function\n     *  ------------------------------------------------------------------------\n     *  It returns the year of a given date, in the loacal timezone.\n     *  ```\n     *  y = date.year(dt)\n     *  ```\n     */\n    year: date => D(date).getFullYear(),\n\n\n    /**\n     *  date.month - function\n     *  ------------------------------------------------------------------------\n     *  It returns the month of a given date, in the loacal timezone. January is 1,\n     *  Febrary is 2, etc.\n     *  ```\n     *  m = date.month(dt)\n     *  ```\n     */\n    month: date => D(date).getMonth()+1,\n\n\n    // Return the year week number of a give date\n    week: date => {\n        date = new Date(Number(date));\n        date.setHours(0, 0, 0, 0);\n        // Thursday in current week decides the year.\n        date.setDate(date.getDate() + 3 - (date.getDay() + 6) % 7);\n        // January 4 is always in week 1.\n        var week1 = new Date(date.getFullYear(), 0, 4);\n        // Adjust to Thursday in week 1 and count number of weeks from date to week1.\n        return 1 + Math.round(((date.getTime() - week1.getTime()) / 86400000 - 3 + (week1.getDay() + 6) % 7) / 7);\n    },\n\n\n    /**\n     *  date.weekDay - function\n     *  ------------------------------------------------------------------------\n     *  It returns the day of the week of a given date, in the loacal timezone.\n     *  Sunday is 0, monday is 1, tuesday is 2, etc.\n     *  ```\n     *  wd = date.weekDay(dt)\n     *  ```\n     */\n    weekDay: date => D(date).getDay(),\n\n\n    /**\n     *  date.day - function\n     *  ------------------------------------------------------------------------\n     *  It returns the month day of a given date, in the loacal timezone.\n     *  ```\n     *  d = date.day(dt)\n     *  ```\n     */\n    day: date => D(date).getDate(),\n\n\n    /**\n     *  date.hours - function\n     *  ------------------------------------------------------------------------\n     *  It returns the hour a given date, in the loacal timezone.\n     *  ```\n     *  h = date.day(dt)\n     *  ```\n     */\n    hours: date => D(date).getHours(),\n\n\n    /**\n     *  date.minutes - function\n     *  ------------------------------------------------------------------------\n     *  It returns the minutes of a given date, in the loacal timezone.\n     *  ```\n     *  min = date.minutes(dt)\n     *  ```\n     */\n    minutes: date => D(date).getMinutes(),\n\n\n    /**\n     *  date.seconds - function\n     *  ------------------------------------------------------------------------\n     *  It returns the seconds of a given date, in the loacal timezone.\n     *  ```\n     *  s = date.seconds(dt)\n     *  ```\n     */\n    seconds: date => D(date).getSeconds(),\n\n\n    /**\n     *  date.milliseconds - function\n     *  ------------------------------------------------------------------------\n     *  It returns the milliseconds of a given date, in the loacal timezone.\n     *  ```\n     *  ms = date.milliseconds(dt)\n     *  ```\n     */\n    milliseconds: date => D(date).getMilliseconds(),\n\n\n    UTC: {\n\n        /**\n         *  date.UTC.\\_\\_apply\\_\\_ - function\n         *  ------------------------------------------------------------------------\n         *  Creates a date given all the date components expressed in the UTC-0\n         *  timezone.\n         *  ```\n         *  dt = date.UTC(y, m, d, h, min, s, ms)\n         *  ```\n         *  - `y` is the year in the local timezone\n         *  - `m` is the month in the local timezone (1:January, ..., 12:December)\n         *  - `d` is the day in the local timezone\n         *  - `h` is the hour in the local timezone\n         *  - `min` is the minute in the local timezone\n         *  - `s` is the number of seconds\n         *  - `ms` is the number of milliseconds\n         *  - `dt` is the number of milliseconds from the epoch (Jan 1, 1970)\n         */\n        __apply__: (y, m=1, d=1, h=0, min=0, s=0, ms=0) => Date.UTC(y, m-1, d, h, min, s, ms),\n\n\n        /**\n         *  date.UTC.year - function\n         *  ------------------------------------------------------------------------\n         *  It returns the year of a given date, in the UTC-0 timezone.\n         *  ```\n         *  y = date.UTC.year(dt)\n         *  ```\n         */\n        year: date => D(date).getUTCFullYear(),\n\n\n        /**\n         *  date.UTC.month - function\n         *  ------------------------------------------------------------------------\n         *  It returns the month of a given date, in the UTC-0 timezone. January is 1,\n         *  Febrary is 2, etc.\n         *  ```\n         *  m = date.UTC.month(dt)\n         *  ```\n         */\n        month: date => D(date).getUTCMonth()+1,\n\n\n        /**\n         *  date.UTC.weekDay - function\n         *  ------------------------------------------------------------------------\n         *  It returns the day of the week of a given date, in the UTC-0 timezone.\n         *  Sunday is 0, monday is 1, tuesday is 2, etc.\n         *  ```\n         *  wd = date.UTC.weekDay(dt)\n         *  ```\n         */\n        weekDay: date => D(date).getUTCDay(),\n\n\n        /**\n         *  date.UTC.day - function\n         *  ------------------------------------------------------------------------\n         *  It returns the month day of a given date, in the UTC-0 timezone.\n         *  ```\n         *  d = date.day(dt)\n         *  ```\n         */\n        day: date => D(date).getUTCDate(),\n\n\n        /**\n         *  date.UTC.hours - function\n         *  ------------------------------------------------------------------------\n         *  It returns the hour a given date, in the UTC-0 timezone.\n         *  ```\n         *  h = date.UTC.day(dt)\n         *  ```\n         */\n        hours: date => D(date).getUTCHours(),\n\n\n        /**\n         *  date.UTC.minutes - function\n         *  ------------------------------------------------------------------------\n         *  It returns the minutes of a given date, in the UTC-0 timezone.\n         *  ```\n         *  min = date.UTC.minutes(dt)\n         *  ```\n         */\n        minutes: date => D(date).getUTCMinutes(),\n\n\n        /**\n         *  date.UTC.seconds - function\n         *  ------------------------------------------------------------------------\n         *  It returns the seconds of a given date, in the UTC-0 timezone.\n         *  ```\n         *  s = date.UTC.seconds(dt)\n         *  ```\n         */\n        seconds: date => D(date).getUTCSeconds(),\n\n\n        /**\n         *  date.UTC.milliseconds - function\n         *  ------------------------------------------------------------------------\n         *  It returns the milliseconds of a given date, in the UTC-0 timezone.\n         *  ```\n         *  ms = date.UTC.milliseconds(dt)\n         *  ```\n         */\n        milliseconds: date => D(date).getUTCMilliseconds(),\n    }\n};\n\nconst D = date => new Date(date);\n\n\n//# sourceURL=webpack:////home/marcello/mdb/Code/olojs/node_modules/@onlabsorg/swan-js/lib/modules/date.js?");

/***/ }),

/***/ "../../node_modules/@onlabsorg/swan-js/lib/modules/path.js":
/*!*****************************************************************************************!*\
  !*** /home/marcello/mdb/Code/olojs/node_modules/@onlabsorg/swan-js/lib/modules/path.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n *  path - swan stdlib module\n *  ============================================================================\n *  This module contains functions to manipulate file path strings.\n */\n\nconst pathlib = __webpack_require__(/*! path */ \"../../node_modules/path-browserify/index.js\");\n\nmodule.exports = {\n\n    /**\n     *  path.dir - function\n     *  ------------------------------------------------------------------------\n     *  Given a path `p`, it returns the path without the terminal segment.\n     *  ```\n     *  dirPath = path.dir(p)\n     *  ```\n     */\n    dir (path) {\n        return pathlib.dirname(path);\n    },\n\n\n    /**\n     *  path.fullName - function\n     *  ------------------------------------------------------------------------\n     *  Given a path `p`, it returns the terminal segment.\n     *  ```\n     *  name = path.fullName(p)\n     *  ```\n     */\n    fullName (path) {\n        return pathlib.basename(path);\n    },\n\n\n    /**\n     *  path.name - function\n     *  ------------------------------------------------------------------------\n     *  Given a path `p`, it returns the terminal segment, without extension.\n     *  ```\n     *  pathName = path.name(p)\n     *  ```\n     */\n    name (path) {\n        const fullName = this.fullName(path);\n        const ext = this.ext(path);\n        return fullName.slice(0, ext.length+1);\n    },\n\n\n    /**\n     *  path.ext - function\n     *  ------------------------------------------------------------------------\n     *  Given a path `p`, it returns the extension of the terminal segment.\n     *  ```\n     *  pathExt = path.ext(p)\n     *  ```\n     */\n    ext (path) {\n        return pathlib.extname(path);\n    },\n\n\n    /**\n     *  path.normalize - function\n     *  ------------------------------------------------------------------------\n     *  Given a path `p`, it returns an equivalent path, after resolving `.`,\n     *  `..` and multiple `/`.\n     *  ```\n     *  nPath = path.normalize(p)\n     *  ```\n     */\n    normalize (path) {\n        return pathlib.normalize(path);\n    },\n\n\n    /**\n     *  path.join - function\n     *  ------------------------------------------------------------------------\n     *  Given a tuple of paths, it returns a signle path obtained by\n     *  concatenating them.\n     *  ```\n     *  jPath = path.join(p1, p2, p3, ...)\n     *  ```\n     */\n    join (...paths) {\n        return pathlib.join(...paths);\n    },\n\n\n    /**\n     *  path.resolve - function\n     *  ------------------------------------------------------------------------\n     *  Given a tuple of paths, it resolves a sequence of paths or path segments\n     *  into an absolute path.\n     *  ```\n     *  absPath = path.resolve(p1, p2, p3, ...)\n     *  ```\n     */\n    resolve (...paths) {\n        return pathlib.resolve(\"/\", ...paths);\n    }\n};\n\n\n//# sourceURL=webpack:////home/marcello/mdb/Code/olojs/node_modules/@onlabsorg/swan-js/lib/modules/path.js?");

/***/ }),

/***/ "../../node_modules/@onlabsorg/swan-js/lib/parser.js":
/*!***********************************************************************************!*\
  !*** /home/marcello/mdb/Code/olojs/node_modules/@onlabsorg/swan-js/lib/parser.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("//  The main export of this module creates and returns a `parse` function,\n//  given a set of syntax options.\n//  \n//  The `parse` function takes an expression string as input and returns an\n//  `evaluate` function.\n//\n//  The `evaluate` function takes an evaluation context as input and returns\n//  the expression value as output.\n\nconst Lexer = __webpack_require__(/*! ./lexer */ \"../../node_modules/@onlabsorg/swan-js/lib/lexer.js\");\n\n\n\nclass Parser {\n    \n    constructor (options) {\n        this.options = options;\n        \n        // create the lexer, given the list of the valid operators\n        this.lexer = new Lexer({\n            binaryOperators: Object.keys(options.binaryOperations),\n            unaryOperators: Object.keys(options.unaryOperations)\n        });\n    }\n    \n    tokenize (source) {\n        return new Tokens(...this.lexer.tokenize(source));\n    }\n    \n    // The `createOperation` funcction returns a function that, once called\n    // with a `context` object, executes an operation and return its value.\n    // Each operation is a node of the AST generated by this parser: each\n    // operand of the operation is in turn either another operation or\n    // a value (leaf).\n    createOperation (handlerName, operands, position) {\n        return async context => {\n            try {\n                if (typeof context[handlerName] !== \"function\") {\n                    throw new Error(`'${handlerName}' handler not defined in this context`);\n                }                \n                return await context[handlerName](...operands, position);\n                \n            } catch (error) {\n                return await context[this.options.errorHandler](error, position);\n            }\n        }\n    }\n    \n    createSyntaxError (message, token) {\n        return new Lexer.SyntaxError(message, token.position.source, token.position.index);\n    }\n    \n    // The following tuns turns the next tokens into a single Operation tree.\n    // It stops when the passed `done` condition is true\n    parseExpression (tokens, done) {\n        \n        // If the `done` condition is immediately true, than the expression\n        // is empty and the `void` operation is returned.\n        if (done()) {\n            const lastToken = tokens.get() || tokens.last || tokens.tail;\n            tokens.inc(); return this.createOperation(this.options.voidHandler, [], lastToken.position);\n        }\n        \n        // First generates an `expression` list [operand, operator, operand, operator, ...].\n        // Then sorts the operators by precedence and returns a function.\n        \n        // Initialize the `epression` list with the first operand.\n        var expression = [ this.parseOperand(tokens) ];\n        \n        // Iterate over all the other operators and operands and add them\n        // to the `expression` list until the `done` condition is matched.\n        while (!done()) {\n            \n            if (tokens.get() && tokens.get().matchBinaryOperator()) {\n                let operator = Object.create(this.options.binaryOperations[tokens.get().value]);\n                operator.position = tokens.get().position;\n                tokens.inc(); \n                expression.push(operator);                \n                if (done()) {\n                    throw this.createSyntaxError('Operand expected', tokens.get() || tokens.tail);\n                }\n                let operand = this.parseOperand(tokens);\n                expression.push(operand);\n            }\n            else {\n                // if the next token is not an operator, then an empty operator\n                // is assumed. This means that the expression consists of \n                // two operands next to each other, without any interposed\n                // operator.\n                let operator = Object.create(this.options.binaryOperations[\"\"]);\n                operator.position = tokens.get(-1).position;\n                expression.push(operator);\n                let operand = this.parseOperand(tokens);\n                expression.push(operand);\n            }\n        }\n        tokens.inc();\n        \n        // Build the operations tree from the plain list [operand, operator, operand, ...]\n        while (expression.length > 1) {\n            \n            // find higher precedence operand\n            let precedence = 0;\n            let operatorIndex = 0;\n            for (let j=1; j<expression.length; j+=2) {\n                let operator = expression[j];\n                if (operator.precedence > precedence) {\n                    if (operator.right) {\n                        let handler = operator.handler;\n                        while (expression[j+2] && expression[j+2].handler === handler) j += 2;\n                    }\n                    precedence = operator.precedence;\n                    operatorIndex = j;\n                }\n            }\n            \n            // evaluate the higher precedence operation\n            let leftHandOperand = expression[operatorIndex - 1];\n            let operator = expression[operatorIndex];\n            let rightHandOperand = expression[operatorIndex + 1];\n            let operation = this.createOperation(operator.handler, [leftHandOperand, rightHandOperand], operator.position);\n            \n            // replace the [...,left,operator,right,...] items with the operation node\n            expression.splice(operatorIndex-1, 3, operation);\n        }\n        \n        // Returns the root operation\n        return expression[0];                \n    }\n    \n    // Returns the next operand in line.\n    // An operand can be a value (leaf) or an branch of the operation tree.\n    parseOperand (tokens) {\n        var unaryOperator, operand;\n        \n        // If the operand is preceded by a unary operator\n        if (tokens.get() && tokens.get().matchUnaryOperator()) {\n            unaryOperator = tokens.get(); \n            tokens.inc();\n        }\n        \n        // If just a number literal\n        if (tokens.get() && tokens.get().matchNumberLiteral()) {\n            operand = this.createOperation(this.options.numberHandler, [tokens.get().value], tokens.get().position); tokens.inc();\n        }\n        \n        // If a string literal\n        else if (tokens.get() && tokens.get().matchStringLiteral()) {\n            if (tokens.get().quoteSymbol === `'`) operand = this.createOperation(this.options.stringHandler1, [tokens.get().value], tokens.get().position);\n            else if (tokens.get().quoteSymbol === `\"`) operand = this.createOperation(this.options.stringHandler2, [tokens.get().value], tokens.get().position);\n            else if (tokens.get().quoteSymbol === '`') operand = this.createOperation(this.options.stringHandler3, [tokens.get().value], tokens.get().position);\n            tokens.inc();\n        }\n        \n        // If an identifier\n        else if (tokens.get() && tokens.get().matchIdentifier()) {\n            operand = this.createOperation(this.options.nameHandler, [tokens.get().value], tokens.get().position); tokens.inc();            \n        }\n        \n        // If a subexpression between `(` and `)`\n        else if (tokens.get() && tokens.get().matchSymbol('(')) {\n            tokens.inc(); operand = this.parseExpression(tokens,  () => tokens.get() && tokens.get().matchSymbol(\")\") );\n        }\n        \n        // If a subexpression between `[` and `]`\n        else if (tokens.get() && tokens.get().matchSymbol('[')) {\n            const position = tokens.get().position; tokens.inc();\n            let expression = this.parseExpression(tokens,  () => tokens.get() && tokens.get().matchSymbol(\"]\") );\n            operand = this.createOperation(this.options.squareGroupHandler, [expression], position);\n        }\n        \n        // If a subexpression between `{` and `}`\n        else if (tokens.get() && tokens.get().matchSymbol('{')) {\n            const position = tokens.get().position; tokens.inc();\n            let expression = this.parseExpression(tokens,  () => tokens.get() && tokens.get().matchSymbol(\"}\") );\n            operand = this.createOperation(this.options.curlyGroupHandler, [expression], position);\n        }\n        \n        // No valid operand found\n        else {\n            throw this.createSyntaxError('Operand expected', tokens.get() || tokens.tail);\n        }\n        \n        if (unaryOperator) {\n            const handler = this.options.unaryOperations[unaryOperator.value];\n            return this.createOperation(handler, [operand], unaryOperator.position);\n        } else {\n            return operand;\n        }\n    }    \n    \n    \n    parse (source) {\n        try {\n            // Perform the lexical analysis\n            var tokens = this.tokenize(source);    // array of tokens\n            tokens.tail = {position: new Lexer.Position(source, source.length)};\n            \n            // Parse the entier expression and return the `evaluate` function\n            return this.parseExpression(tokens, () => tokens.done() );\n            \n        } catch (error) {\n            return async context => await context[this.options.errorHandler](error);\n        }        \n    }\n    \n    static get Position () {\n        return Lexer.Position;\n    }\n}\n\n\n\nclass Tokens {\n    \n    constructor (...tokens) {\n        this.tokens = tokens;\n        this.index = 0;\n    }\n    \n    inc (step=1) {\n        this.index += step;\n        return this;\n    }\n    \n    get (step=0) {\n        return this.tokens[this.index+step];\n    }\n    \n    get last () {\n        return this.tokens[this.tokens.length-1];\n    }\n    \n    done () {\n        return this.index >= this.tokens.length;\n    }\n}\n\n\n\nmodule.exports = Parser;\n\n\n//# sourceURL=webpack:////home/marcello/mdb/Code/olojs/node_modules/@onlabsorg/swan-js/lib/parser.js?");

/***/ }),

/***/ "../../node_modules/@onlabsorg/swan-js/test/index.js":
/*!***********************************************************************************!*\
  !*** /home/marcello/mdb/Code/olojs/node_modules/@onlabsorg/swan-js/test/index.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var expect = __webpack_require__(/*! chai */ \"../../node_modules/chai/index.js\").expect;\nvar {parse, createContext, defineModule} = __webpack_require__(/*! ../index */ \"../../node_modules/@onlabsorg/swan-js/index.js\");\n\ndescribe(\"SWAN LANGUAGE\", () => {\n    __webpack_require__(/*! ./tuple */ \"../../node_modules/@onlabsorg/swan-js/test/tuple.js\");\n    __webpack_require__(/*! ./interpreter */ \"../../node_modules/@onlabsorg/swan-js/test/interpreter.js\");\n    \n    describe(\"MODULES\", () => {\n\n        it(\"should delegate to the loader, defined with define, mathching the modlePath\", async () => {\n            var context = createContext();\n            var mod1={}, mod2={};\n            defineModule('path/to/mod1', () => mod1);\n            defineModule('/path/to/mod2', () => mod2);\n            expect(await context.require('path/to/mod1')).to.equal(mod1);\n            expect(await context.require('/path/to/mod1')).to.equal(mod1);\n            expect(await context.require('path/to/mod2')).to.equal(mod2);\n            expect(await context.require('/path/to/mod2')).to.equal(mod2);\n        });\n    });\n\n    __webpack_require__(/*! ./modules */ \"../../node_modules/@onlabsorg/swan-js/test/modules.js\");\n});\n\n//# sourceURL=webpack:////home/marcello/mdb/Code/olojs/node_modules/@onlabsorg/swan-js/test/index.js?");

/***/ }),

/***/ "../../node_modules/@onlabsorg/swan-js/test/interpreter.js":
/*!*****************************************************************************************!*\
  !*** /home/marcello/mdb/Code/olojs/node_modules/@onlabsorg/swan-js/test/interpreter.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var chai = __webpack_require__(/*! chai */ \"../../node_modules/chai/index.js\"), expect = chai.expect;\n\nvar interpreter = __webpack_require__(/*! ../lib/interpreter */ \"../../node_modules/@onlabsorg/swan-js/lib/interpreter.js\");\nvar Tuple = interpreter.Tuple;\nvar Undefined = interpreter.Undefined;\nvar Position = __webpack_require__(/*! ../lib/lexer */ \"../../node_modules/@onlabsorg/swan-js/lib/lexer.js\").Position;\nvar parse = expression => context => interpreter.parse(expression)(context).then(tuple => Tuple(tuple).normalize());\nvar context = interpreter.context;\nvar evaluate = (expression, presets={}) => parse(expression)(context.$extend(presets));\n\n\nchai.use(function (chai, utils) {\n    chai.Assertion.addMethod('Tuple', function (itemArray) {\n        var obj = utils.flag(this, 'object');\n        expect(obj).to.be.instanceof(Tuple);\n        expect(Array.from(obj)).to.deep.equal(itemArray);\n    });\n    chai.Assertion.addMethod('Undefined', function (...args) {\n        var obj = utils.flag(this, 'object');\n        expect(obj).to.be.instanceof(Undefined);\n        expect(obj.args).to.be.Tuple(args);\n    });\n});\n\nasync function error (fn) {\n    try {\n        await fn();\n        throw new Error(\"Id din not throw!\");\n    } catch (error) {\n        return error.message;\n    } \n}\n\n\ndescribe(\"SWAN EXPRESSION INTERPRETER\", () => {\n\n\n    // CORE\n\n    describe(\"numeric literals\", () => {\n\n        it(\"should evaluate decimal numeric literals to numbers\", async () => {\n            expect(await evaluate(\"10\")).to.equal(10);\n            expect(await evaluate(\"0\")).to.equal(0);\n            expect(await evaluate(\"-10\")).to.equal(-10);\n            expect(await evaluate(\"3.2\")).to.equal(3.2);\n            expect(await evaluate(\"-3.2\")).to.equal(-3.2);\n            expect(await evaluate(\"1.2e3\")).to.equal(1200);\n        });\n    });\n\n    describe(\"string literals\", () => {\n\n        it(`should evaluate string literals between double quotes '\"\"'`, async () => {\n            expect(await evaluate(`\"abc\"`)).to.equal(\"abc\");\n            expect(await evaluate(`\"\"`)).to.equal(\"\");\n        });\n\n        it(\"should evaluate string literals between single quotes `''`\", async () => {\n            expect(await evaluate(`'def'`)).to.equal(\"def\");\n            expect(await evaluate(`''`)).to.equal(\"\");\n        });\n    });\n\n    describe(\"tuples: `exp1, exp2, exp3, ...`\", () => {\n\n        it(\"should return the comma-separated values as a Tuple\", async () => {\n            expect(await evaluate(\"10,'abc'\")).to.be.Tuple([10,'abc']);\n        });\n\n        it(\"should flatten tuples of tuples: `(X,Y),Z` results in `X,Y,Z`\", async () => {\n            expect(await evaluate(\"1,(2,3),4,(5,(6,7)),8,9\")).to.be.Tuple([1,2,3,4,5,6,7,8,9]);\n        });\n\n        it(\"should ignore empty tuples when flattening tuples: `X,(),Y` results in `X,Y`\", async () => {\n            expect(await evaluate(\"1,(),2\")).to.be.Tuple([1,2]);\n            expect(await evaluate(\"(),(1,(),2),(),3\")).to.be.Tuple([1,2,3]);\n        });\n\n        it(\"should evaluate empty tuples `()` as null\", async () => {\n            expect(await evaluate(\"\")).to.equal(null);\n            expect(await evaluate(\"()\")).to.equal(null);\n            expect(await evaluate(\"(), (), ()\")).to.equal(null);\n        });\n\n        it(\"should evaluate 1-uples (x,()) as x\", async () => {\n            expect(await evaluate(\"(), 10, ()\")).to.equal(10);\n        });\n        \n        it(\"should not complain if any of the items is Undefined\", async () => {\n            var presets = {un: new Undefined()};\n            expect(await evaluate(\"10,un\", presets)).to.be.Tuple([10,presets.un]);\n        });\n    });\n\n    describe(\"lists: `[expression]`\", () => {\n\n        it(\"should return an array\", async () => {\n\n            var list = await evaluate(\"[1,'abc',3]\");\n            expect(list).to.deep.equal([1,\"abc\",3]);\n\n            var list = await evaluate(\"[1]\");\n            expect(list).to.deep.equal([1]);\n\n            var list = await evaluate(\"[]\");\n            expect(list).to.deep.equal([]);\n        });\n\n        it(\"should not flatten deep lists\", async () => {\n            var list = await evaluate(\"[[1,2],3,4,[]]\")\n            expect(list).to.deep.equal([[1,2],3,4,[]]);\n        });\n    });\n\n    describe(\"name resolution\", () => {\n\n        it(\"should return the value mapped to the name in the current context\", async () => {\n            var presets = {a:10, _b:20, __c__:\"xxx\"};\n            expect(await evaluate(\"a\", presets)).to.equal(10);\n            expect(await evaluate(\"_b\", presets)).to.equal(20);\n            expect(await evaluate(\"__c__\", presets)).to.equal(\"xxx\");\n        });\n\n        it(\"should return `null` (empty tuple) if the name is not mapped\", async () => {\n            expect(await evaluate(\"d\", {a:10, _b:20})).to.equal(null);\n        });\n\n        it(\"should throw an error if an invalid name is used\", async () => {\n            const u = await evaluate(\"$a\", {$a:1});\n            expect(u).to.be.instanceof(Undefined);\n            const args = Array.from(u.args);\n            expect(args[0]).to.equal(\"failure\");\n            expect(args[1]).to.be.instanceof(Error);\n            expect(args[1].message).to.equal(\"Unexpected character '$' @1:0\");\n        });\n\n        it(\"should not return properties inherited from javascript Object\", async () => {\n            expect(await evaluate(\"isPrototypeOf\")).to.be.null;\n            expect(await evaluate(\"hasOwnProperty\")).to.be.null;\n        });\n\n        describe(\"name resolution in a child context\", () => {\n\n            it(\"should return the child name value if name is mapped in the child context\", async () => {\n                var presets = Object.assign(Object.create({a:10, b:20}), {a:100});\n                expect(await evaluate(\"a\", presets)).to.equal(100);\n            });\n\n            it(\"should return the parent name value if name is not mapped in the child context\", async () => {\n                var presets = Object.assign(Object.create({a:10, b:20}), {a:100});\n                expect(await evaluate(\"b\", presets)).to.equal(20);\n            });\n\n            it(\"should return null if the name is not mapped in the child context nor in the parent context\", async () => {\n                var presets = Object.assign(Object.create({a:10, b:20}), {a:100});\n                expect(await evaluate(\"c\", presets)).to.equal(null);\n            });\n        });\n    });\n\n    describe(\"labelling operation `name: expression`\", () => {\n\n        it(\"should create a new name in the current context and map it to the given value\", async () => {\n            var ctx = context.$extend();\n            await parse(\"x: 10\")(ctx);\n            expect(ctx.x).to.equal(10);\n        });\n\n        it(\"should assign a tuple of values to a tuple of names\", async () => {\n            var ctx = context.$extend();\n            await parse(\"(a,b,c) : (1,2,3)\")(ctx);\n            expect(ctx.a).to.equal(1);\n            expect(ctx.b).to.equal(2);\n            expect(ctx.c).to.equal(3);\n        });\n\n        it(\"should assign null to the last names if the values tuple is smaller than the names tuple\", async () => {\n            var ctx = context.$extend();\n            await parse(\"(a,b,c,d) : (10,20)\")(ctx);\n            expect(ctx.a).to.equal(10);\n            expect(ctx.b).to.equal(20);\n            expect(ctx.c).to.be.null;\n            expect(ctx.d).to.be.null;\n        });\n\n        it(\"should assign to the last name the tuple of remaining values if the names tuple is smaller than the values tuple\", async () => {\n            var ctx = context.$extend();\n\n            await parse(\"(a,b) : (100,200,300)\")(ctx);\n            expect(ctx.a).to.equal(100);\n            expect(ctx.b).to.be.Tuple([200,300]);\n\n            await parse(\"c : (10,20,30)\")(ctx);\n            expect(ctx.c).to.be.Tuple([10,20,30]);\n        });\n\n        it(\"should overwrite an existing name-value mapping\", async () => {\n            var ctx = context.$extend({a:1});\n            await parse(\"a : 2\")(ctx);\n            await parse(\"a : 3\")(ctx);\n            expect(ctx.a).to.equal(3);\n        });\n\n        it(\"should return the expression value\", async () => {\n            expect(await evaluate(\"x: 10\")).to.equal(10);\n            expect(await evaluate(\"(a,b,c) : (1,2,3)\")).to.be.Tuple([1,2,3]);\n            expect(await evaluate(\"(a,b,c,d) : (10,20)\")).to.be.Tuple([10,20]);\n            expect(await evaluate(\"(a,b) : (100,200,300)\")).to.be.Tuple([100,200,300]);\n            expect(await evaluate(\"c : (10,20,30)\")).to.be.Tuple([10,20,30]);\n        });\n        \n        it(\"should ignore non-valid names\", async () => {\n            var ctx = context.$extend();\n            var value = await parse(\"(a, 1, b): (10, 20, 30)\")(ctx);\n            expect(value).to.be.Tuple([10,20,30]);\n            expect(ctx.a).to.equal(10);\n            expect(ctx.b).to.be.Tuple([20,30]);\n        });\n    });\n\n    describe(\"assignment operation: name = expression\", () => {\n\n        it(\"should return null\", async () => {\n            expect(await evaluate(\"x = 10\")).to.equal(null);\n        });\n\n        it(\"should create a new name in the current context and map it to the given value\", async () => {\n            var ctx = context.$extend();\n            await parse(\"x = 10\")(ctx);\n            expect(ctx.x).to.equal(10);\n        });\n\n        it(\"should assign a tuple of values to a tuple of names\", async () => {\n            var ctx = context.$extend();\n            await parse(\"(a,b,c) = (1,2,3)\")(ctx);\n            expect(ctx.a).to.equal(1);\n            expect(ctx.b).to.equal(2);\n            expect(ctx.c).to.equal(3);\n        });\n\n        it(\"should assign null to the last names if the values tuple is smaller than the names tuple\", async () => {\n            var ctx = context.$extend();\n            await parse(\"(a,b,c,d) = (10,20)\")(ctx);\n            expect(ctx.a).to.equal(10);\n            expect(ctx.b).to.equal(20);\n            expect(ctx.c).to.be.null;\n            expect(ctx.d).to.be.null;\n        });\n\n        it(\"should assign to the last name the tuple of remaining values if the names tuple is smaller than the values tuple\", async () => {\n            var ctx = context.$extend();\n\n            await parse(\"(a,b) = (100,200,300)\")(ctx);\n            expect(ctx.a).to.equal(100);\n            expect(ctx.b).to.be.Tuple([200,300]);\n\n            await parse(\"c = (10,20,30)\")(ctx);\n            expect(ctx.c).to.be.Tuple([10,20,30]);\n        });\n\n        it(\"should overwrite an existing name-value mapping\", async () => {\n            var ctx = context.$extend({a:1});\n            await parse(\"a = 2\")(ctx);\n            await parse(\"a = 3\")(ctx);\n            expect(ctx.a).to.equal(3);\n        });\n    });\n\n    describe(\"namespace definition: {expression}\", () => {\n\n        it(\"return an object with the mapped names\", async () => {\n            expect(await evaluate(\"{x=1, y:2, z=3}\")).to.deep.equal({x:1,y:2,z:3});\n        });\n\n        it(\"should ignore the non-assignment operations\", async () => {\n            expect(await evaluate(\"{x=1, 10, y=2, z=3}\")).to.deep.equal({x:1,y:2,z:3});\n        });\n\n        it(\"should not assign the names to the parent context\", async () => {\n            var ctx = context.$extend({x:10});\n            expect(await parse(\"{x=20}\")(ctx)).to.deep.equal({x:20});\n            expect(ctx.x).to.equal(10);\n        });\n    });\n\n    describe(\"function definition: names_tuple -> expression\", () => {\n\n        it(\"should return a function resolving the expression in a context augumented with the argument names\", async () => {\n            var foo = await evaluate(\"(x, y) -> [y,x]\");\n            expect(foo).to.be.a(\"function\");\n            expect(await foo(10,20)).to.deep.equal([20,10]);\n        });\n\n        it(\"should follow the assignment rules when mapping argument names to parameters\", async () => {\n\n            var foo = await evaluate(\"(x, y) -> {a=x,b=y}\");\n            expect(await foo(10)).to.deep.equal({a:10, b:null});\n\n            var retval = await foo(10,20,30);\n            expect(retval.a).to.equal(10);\n            expect(retval.b).to.be.Tuple([20,30]);\n        });\n\n        it(\"should be righ-to-left associative\", async () => {\n            var foo = await evaluate(\"x -> y -> {a=x,b=y}\");\n            var foo10 = await foo(10);\n            expect(foo10).to.be.a(\"function\");\n            expect(await foo10(20)).to.deep.equal({a:10, b:20});\n        });\n    });\n    \n    describe(\"'apply' operation: F X`\", () => {\n        \n        describe(\"when `F` is a function\", () => {\n            \n            it(\"should call F with the parameter X and return its return value\", async () => {\n                var presets = {\n                    double: x => 2 * x,\n                    sum: (x,y) => x + y\n                };\n                expect(await evaluate(\"(x -> [x]) 10\", presets)).to.deep.equal([10]);\n                expect(await evaluate(\"((x, y) -> [y,x])(10, 20)\", presets)).to.deep.equal([20,10]);\n                expect(await evaluate(\"double 25\", presets)).to.equal(50);\n                expect(await evaluate(\"sum(10, 20)\", presets)).to.equal(30);\n            });\n\n            it(\"should return Undefined if F throws an error\", async () => {\n                var error = new Error('Test error');\n                var presets = {fn: x => {throw error}};\n                var u = await evaluate('fn 10', presets);\n                expect(u).to.be.Undefined('failure', error, new Position(\"fn 10\", 2));\n            });\n\n            it(\"should return Undefined if F returns Undefined\", async () => {\n                var un = new Undefined();\n                var presets = {fn: x => un};\n                expect(await evaluate('fn 10', presets)).to.equal(un);\n            });\n        });\n        \n        describe(\"when `F` is a namespace and `F.__apply__` is a function\", () => {\n            \n            it(\"should call F with the parameter X and return its return value\", async () => {\n                var presets = {\n                    double: {__apply__: x => 2 * x},\n                    sum: {__apply__: (x,y) => x + y}\n                };\n                expect(await evaluate(\"(x -> [x]) 10\", presets)).to.deep.equal([10]);\n                expect(await evaluate(\"((x, y) -> [y,x])(10, 20)\", presets)).to.deep.equal([20,10]);\n                expect(await evaluate(\"double 25\", presets)).to.equal(50);\n                expect(await evaluate(\"sum(10, 20)\", presets)).to.equal(30);\n            });\n\n            it(\"should return Undefined if F.__apply__ throws an error\", async () => {\n                var error = new Error('Test error');\n                var presets = {fn: {__apply__: x => {throw error}}};\n                var u = await evaluate('fn 10', presets);\n                expect(u).to.be.Undefined('failure', error, new Position(\"fn 10\", 2));\n            });\n\n            it(\"should return Undefined if F returns Undefined\", async () => {\n                var un = new Undefined();\n                var presets = {fn: {__apply__: x => un}};\n                expect(await evaluate('fn 10', presets)).to.equal(un);\n            });\n        });\n\n        describe(\"when F is of any other type\", () => {\n\n            it(\"should return Undefined\", async () => {\n                for (let F of [true, false, 10, \"abc\", [1,2,3], {a:1}, {__apply__:'not a func'}, new Undefined]) {\n                    expect(await evaluate(\"F(1)\", {F})).to.be.Undefined('application', F, new Position(\"F(1)\", 1));\n                    expect(await evaluate(\"F(1,2,3)\", {F})).to.be.Undefined('application', F, new Position(\"F(1,2,3)\", 1));\n                }\n            });            \n        });\n        \n        describe(\"when F is a tuple\", () => {\n            \n            it(\"should return a tuple obtained applying each item of F to X\", async () => {\n                var presets = {\n                    f2: x => 2*x,\n                    f3: {__apply__: x => 3*x},\n                    s: 'abc'\n                };\n                var source = \"(f2, f3, s)(2)\";\n                var tuple = await evaluate(source, presets);\n                expect(tuple).to.be.instanceof(Tuple);\n                expect(Array.from(tuple)[0]).to.equal(4);\n                expect(Array.from(tuple)[1]).to.equal(6);\n                expect(Array.from(tuple)[2]).to.be.Undefined('application', presets.s, new Position(source, 10));\n            });\n        });\n\n    });\n\n    describe(\"tuple mapping operation: X => Y\", () => {\n        \n        it(\"should apply Y to each item of X and return the resulting tuple\", async () => {\n            expect(await evaluate(\"(1,2,3) => x -> 2*x\")).to.be.Tuple([2,4,6]);\n            var tuple = await evaluate(\"(1,2,3) => 'abcdef'\");\n            expect(tuple).to.be.instanceof(Tuple);\n            expect(Array.from(tuple)[0]).to.be.Undefined('application', \"abcdef\");\n            expect(Array.from(tuple)[1]).to.be.Undefined('application', \"abcdef\");\n            expect(Array.from(tuple)[2]).to.be.Undefined('application', \"abcdef\");\n        });\n    });\n    \n    describe(\"referencing operation: X @ Y\", () => {\n        \n        describe(\"when X is a string\", async () => {\n\n            it(\"should return the Y-th character if Y is an integer\", async () => {\n                expect(await evaluate(\"'abcdef' @ 2\")).to.equal('c');\n            });\n\n            it(\"should consider only the integer part of Y if Y is a decimal number\", async () => {\n                expect(await evaluate(\"'abcdef' @ 2.3\")).to.equal('c');\n            });\n\n            it(\"should consider negative indexes as relative to the string end\", async () => {\n                expect(await evaluate(\"'abcdef' @ (-2)\")).to.equal('e');\n            });\n\n            it(\"should return an empty string if Y is an out of range number or not a number\", async () => {\n                expect(await evaluate(\"'abcdef' @ 100\")).to.equal(\"\");\n                expect(await evaluate(\"'abcdef' @ (-100)\")).to.equal(\"\");\n                expect(await evaluate(\"'abcdef' @ ('1')\")).to.equal(\"\");\n                expect(await evaluate(\"'abcdef' @ ([])\")).to.equal(\"\");\n                expect(await evaluate(\"'abcdef' @ ({})\")).to.equal(\"\");\n            });\n\n            it(\"should return a tuple of charcters if Y is a tuple of numbers\", async () => {\n                expect(await evaluate(\"'abcdef' @ (1,'x',-1)\")).to.be.Tuple(['b','','f']);\n            });\n        });\n\n        describe(\"when X is a list\", () => {\n\n            it(\"shoudl return the Y-th item if Y is an integer\", async () => {\n                expect(await evaluate(\"['a','b','c','d','e','f'] @ 2\")).to.equal('c');\n            });\n\n            it(\"should consider only the integer part of Y if it is a decimal number\", async () => {\n                expect(await evaluate(\"['a','b','c','d','e','f'] @ 2.3\")).to.equal('c');\n            });\n\n            it(\"should consider a negative indexe Y as relative to the list end\", async () => {\n                expect(await evaluate(\"['a','b','c','d','e','f'] @ (-2)\")).to.equal('e');\n            });\n\n            it(\"should return null if the index Y is an out of range number or not a number\", async () => {\n                expect(await evaluate(\"['a','b','c','d','e','f'] @ 100\")).to.equal(null);\n                expect(await evaluate(\"['a','b','c','d','e','f'] @ (-100)\")).to.equal(null);\n                expect(await evaluate(\"['a','b','c','d','e','f'] @ ('1')\")).to.equal(null);\n                expect(await evaluate(\"['a','b','c','d','e','f'] @ ([])\")).to.equal(null);\n                expect(await evaluate(\"['a','b','c','d','e','f'] @ ({})\")).to.equal(null);\n            });\n\n            it(\"should return a tuple of values if Y is a tuple of numbers\", async () => {\n                expect(await evaluate(\"['a','b','c','d','e','f'] @ (1,'x',-1)\")).to.be.Tuple(['b','f']);\n            });\n        });\n\n        describe(\"when X is a namespace\", () => {\n\n            it(\"should return the value mapped to the name Y\", async () => {\n                expect(await evaluate(\"{a=1,b=2,c=3} @ 'c'\")).to.equal(3);\n            });\n\n            it(\"should return null if Y is not a valid name\", async () => {\n                expect(await evaluate(\"{a=1,b=2,c=3} @ 1\")).to.equal(null);\n                expect(await evaluate(\"{a=1,b=2,c=3} @ '$key'\")).to.equal(null);\n            });\n\n            it(\"should return null if Y is a name not mapped to any value\", async () => {\n                expect(await evaluate(\"{a=1,b=2,c=3} @ 'd'\")).to.equal(null);\n            });\n            \n            it(\"should return multiple values if Y is a tuple of names\", async () => {\n                expect(await evaluate(\"{a:1,b:2,c:3}@('a',1,'c')\")).to.be.Tuple([1,3]);\n            });\n        });\n\n        describe(\"when X is of any other type\", () => {\n            \n            it(\"should return Undefined\", async () => {\n                for (let X of [true, false, 10, x=>x, new Undefined()]) {\n                    expect(await evaluate(\"X@(1)\", {X})).to.be.Undefined('referencing', X, 1, new Position(\"X@(1)\", 1));\n                }\n            });\n        });\n        \n        describe(\"when X is a tuple\", () => {\n            \n            it(\"should return a tuple obtained referencing each item to X if X is a tuple\", async () => {\n                var presets = {\n                    s: \"abcdef\",\n                    ls: [10,20,30,40,50],\n                    b: true\n                };\n                var source = \"(s, ls, b)@(2)\";\n                var tuple = await evaluate(source, presets);\n                expect(tuple).to.be.instanceof(Tuple);\n                expect(Array.from(tuple)[0]).to.equal('c');\n                expect(Array.from(tuple)[1]).to.equal(30);\n                expect(Array.from(tuple)[2]).to.be.Undefined('referencing', presets.b, 2, new Position(source, 10));\n            });\n        });\n    });\n\n    describe(\"sub-contexting: namespace.expression\", () => {\n\n        it(\"should evaluate 'Y' in the 'X' context if 'X' is a namespace\", async () => {\n            var ctx = context.$extend({x:10});\n            await parse(\"ns = {y=20, z=30, _h=40}\")(ctx);\n            expect(await parse(\"ns.y\")(ctx)).to.equal(20);\n            expect(await parse(\"ns.[1,y,z]\")(ctx)).to.deep.equal([1,20,30]);\n            expect(await parse(\"ns.x\")(ctx)).to.equal(10);\n            expect(await parse(\"ns._h\")(ctx)).to.equal(40);\n\n            var ctx = context.$extend({ns:{x:10,y:20,z:30}});\n            expect(await parse(\"ns.[x,y,z]\")(ctx)).to.deep.equal([10,20,30]);\n        });\n\n        it(\"should see the global contexts\", async () => {\n            var ctx = context.$extend({x:10});\n            await parse(\"ns = {y=20}\")(ctx);\n            expect(await parse(\"ns.x\")(ctx)).to.equal(10);\n            expect(await parse(\"ns.y\")(ctx)).to.equal(20);\n        });\n\n        it(\"should see the function parameters in a function expressions\", async () => {\n            var ctx = context.$extend({x:10});\n            await parse(\"ns = {x=10}, nsp = {x=20}\")(ctx);\n            await parse(\"f = nsp -> nsp.x\")(ctx);\n            expect(await parse(\"f ns\")(ctx)).to.equal(10);\n        });\n\n        it(\"should return Undefined if 'X' is of any other type\", async () => {\n            expect(await evaluate(\"(10).name\")).to.be.Undefined(\"subcontexting\", 10, new Position(\"(10).name\", 4));\n            expect(await evaluate(\"[].name\")).to.be.Undefined(\"subcontexting\", [], new Position(\"[].name\", 2));\n            var presets = {fn: x=>2*x}\n            expect(await evaluate(\"fn.name\", presets)).to.be.Undefined(\"subcontexting\", presets.fn, new Position(\"fn.name\", 2));\n        });\n        \n        it(\"should return a tuple of items, one for each item of X if X is a tuple of namespaces\", async () => {\n            expect(await evaluate(`({a:1},{a:2},{a:3}).a`)).to.be.Tuple([1,2,3]);\n        });\n    });\n\n    describe(\"comments\", () => {\n\n        it(\"should ignore the text following the `#` character up to the end of the line or of the expression\", async () => {\n            var expression = `\n                # this is a comment\n                12.345 # this is another comment\n                # this is the last comment`\n            expect(await evaluate(expression)).to.equal(12.345);\n        });\n\n        it(\"should not parse `#` characters in a string as comments\", async () => {\n            expect(await evaluate(\"'this # is a string'\")).to.equal(\"this # is a string\");\n            expect(await evaluate(`\"this # is a string\"`)).to.equal(\"this # is a string\");\n        });\n    });\n\n\n    // CONSTANTS\n\n    describe(\"TRUE constant\", () => {\n        it(\"should return true\", async () => {\n            expect(await evaluate(\"TRUE\")).to.equal(true);\n        });\n    });\n\n    describe(\"FALSE constant\", () => {\n        it(\"should return false\", async () => {\n            expect(await evaluate(\"FALSE\")).to.equal(false);\n        });\n    });\n\n    describe(\"INFINITY constant\", () => {\n        it(\"should return Infinity\", async () => {\n            expect(await evaluate(\"INFINITY\")).to.equal(Infinity);\n        });\n    });\n    \n    \n    // BUILT-IN FUNCTIONS\n    \n    describe(\"undefined X\", () => {\n        \n        it(\"should return Undefined\", async () => {\n            var u = await evaluate(\"undefined('testing', 1)\");\n            expect(u).to.be.Undefined(\"testing\", 1);\n\n            var u = await evaluate(\"undefined('testing', 1, [])\");\n            expect(u).to.be.Undefined(\"testing\", 1, []);\n\n            var u = await evaluate(\"undefined('testing', 1, [], {})\");\n            expect(u).to.be.Undefined(\"testing\", 1, [], {});\n\n            var u = await evaluate(\"undefined('testing', null)\");\n            expect(u).to.be.Undefined(\"testing\");\n        });\n    });\n    \n    describe(\"bool X\", () => {\n\n        it(\"should return X if it is a boolean\", async () => {\n            expect(await evaluate(\"bool FALSE\")).to.equal(false);\n            expect(await evaluate(\"bool TRUE\")).to.equal(true);\n        });\n\n        it(\"should return true if X is a non-zero number\", async () => {\n            expect(await evaluate(\"bool 0\")).to.equal(false);\n            expect(await evaluate(\"bool 10\")).to.equal(true);\n            expect(await evaluate(\"bool (-1)\")).to.equal(true);\n        });\n\n        it(\"should return true if X is a non-empty string\", async () => {\n            expect(await evaluate(\"bool ''\")).to.equal(false);\n            expect(await evaluate(\"bool 'abc'\")).to.equal(true);\n        });\n\n        it(\"should return true if X is a non-empty list\", async () => {\n            expect(await evaluate(\"bool []\")).to.equal(false);\n            expect(await evaluate(\"bool [1,2,3]\")).to.equal(true);\n        });\n\n        it(\"should return true if X is a non-empty namespace\", async () => {\n            expect(await evaluate(\"bool {}\")).to.equal(false);\n            expect(await evaluate(\"bool {a=1,b=2,c=3}\")).to.equal(true);\n        });\n\n        it(\"should return true if X is a function\", async () => {\n            expect(await evaluate(\"bool (x->x)\")).to.equal(true);\n            expect(await evaluate(\"bool jsFn\", {jsFn:x=>2*x})).to.equal(true);\n        });\n\n        it(\"should return true if X is a tuple with at least one true item\", async () => {\n            expect(await evaluate(\"bool (0,0,0)\")).to.equal(false);\n            expect(await evaluate(\"bool (0,1,-1)\")).to.equal(true);\n        });\n        \n        it(\"should return false if X is an empty tuple\", async () => {\n            expect(await evaluate(\"bool ()\")).to.equal(false);\n        });\n        \n        it(\"should return Undefined if any of the X items is Undefined\", async () => {\n            var presets = {\n                un1: new Undefined('text1'),\n                un2: new Undefined('test2'),\n            };\n            expect(await evaluate(\"bool un1\", presets)).to.be.Undefined('booleanization', presets.un1);\n            expect(await evaluate(\"bool (0,un1,un2)\", presets)).to.be.Undefined('booleanization', presets.un1);\n        });\n    });\n\n    describe(\"not X\", () => {\n\n        it(\"should return !X if it is a boolean\", async () => {\n            expect(await evaluate(\"not FALSE\")).to.equal(!false);\n            expect(await evaluate(\"not TRUE\")).to.equal(!true);\n        });\n\n        it(\"should return false if X is a non-zero number\", async () => {\n            expect(await evaluate(\"not 0\")).to.equal(!false);\n            expect(await evaluate(\"not 10\")).to.equal(!true);\n            expect(await evaluate(\"not (-1)\")).to.equal(!true);\n        });\n\n        it(\"should return false if X is a non-empty string\", async () => {\n            expect(await evaluate(\"not ''\")).to.equal(!false);\n            expect(await evaluate(\"not 'abc'\")).to.equal(!true);\n        });\n\n        it(\"should return false if X is a non-empty list\", async () => {\n            expect(await evaluate(\"not []\")).to.equal(!false);\n            expect(await evaluate(\"not [1,2,3]\")).to.equal(!true);\n        });\n\n        it(\"should return false if X is a non-empty namespace\", async () => {\n            expect(await evaluate(\"not {}\")).to.equal(!false);\n            expect(await evaluate(\"not {a=1,b=2,c=3}\")).to.equal(!true);\n        });\n\n        it(\"should return false if X is a function\", async () => {\n            expect(await evaluate(\"not (x->x)\")).to.equal(!true);\n            expect(await evaluate(\"not jsFn\", {jsFn:x=>2*x})).to.equal(!true);\n        });\n\n        it(\"should return false if X is a tuple with at least one true item\", async () => {\n            expect(await evaluate(\"not (0,0,0)\")).to.equal(!false);\n            expect(await evaluate(\"not (0,1,-1)\")).to.equal(!true);\n        });\n\n        it(\"should return true if X is an empty tuple\", async () => {\n            expect(await evaluate(\"not ()\")).to.equal(!false);\n        });\n\n        it(\"should return Undefined if any of the X items is undefined\", async () => {\n            var presets = {\n                un1: new Undefined('text1'),\n                un2: new Undefined('test2'),\n            };\n            expect(await evaluate(\"not un1\", presets)).to.be.Undefined('booleanization', presets.un1);\n            expect(await evaluate(\"not (0,un1,un2)\", presets)).to.be.Undefined('booleanization', presets.un1);\n        });\n    });\n\n    describe(\"str X\", () => {\n\n        it(\"should return an empty string if X is nothing\", async () => {\n            expect(await evaluate(\"str ()\")).to.equal(\"\");\n        });\n\n        it(\"should return 'TRUE' if X is true\", async () => {\n            expect(await evaluate(\"str TRUE\")).to.equal(\"TRUE\");\n        });\n\n        it(\"should return 'FALSE' if X is false\", async () => {\n            expect(await evaluate(\"str FALSE\")).to.equal(\"FALSE\");\n        });\n\n        it(\"should return String(X) if X is a number\", async () => {\n            expect(await evaluate(\"str 123.4\")).to.equal(\"123.4\");\n        });\n\n        it(\"should return X itself if it is a string\", async () => {\n            expect(await evaluate(\"str 'abc'\")).to.equal(\"abc\");\n        });\n\n        it(\"should return '[[Function]]' if X is a function\", async () => {\n            expect(await evaluate(\"str jsFn\", {jsFn: x => 2*x})).to.equal(\"[[Function]]\");\n            expect(await evaluate(\"str (x->x)\", {jsFn: x => 2*x})).to.equal(\"[[Function]]\");\n        });\n\n        it(\"should return '[[List of n items]]' when X is a list with n items\", async () => {\n            expect(await evaluate(\"str[1,2,'abc']\")).to.equal(\"[[List of 3 items]]\")\n        });\n\n        it(\"should return '[[Namespace of n items]]' when X is a namestpace with n items\", async () => {\n            expect(await evaluate(\"str{a=1,b=2,c=3}\")).to.equal(\"[[Namespace of 3 items]]\");\n            expect(await evaluate(\"str ns\", {ns:{a:1,b:2,c:3,$d:4}})).to.equal(\"[[Namespace of 3 items]]\");\n        });\n        \n        it(\"shoulr return `X.__str__` if `X` is a namespace and `X.__str__` is a string\", async () => {\n            expect(await evaluate(\"str{__str__:'custom string'}\")).to.equal(\"custom string\");\n            expect(await evaluate(\"str{a=1,b=2,__str__=3}\")).to.equal(\"[[Namespace of 3 items]]\");            \n        });\n        \n        it(\"Should return '[[Undefined: arg1, arg2, ...]]' if X is Undefined\", async () => {\n            var presets = {un: new Undefined(\"test\", 10, [1,2,3], new Position(\"\\n1+2\", 2))};\n            console.log(await evaluate(\"str un\", presets));\n            expect(await evaluate(\"str un\", presets)).to.equal(\"[[Undefined: test, 10, [[List of 3 items]], @2:1]]\");\n        });\n\n        it(\"should concatenate the serialized item if X is a tuple\", async () => {\n            expect(await evaluate(\"str('it is ',TRUE,' that 1+2 is ',3)\")).to.equal(\"it is TRUE that 1+2 is 3\");\n        });\n    });\n\n    describe(\"enum X\", () => {\n        \n        it(\"shoule return the tuple of the first X integers if X is a number\", async () => {\n            expect(await evaluate('enum 5')).to.be.Tuple([0,1,2,3,4]);\n            expect(await evaluate('enum 5.1')).to.be.Tuple([0,1,2,3,4,5]);\n            expect(await evaluate('enum (-3)')).to.be.Tuple([0,-1,-2]);\n            expect(await evaluate('enum (-3.1)')).to.be.Tuple([0,-1,-2,-3]);\n            expect(await evaluate(\"enum 1\")).to.equal(0);\n            expect(await evaluate(\"enum 0\")).to.equal(null);\n        });\n        \n        it(\"should return the tuple `(x1,x2,x3,...)` when X is the list `[x1,x2,x3,...]`\", async () => {\n            expect(await evaluate(\"enum [10,20,30]\")).to.be.Tuple([10,20,30]);\n            expect(await evaluate(\"enum ls\", {ls:[10,20,30]})).to.be.Tuple([10,20,30]);\n            expect(await evaluate(\"enum [1]\")).to.equal(1);\n            expect(await evaluate(\"enum []\")).to.equal(null);\n            \n            // it doesn't complain if a list item is Undefined\n            var presets = {un: new Undefined('Test exception!')};\n            expect(await evaluate(\"enum [1,un,2]\", presets)).to.be.Tuple([1,presets.un,2]);\n            expect(await evaluate(\"enum [un]\", presets)).to.equal(presets.un);\n        });\n\n        it(\"should return the tuple `('a','b','c')` when X is the string `'abc'`\", async () => {\n            expect(await evaluate(\"enum 'abc'\")).to.be.Tuple(['a','b','c']);\n            expect(await evaluate(\"enum s\", {s:\"abc\"})).to.be.Tuple(['a','b','c']);\n            expect(await evaluate(\"enum 'a'\")).to.equal(\"a\");\n            expect(await evaluate(\"enum ''\")).to.equal(null);\n        });\n\n        it(\"should return the tuple `('name1','name2',...)` when X is the namespace `{name1:val1, name2:val2, ...}`\", async () => {\n            expect(await evaluate(\"enum {a:1,b:2,c:3}\")).to.be.Tuple(['a','b','c']);\n            expect(await evaluate(\"enum ns\", {ns:{a:1,b:2,c:3,$d:4}})).to.be.Tuple(['a','b','c']);\n            expect(await evaluate(\"enum {a:1}\")).to.equal(\"a\");\n            expect(await evaluate(\"enum {}\")).to.equal(null);\n        });\n        \n        it(\"should return Undefined when X is of any other type\", async () => {\n            expect(await evaluate(\"enum TRUE\")).to.be.Undefined(\"enumeration\", true);\n            expect(await evaluate(\"enum FALSE\")).to.be.Undefined(\"enumeration\", false);\n            \n            var presets = {un: new Undefined(), fn: x=>2*x};\n            expect(await evaluate(\"enum fn\", presets)).to.be.Undefined(\"enumeration\", presets.fn);\n            expect(await evaluate(\"enum un\", presets)).to.be.Undefined('enumeration', presets.un);\n        });\n\n        it(\"should concatenate the enumeration of each item if X is a tuple\", async () => {\n            expect(await evaluate(\"enum ('abc',[1,2,3])\")).to.be.Tuple(['a','b','c',1,2,3]);\n        });\n    });\n\n    describe(\"type X\", () => {\n\n        it(\"should return Nothing if `X` is an empty tuple\", async () => {\n            expect(await evaluate(\"type()\")).to.equal(null);\n        });\n        \n        it(\"should return 'Undefined' if `X` is an Undefined object\", async () => {\n            var presets = {un: new Undefined()};\n            expect(await evaluate(\"type un\", presets)).to.equal('Undefined');\n        });\n\n        it(\"should return 'Boolean' if `X` is a boolean value\", async () => {\n            expect(await evaluate(\"type TRUE\")).to.equal(\"Boolean\");\n            expect(await evaluate(\"type FALSE\")).to.equal(\"Boolean\");\n        });\n\n        it(\"should return 'Number' if `X` is a number\", async () => {\n            expect(await evaluate(\"type 1\")).to.equal(\"Number\");\n        });\n\n        it(\"should return 'String' if `X` is a string\", async () => {\n            expect(await evaluate(\"type 'abc'\")).to.equal(\"String\");\n        });\n\n        it(\"should return 'List' if `X` is a list\", async () => {\n            expect(await evaluate(\"type [1,2,3]\")).to.equal(\"List\");\n        });\n\n        it(\"should return 'Namespace' if `X` is a namespace\", async () => {\n            expect(await evaluate(\"type {x:1}\")).to.equal(\"Namespace\");\n        });\n\n        it(\"should return 'Function' if `X` is a function\", async () => {\n            expect(await evaluate(\"type(()->())\")).to.equal(\"Function\");\n        });\n\n        it(\"should return a tuple of types if `X` is a tuple\", async () => {\n            expect(await evaluate(\"type(TRUE,1,'abc')\")).to.be.Tuple(['Boolean', 'Number', 'String']);\n            \n            // it should not complain fi a tuple item is Undefined\n            var presets = {un: new Undefined()}\n            expect(await evaluate(\"type(TRUE,un,'abc')\", presets)).to.be.Tuple(['Boolean', 'Undefined', 'String']);\n        });\n    });\n\n    describe(\"size X\", () => {\n\n        it(\"should return the length of X if X is a string\", async () => {\n            var size = await evaluate(\"size 'abc'\");\n            expect(size).to.equal(3);\n        });\n\n        it(\"should return the length of X if X is a list\", async () => {\n            var size = await evaluate(\"size [1,2,3]\");\n            expect(size).to.equal(3);\n        });\n\n        it(\"should return the number of own names if X is a namespace\", async () => {\n            var size = await evaluate(\"size {a=1,b=2,c=3}\");\n            expect(size).to.equal(3);\n\n            var ctx = {o: Object.assign(Object.create({x:1,y:2,a:10}), {a:1,b:2,c:3,$d:4})};\n            var size = await evaluate(\"size o\", ctx);\n            expect(size).to.equal(5);\n        });\n        \n        it(\"should return Undefined if X is of any other type\", async () => {\n            expect(await evaluate(\"size TRUE\")).to.be.Undefined('size', true);\n            expect(await evaluate(\"size 1\")).to.be.Undefined('size', 1);\n            \n            var presets = {un: new Undefined(), fn: x=>2*x};\n            expect(await evaluate(\"size fn\", presets)).to.be.Undefined('size', presets.fn);\n            expect(await evaluate(\"size un\", presets)).to.be.Undefined('size', presets.un);\n        });\n        \n        it(\"should return a tuple containing the size of each item if X is a tuple\", async () => {\n            expect(await evaluate(\"size('abc', [1,2,3,4], {a:1})\")).to.be.Tuple([3,4,1]);\n            expect(await evaluate(\"size()\")).to.be.null;\n            \n            // it should not complain fi a tuple item is Undefined\n            var presets = {un: new Undefined};\n            var size = await evaluate(\"size('abc', un, 10)\", presets);\n            expect(size).to.be.instanceof(Tuple);\n            expect(Array.from(size)[0]).to.equal(3);\n            expect(Array.from(size)[1]).to.be.Undefined('size', presets.un);\n            expect(Array.from(size)[2]).to.be.Undefined('size', 10);\n        });\n    });\n    \n    \n    // UNARY OPERATORS\n    \n    describe(\"+X\", () => {\n        \n        it(\"should return X\", async () => {\n            for (let operand of [true, false, \"abc\", [1,2,3], {x:1}, x=>x, new Undefined(), Tuple(1,2,3), null]) {\n                expect(await evaluate(\"+operand\", {operand})).to.equal(operand);\n            }\n        });\n    });\n    \n    describe(\"-X\", () => {\n        \n        it(\"should return -1*X if X is a number\", async () => {\n            expect(await evaluate(\"-3\")).to.equal(-3);\n            expect(await evaluate(\"-x\", {x:10})).to.equal(-10);\n        });\n        \n        it(\"should return Undefined if X is not a number\", async () => {\n            for (let operand of [true, false, \"abc\", [1,2,3], {x:1}, x=>x, new Undefined()]) {\n                expect(await evaluate(\"-operand\", {operand})).to.be.Undefined('negation', operand, new Position(\"-operand\", 0));\n            }\n        });\n        \n        it(\"should apply the operator to each item of X if X is a Tuple\", async () => {\n            var tuple = await evaluate(\"-(3, x, s)\", {x:-10, s:'abc'});\n            expect(tuple).to.be.instanceof(Tuple);\n            expect(Array.from(tuple)[0]).to.equal(-3);\n            expect(Array.from(tuple)[1]).to.equal(10);\n            expect(Array.from(tuple)[2]).to.be.Undefined('negation', \"abc\", new Position(\"-(3, x, s)\", 0));\n        });\n    });\n\n\n    // LOGIC OPERATORS\n\n    describe(\"X | Y\", () => {\n\n        it(\"should return X if `bool X` is true\", async () => {\n\n            // true or true\n            expect(await evaluate(\"TRUE | TRUE\")).to.equal(true);\n            expect(await evaluate(\"TRUE | 10\")).to.equal(true);\n            expect(await evaluate(\"10 | TTRUE\")).to.equal(10);\n            expect(await evaluate(\"10 | 10\")).to.equal(10);\n\n            // true or false\n            expect(await evaluate(\"TRUE | FALSE\")).to.equal(true);\n            expect(await evaluate(\"TRUE | 0\")).to.equal(true);\n            expect(await evaluate(\"10 | FALSE\")).to.equal(10);\n            expect(await evaluate(\"10 | 0\")).to.equal(10);\n            \n            // true or Undefined\n            var presets = {un: new Undefined()};\n            expect(await evaluate(\"TRUE | un\", presets)).to.equal(true);\n            expect(await evaluate(\"10 | un\", presets)).to.equal(10);\n        })\n        \n        it(\"should return Y if `bool X` is false\", async () => {\n\n            // false or true\n            expect(await evaluate(\"FALSE | TRUE\")).to.equal(true);\n            expect(await evaluate(\"FALSE | 10\")).to.equal(10);\n            expect(await evaluate(\"0 | TRUE\")).to.equal(true);\n            expect(await evaluate(\"0 | 10\")).to.equal(10);\n\n            // false or false\n            expect(await evaluate(\"FALSE | FALSE\")).to.equal(false);\n            expect(await evaluate(\"FALSE | 0\")).to.equal(0);\n            expect(await evaluate(\"0 | FALSE\")).to.equal(false);\n            expect(await evaluate(\"0 | 0\")).to.equal(0);\n            \n            // false or Undefined\n            var presets = {un: new Undefined()};\n            expect(await evaluate(\"FALSE | un\", presets)).to.equal(presets.un);\n            expect(await evaluate(\"0 | un\", presets)).to.equal(presets.un);\n        })\n\n        it(\"should return bool(X) if it is Undefined\", async () => {\n            var presets = {\n                un1: new Undefined(\"Test exception 1\"),\n                un2: new Undefined(\"Test exception 2\"),\n            };\n            expect(await evaluate(\"un1 | 1\", presets)).to.be.Undefined('booleanization', presets.un1);\n            expect(await evaluate(\"un1 | un2\", presets)).to.be.Undefined('booleanization', presets.un1);\n        });\n    });\n\n    describe(\"X & Y\", () => {\n\n        it(\"should return Y if `bool X` is true\", async () => {\n\n            // true or true\n            expect(await evaluate(\"TRUE & TRUE\")).to.equal(true);\n            expect(await evaluate(\"TRUE & 10\")).to.equal(10);\n            expect(await evaluate(\"10 & TRUE\")).to.equal(true);\n            expect(await evaluate(\"10 & 10\")).to.equal(10);\n\n            // true or false\n            expect(await evaluate(\"TRUE & FALSE\")).to.equal(false);\n            expect(await evaluate(\"TRUE & 0\")).to.equal(0);\n            expect(await evaluate(\"10 & FALSE\")).to.equal(false);\n            expect(await evaluate(\"10 & 0\")).to.equal(0);\n\n            // true and Undefined\n            var presets = {un: new Undefined(\"Test exception\")};\n            expect(await evaluate(\"TRUE & un\", presets)).to.equal(presets.un);\n            expect(await evaluate(\"1 & un\", presets)).to.equal(presets.un);\n        });\n        \n        it(\"should return X if `bool X` is false\", async () => {\n\n            // false or true\n            expect(await evaluate(\"FALSE & TRUE\")).to.equal(false);\n            expect(await evaluate(\"FALSE & 10\")).to.equal(false);\n            expect(await evaluate(\"0 & TRUE\")).to.equal(0);\n            expect(await evaluate(\"0 & 10\")).to.equal(0);\n\n            // false or false\n            expect(await evaluate(\"FALSE & FALSE\")).to.equal(false);\n            expect(await evaluate(\"FALSE & 0\")).to.equal(false);\n            expect(await evaluate(\"0 & FALSE\")).to.equal(0);\n            expect(await evaluate(\"0 & 0\")).to.equal(0);\n            \n            // false or Undefined\n            var presets = {un: new Undefined(\"Test exception\")};\n            expect(await evaluate(\"FALSE & un\", presets)).to.equal(false);            \n            expect(await evaluate(\"0 & un\", presets)).to.equal(0);            \n        });\n        \n        it(\"should return bool(X) if it is Undefined\", async () => {\n            var presets = {\n                un1: new Undefined(\"Test exception 1\"),\n                un2: new Undefined(\"Test exception 2\"),\n            };\n            expect(await evaluate(\"un1 & 1\", presets)).to.be.Undefined('booleanization', presets.un1);\n            expect(await evaluate(\"un1 & un2\", presets)).to.be.Undefined('booleanization', presets.un1);\n        });\n    });\n\n    describe(\"X ? Y\", () => {\n\n        it(\"should return Y is `bool X` is true\", async () => {\n            expect(await evaluate(\"TRUE ? [1,2,3]\")).to.deep.equal([1,2,3]);\n            expect(await evaluate(\"10 ? [1,2,3]\")).to.deep.equal([1,2,3]);\n            \n            // true ? Undefined\n            var presets = {un: new Undefined()};\n            expect(await evaluate(\"TRUE ? un\", presets)).to.equal(presets.un);\n            expect(await evaluate(\"1 ? un\", presets)).to.equal(presets.un);            \n        });\n\n        it(\"should return null if `bool X` is false\", async () => {\n            expect(await evaluate(\"FALSE ? [1,2,3]\")).to.be.null;\n            expect(await evaluate(\"0 ? [1,2,3]\")).to.be.null;\n\n            // false ? Undefined\n            var presets = {un: new Undefined()};\n            expect(await evaluate(\"FALSE ? un\", presets)).to.equal(null);\n            expect(await evaluate(\"0 ? un\", presets)).to.equal(null);            \n        });\n        \n        it(\"should return `bool(X)` if it is Undefined\", async () => {\n            var presets = {\n                un1: new Undefined(\"Test exception 1\"),\n                un2: new Undefined(\"Test exception 2\"),\n            };\n            expect(await evaluate(\"un1 ? 1\", presets)).to.be.Undefined('booleanization', presets.un1);\n            expect(await evaluate(\"un1 ? un2\", presets)).to.be.Undefined('booleanization', presets.un1);\n        });\n    });\n\n    describe(\"X ; Y\", () => {\n\n        it(\"should return X if it is not `null`\", async () => {\n            expect(await evaluate(\"[1,2,3] ; [3,4,5]\")).to.deep.equal([1,2,3]);\n            \n            var presets = {un: new Undefined()};\n            expect(await evaluate(\"10 ; un\", presets)).to.equal(10);\n            expect(await evaluate(\"un ; 10\", presets)).to.equal(presets.un);\n        });\n\n        it(\"should return Y if X is `null`\", async () => {\n            expect(await evaluate(\"() ; [3,4,5]\")).to.deep.equal([3,4,5]);\n\n            var presets = {un: new Undefined()};\n            expect(await evaluate(\"() ; un\", presets)).to.equal(presets.un);\n        });\n    });\n\n\n    // ARITHMETIC OPERATORS\n\n    describe(\"X + Y\", () => {\n\n        it(\"should return Y if X is nothing\", async () => {\n            var presets = {fn:()=>{}, ls:[1,2,3], ns:{a:1,b:2,c:3}, T:true, F:false,\n                    un: new Undefined()};\n            expect(await evaluate(\"() + ()\", presets)).to.equal(null);\n            expect(await evaluate(\"() + T\", presets)).to.equal(true);\n            expect(await evaluate(\"() + F\", presets)).to.equal(false);\n            expect(await evaluate(\"() + 10\", presets)).to.equal(10);\n            expect(await evaluate(\"() + 'abc'\", presets)).to.equal(\"abc\");\n            expect(await evaluate(\"() + fn\", presets)).to.equal(presets.fn);\n            expect(await evaluate(\"() + ls\", presets)).to.deep.equal([1,2,3]);\n            expect(await evaluate(\"() + ns\", presets)).to.deep.equal({a:1,b:2,c:3});\n            expect(await evaluate(\"() + un\", presets)).to.deep.equal(presets.un);\n\n            var tuple = await evaluate(\"() + (1,2,3)\", presets);\n            expect(tuple instanceof Tuple).to.be.true;\n            expect(Array.from(tuple)).to.deep.equal([1,2,3]);\n        });\n\n        it(\"should return X if Y is nothing\", async () => {\n            var presets = {fn:()=>{}, ls:[1,2,3], ns:{a:1,b:2,c:3}, T:true, F:false,\n                    un: new Undefined()};\n            expect(await evaluate(\"() + ()\", presets)).to.equal(null);\n            expect(await evaluate(\"T + ()\", presets)).to.equal(true);\n            expect(await evaluate(\"F + ()\", presets)).to.equal(false);\n            expect(await evaluate(\"10 + ()\", presets)).to.equal(10);\n            expect(await evaluate(\"'abc' + ()\", presets)).to.equal(\"abc\");\n            expect(await evaluate(\"fn + ()\", presets)).to.equal(presets.fn);\n            expect(await evaluate(\"ls + ()\", presets)).to.deep.equal([1,2,3]);\n            expect(await evaluate(\"ns + ()\", presets)).to.deep.equal({a:1,b:2,c:3});\n            expect(await evaluate(\"un + ()\", presets)).to.deep.equal(presets.un);\n\n            var tuple = await evaluate(\"(1,2,3) + ()\", presets);\n            expect(tuple instanceof Tuple).to.be.true;\n            expect(Array.from(tuple)).to.deep.equal([1,2,3]);\n        });\n\n        it(\"should return `X||Y` if both X and Y are booleans\", async () => {\n            var presets = {T:true, F:false};\n            expect(await evaluate(\"T + T\", presets)).to.be.true;\n            expect(await evaluate(\"T + F\", presets)).to.be.true;\n            expect(await evaluate(\"F + T\", presets)).to.be.true;\n            expect(await evaluate(\"F + F\", presets)).to.be.false;\n        });\n\n        it(\"should return `X+Y` if both X and Y are numbers\", async () => {\n            expect(await evaluate(\"10 + 1\")).to.equal(11);\n            expect(await evaluate(\"10 + 0\")).to.equal(10);\n            expect(await evaluate(\"10 + (-2)\")).to.equal(8);\n        });\n\n        it(\"should concatenate X and Y if they are both strings\", async () => {\n            expect(await evaluate(\"'abc' + 'def'\")).to.equal(\"abcdef\");\n            expect(await evaluate(\"'abc' + ''\")).to.equal(\"abc\");\n            expect(await evaluate(\"'' + 'def'\")).to.equal(\"def\");\n        });\n\n        it(\"should concatenate X and Y if they are both lists\", async () => {\n            expect(await evaluate(\"[1,2,3] + [4,5,6]\")).to.deep.equal([1,2,3,4,5,6]);\n            expect(await evaluate(\"[1,2,3] + []\")).to.deep.equal([1,2,3]);\n            expect(await evaluate(\"[] + [4,5,6]\")).to.deep.equal([4,5,6]);\n        });\n\n        it(\"should merge X and Y if they are both namespaces\", async () => {\n            expect(await evaluate(\"{a=1,b=2} + {b=20,c=30}\")).to.deep.equal({a:1,b:20,c:30});\n            expect(await evaluate(\"{a=1,b=2} + {}\")).to.deep.equal({a:1,b:2});\n            expect(await evaluate(\"{} + {b=20,c=30}\")).to.deep.equal({b:20,c:30});\n            \n            var presets = {\n                ns1: {a:1, un: new Undefined()},\n                ns2: {b:2, un: new Undefined()},\n            }\n            expect(await evaluate(\"ns1 + ns2\", presets)).to.deep.equal({a:1, b:2, un:presets.ns2.un});\n        });\n\n        it(\"should return Undefined for all the other type combinations\", async () => {\n            var T=true, F=false, n=10, s=\"abc\", ls=[1,2,3], ns={a:1}, fn=x=>x, u=new Undefined();\n            for (let [L,R] of [\n                    [T,n], [T,s], [T,ls], [T,ns], [T,fn], [T,u],\n                    [F,n], [F,s], [F,ls], [F,ns], [F,fn], [F, u],\n                    [n,T], [n,F], [n,s], [n,ls], [n,ns], [n,fn], [n,u],\n                    [s,T], [s,F], [s,n], [s,ls], [s,ns], [s,fn], [s,u],\n                    [ls,T], [ls,F], [ls,n], [ls,s], [ls,ns], [ls,fn], [ls,u],\n                    [ns,T], [ns,F], [ns,n], [ns,s], [ns,ls], [ns,fn], [ns,u],\n                    [fn,T], [fn,F], [fn,n], [fn,s], [fn,ls], [fn,ns], [fn,u],\n                    [u,T], [u,F], [u,n], [u,s], [u,ls], [u,ns], [u,fn], [u,u] ]) {\n                \n                var LType = context.type(L);\n                var RType = context.type(R);\n                expect(await evaluate(\"L + R\", {L,R})).to.be.Undefined('sum', L, R, new Position(\"L + R\", 2));\n            }\n        });\n        \n        it(\"should return (x1+y1, x2+y2, ...) if X and/or Y is a tuple\", async () => {\n            var presets = {T:true, F:false};\n            expect(Array.from(await evaluate(\"(T, 1, 'a', [1], {a=1}) + (F, 2, 'b', [2], {b=2})\", presets))).to.deep.equal([true, 3, \"ab\", [1,2], {a:1,b:2}])\n            expect(Array.from(await evaluate(\"(T, 1, 'a', [1], {a=1}) + (F, 2, 'b')\", presets))).to.deep.equal([true, 3, \"ab\", [1], {a:1}])\n            expect(Array.from(await evaluate(\"(T, 1, 'a') + (F, 2, 'b', [2], {b=2})\", presets))).to.deep.equal([true, 3, \"ab\", [2], {b:2}])\n            expect(Array.from(await evaluate(\"10 + (1, 2, 3)\", presets))).to.deep.equal([11, 2, 3])\n            expect(Array.from(await evaluate(\"(1, 2, 3) + 10\", presets))).to.deep.equal([11, 2, 3])\n                        \n            // partial exception\n            var source = \"(10,20,30) + (1,2,[])\";\n            var tuple = await evaluate(source);\n            expect(tuple).to.be.instanceof(Tuple);\n            expect(Array.from(tuple)[0]).to.equal(11);\n            expect(Array.from(tuple)[1]).to.equal(22);\n            expect(Array.from(tuple)[2]).to.be.Undefined('sum', 30, [], new Position(source, 11));\n        });\n    });\n\n    describe(\"X - Y\", () => {\n\n        it(\"should return X if Y is nothing\", async () => {\n            var presets = {fn:()=>{}, ls:[1,2,3], ns:{a:1,b:2,c:3}, T:true, F:false};\n            expect(await evaluate(\"() - ()\", presets)).to.equal(null);\n            expect(await evaluate(\"T - ()\", presets)).to.equal(true);\n            expect(await evaluate(\"F - ()\", presets)).to.equal(false);\n            expect(await evaluate(\"10 - ()\", presets)).to.equal(10);\n            expect(await evaluate(\"'abc' - ()\", presets)).to.equal(\"abc\");\n            expect(await evaluate(\"fn - ()\", presets)).to.equal(presets.fn);\n            expect(await evaluate(\"ls - ()\", presets)).to.deep.equal(presets.ls);\n            expect(await evaluate(\"ns - ()\", presets)).to.deep.equal(presets.ns);\n            expect(Array.from(await evaluate(\"(1,2,3) - ()\", presets))).to.deep.equal([1,2,3]);\n        });\n\n        it(\"should return Undefined if X is nothing\", async () => {\n            for (let R of [true, false, 10, 'abc', [1,2,3], {a:1}, x=>x]) {\n                var RType = context.type(R);\n                expect(await evaluate(\"() - R\", {R})).to.be.Undefined('subtraction', R, new Position(\"() - R\", 3));\n            }\n        });\n        \n        it(\"should return `X-Y` if both X and Y are numbers\", async () => {\n            var presets = {T:true, F:false};\n            expect(await evaluate(\"10 - 1\", presets)).to.equal(9);\n            expect(await evaluate(\"20 - 0\", presets)).to.equal(20);\n            expect(await evaluate(\"10 - (-7)\", presets)).to.equal(17);\n        });\n\n        it(\"should return Undefined for all the other type combinations\", async () => {\n            var T=true, F=false, n=10, s=\"abc\", ls=[1,2,3], ns={a:1}, fn=x=>x, u=new Undefined();\n            for (let [L,R] of [\n                    [T,n], [T,s], [T,ls], [T,ns], [T,fn], [T,u],\n                    [F,n], [F,s], [F,ls], [F,ns], [F,fn], [F,u],\n                    [n,T], [n,F], [n,s], [n,ls], [n,ns], [n,fn], [n,u],\n                    [s,T], [s,F], [s,n], [s,ls], [s,ns], [s,fn], [s,u],\n                    [ls,T], [ls,F], [ls,n], [ls,s], [ls,ns], [ls,fn], [ls,u],\n                    [ns,T], [ns,F], [ns,n], [ns,s], [ns,ls], [ns,fn], [ns,u],\n                    [fn,T], [fn,F], [fn,n], [fn,s], [fn,ls], [fn,ns], [fn,u],\n                    [u,T], [u,F], [u,n], [u,s], [u,ls], [u,ns], [u,fn], [u,u] ]) {\n                \n                var LType = context.type(L);\n                var RType = context.type(R);\n                expect(await evaluate(\"L - R\", {L,R})).to.be.Undefined('subtraction', L, R, new Position(\"L - R\", 2));\n            }            \n        });\n\n        it(\"should return (x1-y1, x2-y2, ...) if X and/or Y is a tuple\", async () => {\n            var presets = {};\n            expect(Array.from(await evaluate(\"(10,20,30) - (1,2,3)\", presets))).to.deep.equal([9,18,27]);\n            expect(Array.from(await evaluate(\"(10,20,30) - (1,2)\", presets))).to.deep.equal([9,18,30]);\n            expect(Array.from(await evaluate(\"(10,20,30) - 1\", presets))).to.deep.equal([9,20,30]);\n\n            // partial exception\n            var source = \"(10,20,30) - (1,2,[])\";\n            var tuple = await evaluate(source);\n            expect(tuple).to.be.instanceof(Tuple);\n            expect(Array.from(tuple)[0]).to.equal(9);\n            expect(Array.from(tuple)[1]).to.equal(18);\n            expect(Array.from(tuple)[2]).to.be.Undefined('subtraction', 30, [], new Position(source, 11));\n        });\n    });\n\n    describe(\"X * Y\", () => {\n\n        it(\"should return () if either X or Y is nothing\", async () => {\n            var presets = {fn:()=>{}, ls:[1,2,3], ns:{a:1,b:2,c:3}, T:true, F:false,\n                    un: new Undefined()};\n\n            expect(await evaluate(\"() * ()\", presets)).to.equal(null);\n            expect(await evaluate(\"() * T\", presets)).to.equal(null);\n            expect(await evaluate(\"() * F\", presets)).to.equal(null);\n            expect(await evaluate(\"() * 10\", presets)).to.equal(null);\n            expect(await evaluate(\"() * 'abc'\", presets)).to.equal(null);\n            expect(await evaluate(\"() * fn\", presets)).to.equal(null);\n            expect(await evaluate(\"() * ls\", presets)).to.equal(null);\n            expect(await evaluate(\"() * ns\", presets)).to.equal(null);\n            expect(await evaluate(\"() * (1,2,3)\", presets)).to.equal(null);\n            expect(await evaluate(\"() * un\", presets)).to.equal(null);\n\n            expect(await evaluate(\"() * ()\", presets)).to.equal(null);\n            expect(await evaluate(\"T * ()\", presets)).to.equal(null);\n            expect(await evaluate(\"F * ()\", presets)).to.equal(null);\n            expect(await evaluate(\"10 * ()\", presets)).to.equal(null);\n            expect(await evaluate(\"'abc' * ()\", presets)).to.equal(null);\n            expect(await evaluate(\"fn * ()\", presets)).to.equal(null);\n            expect(await evaluate(\"ls * ()\", presets)).to.equal(null);\n            expect(await evaluate(\"ns * ()\", presets)).to.equal(null);\n            expect(await evaluate(\"(1,2,3) * ()\", presets)).to.equal(null);\n            expect(await evaluate(\"un * ()\", presets)).to.equal(null);\n        });\n        \n        it(\"should return `X&&Y` if both X and Y are booleans\", async () => {\n            var presets = {T:true, F:false};\n            expect(await evaluate(\"T * T\", presets)).to.equal(true);\n            expect(await evaluate(\"T * F\", presets)).to.equal(false);\n            expect(await evaluate(\"F * T\", presets)).to.equal(false);\n            expect(await evaluate(\"F * F\", presets)).to.equal(false);\n        });\n\n        it(\"should return `X*Y` if both X and Y are numbers\", async () => {\n            expect(await evaluate(\"10 * 2\")).to.equal(20);\n            expect(await evaluate(\"10 * 0\")).to.equal(0);\n            expect(await evaluate(\"10 * (-2)\")).to.equal(-20);\n        });\n\n        it(\"should concatenate X times Y if X is a number and Y is a string\", async () => {\n            expect(await evaluate(\"3 * 'Abc'\")).to.equal(\"AbcAbcAbc\");\n            expect(await evaluate(\"3.1 * 'Abc'\")).to.equal(\"AbcAbcAbc\");\n            expect(await evaluate(\"3.9 * 'Abc'\")).to.equal(\"AbcAbcAbc\");\n            expect(await evaluate(\"0 * 'Abc'\")).to.equal(\"\");\n            expect(await evaluate(\"-2 * 'Abc'\")).to.equal(\"\");\n        });\n\n        it(\"should concatenate Y times X if Y is a number and X is a string\", async () => {\n            expect(await evaluate(\"'Abc' * 3\")).to.equal(\"AbcAbcAbc\");\n            expect(await evaluate(\"'Abc' * 3.1\")).to.equal(\"AbcAbcAbc\");\n            expect(await evaluate(\"'Abc' * 3.9\")).to.equal(\"AbcAbcAbc\");\n            expect(await evaluate(\"'Abc' * 0\")).to.equal(\"\");\n            expect(await evaluate(\"'Abc' * (-2)\")).to.equal(\"\");\n        });\n\n        it(\"should concatenate X times Y if X is a number and Y is a list\", async () => {\n            expect(await evaluate(\"3 * [1,2,3]\")).to.deep.equal([1,2,3,1,2,3,1,2,3]);\n            expect(await evaluate(\"3.1 * [1,2,3]\")).to.deep.equal([1,2,3,1,2,3,1,2,3]);\n            expect(await evaluate(\"3.9 * [1,2,3]\")).to.deep.equal([1,2,3,1,2,3,1,2,3]);\n            expect(await evaluate(\"0 * [1,2,3]\")).to.deep.equal([]);\n            expect(await evaluate(\"-2 * [1,2,3]\")).to.deep.equal([]);\n        });\n\n        it(\"should concatenate Y times X if Y is a number and X is a list\", async () => {\n            expect(await evaluate(\"[1,2,3] * 3\")).to.deep.equal([1,2,3,1,2,3,1,2,3]);\n            expect(await evaluate(\"[1,2,3] * 3.1\")).to.deep.equal([1,2,3,1,2,3,1,2,3]);\n            expect(await evaluate(\"[1,2,3] * 3.9\")).to.deep.equal([1,2,3,1,2,3,1,2,3]);\n            expect(await evaluate(\"[1,2,3] * 0\")).to.deep.equal([]);\n            expect(await evaluate(\"[1,2,3] * (-2)\")).to.deep.equal([]);\n        });\n\n        it(\"should return Undefined for all the other type combinations\", async () => {\n            var T=true, F=false, n=10, s=\"abc\", ls=[1,2,3], ns={a:1}, fn=x=>x, u=new Undefined();\n            for (let [L,R] of [\n                    [T,n], [T,s], [T,ls], [T,ns], [T,fn], [T,u],\n                    [F,n], [F,s], [F,ls], [F,ns], [F,fn], [F,u],\n                    [n,T], [n,F], [n,ns], [n,fn], [n,u],\n                    [s,T], [s,F], [s,ls], [s,ns], [s,fn], [s,u],\n                    [ls,T], [ls,F], [ls,s], [ls,ns], [ls,fn], [ls,u],\n                    [ns,T], [ns,F], [ns,n], [ns,s], [ns,ls], [ns,fn], [ns,u],\n                    [fn,T], [fn,F], [fn,n], [fn,s], [fn,ls], [fn,ns], [fn,u],\n                    [u,T], [u,F], [u,n], [u,s], [u,ls], [u,ns], [u,fn], [u,u] ]) {\n                \n                var LType = context.type(L);\n                var RType = context.type(R);\n                expect(await evaluate(\"L * R\", {L,R})).to.be.Undefined('product', L, R, new Position(\"L * R\", 2));\n            }                        \n        });\n \n        it(\"should return (x1*y1, x2*y2, ...) if X and/or Y is a tuple\", async () => {\n            var presets = {T:true, F:false};\n            expect(Array.from(await evaluate(\"(T, 3, 'a', [1]) * (F, 2, 2, 2)\",presets))).to.deep.equal([false, 6, \"aa\", [1,1]]);\n            expect(Array.from(await evaluate(\"(10,20,30) * (2,3,4)\",presets))).to.deep.equal([20,60,120]);\n            expect(Array.from(await evaluate(\"(10,20,30) * (2,3)\",presets))).to.deep.equal([20,60]);\n            expect(Array.from(await evaluate(\"(10,20) * (2,3,4)\",presets))).to.deep.equal([20,60]);\n            expect(await evaluate(\"10 * (2,3,4)\",presets)).to.equal(20);\n            expect(await evaluate(\"(10,20,30) * 2\",presets)).to.equal(20);\n            \n            // partial exception\n            var source = \"(10,20,30) * (1,2,{})\";\n            var tuple = await evaluate(source);\n            expect(tuple).to.be.instanceof(Tuple);\n            expect(Array.from(tuple)[0]).to.equal(10);\n            expect(Array.from(tuple)[1]).to.equal(40);\n            expect(Array.from(tuple)[2]).to.be.Undefined('product', 30, {}, new Position(source, 11));\n        });\n    });\n\n    describe(\"X / Y\", () => {\n\n        it(\"should return nothing if X is nothing\", async () => {\n            var presets = {fn:()=>{}, ls:[1,2,3], ns:{a:1,b:2,c:3}, T:true, F:false};\n            expect(await evaluate(\"() / ()\", presets)).to.equal(null);\n            expect(await evaluate(\"() / T\", presets)).to.equal(null);\n            expect(await evaluate(\"() / F\", presets)).to.equal(null);\n            expect(await evaluate(\"() / 10\", presets)).to.equal(null);\n            expect(await evaluate(\"() / 'abc'\", presets)).to.equal(null);\n            expect(await evaluate(\"() / fn\", presets)).to.equal(null);\n            expect(await evaluate(\"() / ls\", presets)).to.equal(null);\n            expect(await evaluate(\"() / ns\", presets)).to.equal(null);\n        });\n        \n        it(\"should return Undefined if Y is NOTHING\", async () => {\n            for (let L of [true, false, 10, 'abc', [1,2,3], {x:1}, x=>x]) {\n                var LType = context.type(L);\n                expect(await evaluate(\"L / ()\", {L})).to.be.Undefined('division', L, new Position(\"L / ()\", 2));\n            }\n        });\n\n        it(\"should return `X/Y` if both X and Y are numbers\", async () => {\n            expect(await evaluate(\"10 / 2\")).to.equal(5);\n            expect(await evaluate(\"20 / 0\")).to.equal(Infinity);\n            expect(await evaluate(\"10 / (-2)\")).to.equal(-5);\n        });\n\n        it(\"should return Undefined for all the other type combinations\", async () => {\n            var T=true, F=false, n=10, s=\"abc\", ls=[1,2,3], ns={a:1}, fn=x=>x, u=new Undefined();\n            for (let [L,R] of [\n                    [T,n], [T,s], [T,ls], [T,ns], [T,fn], [T,u],\n                    [F,n], [F,s], [F,ls], [F,ns], [F,fn], [F,u],\n                    [n,T], [n,F], [n,s], [n,ns], [n,fn], [n,u],\n                    [s,T], [s,F], [s,n], [s,ls], [s,ns], [s,fn], [s,u],\n                    [ls,T], [ls,F], [ls,n], [ls,s], [ls,ns], [ls,fn], [ls,u],\n                    [ns,T], [ns,F], [ns,n], [ns,s], [ns,ls], [ns,fn], [ns,u],\n                    [fn,T], [fn,F], [fn,n], [fn,s], [fn,ls], [fn,ns], [fn,u],\n                    [u,T], [u,F], [u,n], [u,s], [u,ls], [u,ns], [u,fn], [u,u] ]) {\n                \n                var LType = context.type(L);\n                var RType = context.type(R);\n                expect(await evaluate(\"L / R\", {L,R})).to.be.Undefined('division', L, R, new Position(\"L / R\", 2));\n            }                        \n        });\n\n        it(\"should return (x1/y1, x2/y2, ...) if X and/or Y is a tuple\", async () => {\n            expect(Array.from(await evaluate(\"(10,20,30) / (2,5,3)\"))).to.deep.equal([5,4,10]);\n            expect(Array.from(await evaluate(\"(10,20) / (2,5,3)\"))).to.deep.equal([5,4]);\n            expect(await evaluate(\"10 / (2,5,3)\")).to.equal(5);\n            expect(await evaluate(\"() / (2,4,3)\")).to.equal(null);\n            \n            // partial exception\n            var source = \"(10,20,30) / (2,5)\";\n            var tuple = await evaluate(source);\n            expect(tuple).to.be.instanceof(Tuple);\n            expect(Array.from(tuple)[0]).to.equal(5);\n            expect(Array.from(tuple)[1]).to.equal(4);\n            expect(Array.from(tuple)[2]).to.be.Undefined('division', 30, new Position(source, 11));\n        });\n    });\n\n    describe(\"X % Y\", () => {\n\n        it(\"should return NOTHING if X is nothing\", async () => {\n            var presets = {fn:()=>{}, ls:[1,2,3], ns:{a:1,b:2,c:3}, T:true, F:false};\n            expect(await evaluate(\"() % ()\", presets)).to.equal(null);\n            expect(await evaluate(\"() % T\", presets)).to.equal(null);\n            expect(await evaluate(\"() % F\", presets)).to.equal(null);\n            expect(await evaluate(\"() % 10\", presets)).to.equal(null);\n            expect(await evaluate(\"() % 'abc'\", presets)).to.equal(null);\n            expect(await evaluate(\"() % fn\", presets)).to.equal(null);\n            expect(await evaluate(\"() % ls\", presets)).to.equal(null);\n            expect(await evaluate(\"() % ns\", presets)).to.equal(null);\n        });\n\n        it(\"should return Undefined if Y is NOTHING\", async () => {\n            for (let L of [true, false, 10, 'abc', [1,2,3], {x:1}, x=>x]) {\n                var LType = context.type(L);\n                expect(await evaluate(\"L % ()\", {L})).to.be.Undefined('modulo', L, new Position(\"L % ()\", 2));\n            }\n        });\n\n        it(\"should return `X%Y` if both X and Y are numbers\", async () => {\n            expect(await evaluate(\"10 % 4\")).to.equal(2);\n            expect(await evaluate(\"10 % (-4)\")).to.equal(2);\n        });\n\n        it(\"should return Undefined for all the other type combinations\", async () => {\n            var T=true, F=false, n=10, s=\"abc\", ls=[1,2,3], ns={a:1}, fn=x=>x, u=new Undefined();\n            for (let [L,R] of [\n                    [T,n], [T,s], [T,ls], [T,ns], [T,fn], [T,u],\n                    [F,n], [F,s], [F,ls], [F,ns], [F,fn], [F,u],\n                    [n,T], [n,F], [n,s], [n,ns], [n,fn], [n,u],\n                    [s,T], [s,F], [s,n], [s,ls], [s,ns], [s,fn], [s,u],\n                    [ls,T], [ls,F], [ls,n], [ls,s], [ls,ns], [ls,fn], [ls,u],\n                    [ns,T], [ns,F], [ns,n], [ns,s], [ns,ls], [ns,fn], [ns,u],\n                    [fn,T], [fn,F], [fn,n], [fn,s], [fn,ls], [fn,ns], [fn,u],\n                    [u,T], [u,F], [u,n], [u,s], [u,ls], [u,ns], [u,fn], [u,u] ]) {\n                \n                var LType = context.type(L);\n                var RType = context.type(R);\n                expect(await evaluate(\"L % R\", {L,R})).to.be.Undefined('modulo', L, R, new Position(\"L % R\", 2));\n            }            \n        });\n\n        it(\"should return (x1/y1, x2/y2, ...) if X and/or Y is a tuple\", async () => {\n            expect(Array.from(await evaluate(\"(10,20,30) % (4,7,8)\"))).to.deep.equal([2,6,6]);\n            expect(Array.from(await evaluate(\"(10,20) % (4,7,8)\"))).to.deep.equal([2,6]);\n            expect(await evaluate(\"10 % (4,7,8)\")).to.equal(2);\n            expect(await evaluate(\"() % (4,7,8)\")).to.equal(null);\n\n            // partial exception\n            var source = \"(10,20,30) % (3,6)\";\n            var tuple = await evaluate(source);\n            expect(tuple).to.be.instanceof(Tuple);\n            expect(Array.from(tuple)[0]).to.equal(1);\n            expect(Array.from(tuple)[1]).to.equal(2);\n            expect(Array.from(tuple)[2]).to.be.Undefined('modulo', 30, new Position(source, 11));\n        });\n    });\n\n    describe(\"X ^ Y\", () => {\n\n        it(\"should return nothing if X is nothing\", async () => {\n            var presets = {fn:()=>{}, ls:[1,2,3], ns:{a:1,b:2,c:3}, T:true, F:false};\n            expect(await evaluate(\"() ^ ()\", presets)).to.equal(null);\n            expect(await evaluate(\"() ^ T\", presets)).to.equal(null);\n            expect(await evaluate(\"() ^ F\", presets)).to.equal(null);\n            expect(await evaluate(\"() ^ 10\", presets)).to.equal(null);\n            expect(await evaluate(\"() ^ 'abc'\", presets)).to.equal(null);\n            expect(await evaluate(\"() ^ fn\", presets)).to.equal(null);\n            expect(await evaluate(\"() ^ ls\", presets)).to.equal(null);\n            expect(await evaluate(\"() ^ ns\", presets)).to.equal(null);\n        });\n\n        it(\"should return Undefined if Y is NOTHING\", async () => {\n            for (let L of [true, false, 10, 'abc', [1,2,3], {x:1}, x=>x]) {\n                var LType = context.type(L);\n                expect(await evaluate(\"L ^ ()\", {L})).to.be.Undefined('exponentiation', L, new Position(\"L ^ ()\", 2));\n            }\n        });\n\n        it(\"should return `X**Y` if both X and Y are numbers\", async () => {\n            expect(await evaluate(\"10 ^ 2\")).to.equal(100);\n            expect(await evaluate(\"20 ^ 0\")).to.equal(1);\n            expect(await evaluate(\"10 ^ (-2)\")).to.equal(0.01);\n        });\n\n        it(\"should return Undefined for all the other type combinations\", async () => {\n            var T=true, F=false, n=10, s=\"abc\", ls=[1,2,3], ns={a:1}, fn=x=>x, u=new Undefined();\n            for (let [L,R] of [\n                    [T,n], [T,s], [T,ls], [T,ns], [T,fn], [T,u],\n                    [F,n], [F,s], [F,ls], [F,ns], [F,fn], [F,u],\n                    [n,T], [n,F], [n,s], [n,ns], [n,fn], [n,u],\n                    [s,T], [s,F], [s,n], [s,ls], [s,ns], [s,fn], [s,u],\n                    [ls,T], [ls,F], [ls,n], [ls,s], [ls,ns], [ls,fn], [ls,u],\n                    [ns,T], [ns,F], [ns,n], [ns,s], [ns,ls], [ns,fn], [ns,u],\n                    [fn,T], [fn,F], [fn,n], [fn,s], [fn,ls], [fn,ns], [fn,u],\n                    [u,T], [u,F], [u,n], [u,s], [u,ls], [u,ns], [u,fn], [u,u] ]) {\n                \n                var LType = context.type(L);\n                var RType = context.type(R);\n                expect(await evaluate(\"L ^ R\", {L,R})).to.be.Undefined('exponentiation', L, R, new Position(\"L ^ R\", 2));\n            }\n        });\n\n        it(\"should return (x1^y1, x2^y2, ...) if X and/or Y is a tuple\", async () => {\n            expect(Array.from(await evaluate(\"(10,20,30) ^ (2,3,4)\"))).to.deep.equal([10**2,20**3,30**4]);\n            expect(Array.from(await evaluate(\"(10,20) ^ (2,3,4)\"))).to.deep.equal([10**2,20**3]);\n            expect(await evaluate(\"10 ^ (2,3,4)\")).to.equal(10**2);\n            expect(await evaluate(\"() ^ (2,3,4)\")).to.equal(null);\n            \n            // partial exception\n            var source = \"(2,3,4) ^ (2,3)\";\n            var tuple = await evaluate(source);\n            expect(tuple).to.be.instanceof(Tuple);\n            expect(Array.from(tuple)[0]).to.equal(4);\n            expect(Array.from(tuple)[1]).to.equal(27);\n            expect(Array.from(tuple)[2]).to.be.Undefined(\"exponentiation\", 4, new Position(source, 8));\n        });\n    });\n\n\n    // COMPARISON OPERATORS\n\n    describe(\"X == Y\", () => {\n\n        it(\"should return true if both X and Y are nothing\", async () => {\n            expect(await evaluate(\"() == ()\")).to.equal(true);\n        });\n\n        it(\"should return true if X and Y are both true or both false\", async () => {\n            var presets = {fn:()=>{}, ls:[1,2,3], ns:{a:1,b:2,c:3}, T:true, F:false};\n            expect(await evaluate(\"T == T\", presets)).to.equal(true);\n            expect(await evaluate(\"F == F\", presets)).to.equal(true);\n            expect(await evaluate(\"T == F\", presets)).to.equal(false);\n            expect(await evaluate(\"F == T\", presets)).to.equal(false);\n        });\n\n        it(\"should return true if X and Y are the same number\", async () => {\n            var presets = {fn:()=>{}, ls:[1,2,3], ns:{a:1,b:2,c:3}, T:true, F:false};\n            expect(await evaluate(\"3 == 3\", presets)).to.equal(true);\n            expect(await evaluate(\"0 == 0\", presets)).to.equal(true);\n            expect(await evaluate(\"-3 == -3\", presets)).to.equal(true);\n            expect(await evaluate(\"3 == 2\", presets)).to.equal(false);\n            expect(await evaluate(\"0 == -4\", presets)).to.equal(false);\n        });\n\n        it(\"should return true if X and Y are the same string\", async () => {\n            var presets = {fn:()=>{}, ls:[1,2,3], ns:{a:1,b:2,c:3}, T:true, F:false};\n            expect(await evaluate(\"'abc' == 'abc'\", presets)).to.equal(true);\n            expect(await evaluate(\"'' == ''\", presets)).to.equal(true);\n            expect(await evaluate(\"'abc' == 'def'\", presets)).to.equal(false);\n            expect(await evaluate(\"'abc' == ''\", presets)).to.equal(false);\n        });\n\n        it(\"should return true if X and Y are both lists with equal items\", async () => {\n            var presets = {fn:()=>{}, ls:[1,2,3], ns:{a:1,b:2,c:3}, T:true, F:false};\n            expect(await evaluate(\"[1,2,3] == [1,2,3]\", presets)).to.equal(true);\n            expect(await evaluate(\"[] == []\", presets)).to.equal(true);\n            expect(await evaluate(\"[1,2,3] == [4,5,6]\", presets)).to.equal(false);\n            expect(await evaluate(\"[1,2,3] == []\", presets)).to.equal(false);\n        });\n\n        it(\"should return true if X and Y are both namespace with sname name:value pairs\", async () => {\n            var presets = {fn:()=>{}, ls:[1,2,3], ns:{a:1,b:2,c:3}, T:true, F:false};\n            expect(await evaluate(\"{a=1,b=2} == {a=1,b=2}\", presets)).to.equal(true);\n            expect(await evaluate(\"{} == {}\", presets)).to.equal(true);\n            expect(await evaluate(\"{a=1,b=2} == {a=1,c=2}\", presets)).to.equal(false);\n            expect(await evaluate(\"{a=1,b=2} == {a=1,b=3}\", presets)).to.equal(false);\n            expect(await evaluate(\"{a=1,b=2} == {a=1}\", presets)).to.equal(false);\n            expect(await evaluate(\"{a=1,b=2} == {}\", presets)).to.equal(false);\n            expect(await evaluate(\"{a=1} == {a=1,b=2}\", presets)).to.equal(false);\n            expect(await evaluate(\"{} == {a=1,b=2}\", presets)).to.equal(false);\n            \n            const ns1 = {x:10};\n            presets.ns2 = Object.assign(Object.create(ns1), {y:20});\n            expect(await evaluate(\"ns2 == {x:10,y:20}\", presets)).to.equal(true);\n        });\n\n        it(\"should return true if X and Y are the same function\", async () => {\n            var presets = {fn1:x=>2*x, fn2:x=>2*x};\n            expect(await evaluate(\"fn1 == fn1\", presets)).to.equal(true);\n            expect(await evaluate(\"fn1 == fn2\", presets)).to.equal(false);\n            expect(await evaluate(\"(x->2*x) == (x->2*x)\", presets)).to.equal(false);\n            expect(await evaluate(\"(x->2*x) == fn1\", presets)).to.equal(false);\n            expect(await evaluate(\"fn1 == (x->2*x)\", presets)).to.equal(false);\n        });\n\n        it(\"should return true if X and Y are the same Undefined object\", async () => {\n            var presets = {un1: new Undefined(), un2: new Undefined};\n            expect(await evaluate(\"un1 == un1\", presets)).to.equal(true);\n            expect(await evaluate(\"un1 == un2\", presets)).to.equal(false);\n        });\n\n        it(\"should return false if X and Y are of different types\", async () => {\n            var T=true, F=false, n=10, s=\"abc\", ls=[1,2,3], ns={a:1}, fn=x=>x, u=new Undefined();\n            for (let [L,R] of [\n                    [T,n], [T,s], [T,ls], [T,ns], [T,fn], [T,u],\n                    [F,n], [F,s], [F,ls], [F,ns], [F,fn], [F, u],\n                    [n,T], [n,F], [n,s], [n,ls], [n,ns], [n,fn], [n,u],\n                    [s,T], [s,F], [s,n], [s,ls], [s,ns], [s,fn], [s,u],\n                    [ls,T], [ls,F], [ls,n], [ls,s], [ls,ns], [ls,fn], [ls,u],\n                    [ns,T], [ns,F], [ns,n], [ns,s], [ns,ls], [ns,fn], [ns,u],\n                    [fn,T], [fn,F], [fn,n], [fn,s], [fn,ls], [fn,ns], [fn,u],\n                    [u,T], [u,F], [u,n], [u,s], [u,ls], [u,ns], [u,fn] ]) {\n                \n                expect(await evaluate(\"L == R\", {L,R})).to.be.false;\n            }\n        });\n\n        it(\"should compare tuples with lexicographical criteria\", async () => {\n            var presets = {fn:()=>{}, ls:[1,2,3], ns:{a:1,b:2,c:3}, T:true, F:false};\n            expect(await evaluate(\"(1,2,3) == (1,2,3)\", presets)).to.equal(true);\n            expect(await evaluate(\"(1,2,3) == (1,2)\", presets)).to.equal(false);\n            expect(await evaluate(\"(1,2) == (1,2,3)\", presets)).to.equal(false);\n            expect(await evaluate(\"1 == (1,2,3)\", presets)).to.equal(false);\n            expect(await evaluate(\"(1,2,3) == 1\", presets)).to.equal(false);\n        });\n    });\n\n    describe(\"X != Y\", () => {\n\n        it(\"should return false if both X and Y are nothing\", async () => {\n            var presets = {fn:()=>{}, ls:[1,2,3], ns:{a:1,b:2,c:3}, T:true, F:false};\n            expect(await evaluate(\"() != ()\", presets)).to.equal(false);\n        });\n\n        it(\"should return false if X and Y are both false or both true\", async () => {\n            var presets = {fn:()=>{}, ls:[1,2,3], ns:{a:1,b:2,c:3}, T:true, F:false};\n            expect(await evaluate(\"T != T\", presets)).to.equal(false);\n            expect(await evaluate(\"F != F\", presets)).to.equal(false);\n            expect(await evaluate(\"T != F\", presets)).to.equal(true);\n            expect(await evaluate(\"F != T\", presets)).to.equal(true);\n        });\n\n        it(\"should return false if X and Y are the same number\", async () => {\n            var presets = {fn:()=>{}, ls:[1,2,3], ns:{a:1,b:2,c:3}, T:true, F:false};\n            expect(await evaluate(\"3 != 3\", presets)).to.equal(false);\n            expect(await evaluate(\"0 != 0\", presets)).to.equal(false);\n            expect(await evaluate(\"-3 != -3\", presets)).to.equal(false);\n            expect(await evaluate(\"3 != 2\", presets)).to.equal(true);\n            expect(await evaluate(\"0 != -4\", presets)).to.equal(true);\n        });\n\n        it(\"should return false if X and Y are the same string\", async () => {\n            var presets = {fn:()=>{}, ls:[1,2,3], ns:{a:1,b:2,c:3}, T:true, F:false};\n            expect(await evaluate(\"'abc' != 'abc'\", presets)).to.equal(false);\n            expect(await evaluate(\"'' != ''\", presets)).to.equal(false);\n            expect(await evaluate(\"'abc' != 'def'\", presets)).to.equal(true);\n            expect(await evaluate(\"'abc' != ''\", presets)).to.equal(true);\n        });\n\n        it(\"should return false if X and Y are both lists with equal items\", async () => {\n            var presets = {fn:()=>{}, ls:[1,2,3], ns:{a:1,b:2,c:3}, T:true, F:false};\n            expect(await evaluate(\"[1,2,3] != [1,2,3]\", presets)).to.equal(false);\n            expect(await evaluate(\"[] != []\", presets)).to.equal(false);\n            expect(await evaluate(\"[1,2,3] != [4,5,6]\", presets)).to.equal(true);\n            expect(await evaluate(\"[1,2,3] != []\", presets)).to.equal(true);\n        });\n\n        it(\"should return false if X and Y are both namespace with sname name:value pairs\", async () => {\n            var presets = {fn:()=>{}, ls:[1,2,3], ns:{a:1,b:2,c:3}, T:true, F:false};\n            expect(await evaluate(\"{a=1,b=2} != {a=1,b=2}\", presets)).to.equal(false);\n            expect(await evaluate(\"{} != {}\", presets)).to.equal(false);\n            expect(await evaluate(\"{a=1,b=2} != {a=1,c=2}\", presets)).to.equal(true);\n            expect(await evaluate(\"{a=1,b=2} != {a=1,b=3}\", presets)).to.equal(true);\n            expect(await evaluate(\"{a=1,b=2} != {a=1}\", presets)).to.equal(true);\n            expect(await evaluate(\"{a=1,b=2} != {}\", presets)).to.equal(true);\n            expect(await evaluate(\"{a=1} != {a=1,b=2}\", presets)).to.equal(true);\n            expect(await evaluate(\"{} != {a=1,b=2}\", presets)).to.equal(true);\n        });\n\n        it(\"should return false if X and Y are the same function\", async () => {\n            var presets = {fn1:x=>2*x, fn2:x=>2*x};\n            expect(await evaluate(\"fn1 != fn1\", presets)).to.equal(false);\n            expect(await evaluate(\"fn1 != fn2\", presets)).to.equal(true);\n            expect(await evaluate(\"(x->2*x) != (x->2*x)\", presets)).to.equal(true);\n            expect(await evaluate(\"(x->2*x) != fn1\", presets)).to.equal(true);\n            expect(await evaluate(\"fn1 != (x->2*x)\", presets)).to.equal(true);\n        });\n\n        it(\"should return false if X and Y are the same Undefined object\", async () => {\n            var presets = {un1: new Undefined(), un2: new Undefined};\n            expect(await evaluate(\"un1 != un1\", presets)).to.equal(false);\n            expect(await evaluate(\"un1 != un2\", presets)).to.equal(true);\n        });\n\n        it(\"should return true if X and Y are of different types\", async () => {\n            var T=true, F=false, n=10, s=\"abc\", ls=[1,2,3], ns={a:1}, fn=x=>x, u=new Undefined();\n            for (let [L,R] of [\n                    [T,n], [T,s], [T,ls], [T,ns], [T,fn], [T,u],\n                    [F,n], [F,s], [F,ls], [F,ns], [F,fn], [F, u],\n                    [n,T], [n,F], [n,s], [n,ls], [n,ns], [n,fn], [n,u],\n                    [s,T], [s,F], [s,n], [s,ls], [s,ns], [s,fn], [s,u],\n                    [ls,T], [ls,F], [ls,n], [ls,s], [ls,ns], [ls,fn], [ls,u],\n                    [ns,T], [ns,F], [ns,n], [ns,s], [ns,ls], [ns,fn], [ns,u],\n                    [fn,T], [fn,F], [fn,n], [fn,s], [fn,ls], [fn,ns], [fn,u],\n                    [u,T], [u,F], [u,n], [u,s], [u,ls], [u,ns], [u,fn] ]) {\n                \n                expect(await evaluate(\"L != R\", {L,R})).to.be.true;\n            }\n        });\n\n        it(\"should compare tuples with lexicographical criteria\", async () => {\n            var presets = {fn:()=>{}, ls:[1,2,3], ns:{a:1,b:2,c:3}, T:true, F:false};\n            expect(await evaluate(\"(1,2,3) != (1,2,3)\", presets)).to.equal(false);\n            expect(await evaluate(\"(1,2,3) != (1,2)\", presets)).to.equal(true);\n            expect(await evaluate(\"(1,2) != (1,2,3)\", presets)).to.equal(true);\n            expect(await evaluate(\"1 != (1,2,3)\", presets)).to.equal(true);\n            expect(await evaluate(\"(1,2,3) != 1\", presets)).to.equal(true);\n        });\n    });\n\n    describe(\"X < Y\", () => {\n\n        it(\"should return false if both X and Y are nothing\", async () => {\n            var presets = {fn:()=>{}, ls:[1,2,3], ns:{a:1,b:2,c:3}, T:true, F:false};\n            expect(await evaluate(\"() < ()\", presets)).to.equal(false);\n        });\n\n        it(\"should return true if X is false and Y is true\", async () => {\n            var presets = {fn:()=>{}, ls:[1,2,3], ns:{a:1,b:2,c:3}, T:true, F:false};\n            expect(await evaluate(\"T < T\", presets)).to.equal(false);\n            expect(await evaluate(\"F < F\", presets)).to.equal(false);\n            expect(await evaluate(\"T < F\", presets)).to.equal(false);\n            expect(await evaluate(\"F < T\", presets)).to.equal(true);\n        });\n\n        it(\"should return true if X is a lower number than Y\", async () => {\n            var presets = {fn:()=>{}, ls:[1,2,3], ns:{a:1,b:2,c:3}, T:true, F:false};\n            expect(await evaluate(\"1 < 2\", presets)).to.equal(true);\n            expect(await evaluate(\"0 < 2\", presets)).to.equal(true);\n            expect(await evaluate(\"-1 < 2\", presets)).to.equal(true);\n            expect(await evaluate(\"2 < 1\", presets)).to.equal(false);\n            expect(await evaluate(\"2 < 0\", presets)).to.equal(false);\n            expect(await evaluate(\"2 < (-2)\", presets)).to.equal(false);\n            expect(await evaluate(\"2 < 2\", presets)).to.equal(false);\n        });\n\n        it(\"should return true if X and Y are both strings and X precedes Y alphabetically\", async () => {\n            var presets = {fn:()=>{}, ls:[1,2,3], ns:{a:1,b:2,c:3}, T:true, F:false};\n            expect(await evaluate(\"'abc' < 'def'\", presets)).to.equal(true);\n            expect(await evaluate(\"'abc' < 'abd'\", presets)).to.equal(true);\n            expect(await evaluate(\"'ab' < 'abc'\", presets)).to.equal(true);\n            expect(await evaluate(\"'' < 'abc'\", presets)).to.equal(true);\n            expect(await evaluate(\"'abc' < 'abc'\", presets)).to.equal(false);\n            expect(await evaluate(\"'abd' < 'abc'\", presets)).to.equal(false);\n            expect(await evaluate(\"'abc' < 'ab'\", presets)).to.equal(false);\n            expect(await evaluate(\"'abc' < ''\", presets)).to.equal(false);\n        });\n\n        it(\"should return true if X and Y are both lists and X precedes Y lexicographically\", async () => {\n            var presets = {fn:()=>{}, ls:[1,2,3], ns:{a:1,b:2,c:3}, T:true, F:false};\n            expect(await evaluate(\"[1,2,3] < [4,5,6]\", presets)).to.equal(true);\n            expect(await evaluate(\"[1,2,3] < [1,2,4]\", presets)).to.equal(true);\n            expect(await evaluate(\"[1,2] < [1,2,4]\", presets)).to.equal(true);\n            expect(await evaluate(\"[] < [1,2,3]\", presets)).to.equal(true);\n            expect(await evaluate(\"[1,2,3] < [1,2,3]\", presets)).to.equal(false);\n            expect(await evaluate(\"[1,2,4] < [1,2,3]\", presets)).to.equal(false);\n            expect(await evaluate(\"[1,2,4] < [1,2]\", presets)).to.equal(false);\n            expect(await evaluate(\"[1,2,3] < []\", presets)).to.equal(false);\n        });\n\n        it(\"should return true if X is nothing and Y is not\", async () => {\n            var presets = {fn:()=>{}, ls:[1,2,3], ns:{a:1,b:2,c:3}, T:true, F:false};\n            expect(await evaluate(\"() < ()\", presets)).to.equal(false);\n            expect(await evaluate(\"() < T\", presets)).to.equal(true);\n            expect(await evaluate(\"() < F\", presets)).to.equal(true);\n            expect(await evaluate(\"() < 1\", presets)).to.equal(true);\n            expect(await evaluate(\"() < 'abc'\", presets)).to.equal(true);\n            expect(await evaluate(\"() < ls\", presets)).to.equal(true);\n            expect(await evaluate(\"() < ns\", presets)).to.equal(true);\n            expect(await evaluate(\"() < fn\", presets)).to.equal(true);\n        });\n\n        it(\"should return false if Y is nothing and X is not\", async () => {\n            var presets = {fn:()=>{}, ls:[1,2,3], ns:{a:1,b:2,c:3}, T:true, F:false};\n            expect(await evaluate(\"() < ()\", presets)).to.equal(false);\n            expect(await evaluate(\"T < ()\", presets)).to.equal(false);\n            expect(await evaluate(\"F < ()\", presets)).to.equal(false);\n            expect(await evaluate(\"1 < ()\", presets)).to.equal(false);\n            expect(await evaluate(\"'abc' < ()\", presets)).to.equal(false);\n            expect(await evaluate(\"ls < ()\", presets)).to.equal(false);\n            expect(await evaluate(\"ns < ()\", presets)).to.equal(false);\n            expect(await evaluate(\"fn < ()\", presets)).to.equal(false);\n        });\n\n        it(\"should return Undefined for any other type combination\", async () => {\n            var T=true, F=false, n=10, s=\"abc\", ls=[1,2,3], ns={a:1}, fn=x=>x;\n            for (let [L,R] of [\n                    [T,n], [T,s], [T,ls], [T,ns], [T,fn],\n                    [F,n], [F,s], [F,ls], [F,ns], [F,fn],\n                    [n,T], [n,F], [n,s], [n,ns], [n,fn],\n                    [s,T], [s,F], [s,n], [s,ls], [s,ns], [s,fn],\n                    [ls,T], [ls,F], [ls,n], [ls,s], [ls,ns], [ls,fn],\n                    [ns,T], [ns,F], [ns,n], [ns,s], [ns,ls], [ns,fn],\n                    [fn,T], [fn,F], [fn,n], [fn,s], [fn,ls], [fn,ns] ]) {\n                \n                var LType = context.type(L);\n                var RType = context.type(R);\n                expect(await evaluate(\"L < R\", {L,R})).to.be.Undefined('comparison', L, R, new Position(\"L < R\", 2));\n            }                        \n        });\n\n        it(\"should compare tuples with lexicographical criteria\", async () => {\n            var presets = {fn:()=>{}, ls:[1,2,3], ns:{a:1,b:2,c:3}, T:true, F:false};\n            expect(await evaluate(\"(1,2,3) < (4,5,6)\", presets)).to.equal(true);\n            expect(await evaluate(\"(1,2,3) < (1,2,4)\", presets)).to.equal(true);\n            expect(await evaluate(\"(1,2) < (1,2,4)\", presets)).to.equal(true);\n            expect(await evaluate(\"() < (1,2,3)\", presets)).to.equal(true);\n            expect(await evaluate(\"(1,2,3) < (1,2,3)\", presets)).to.equal(false);\n            expect(await evaluate(\"(1,2,4) < (1,2,3)\", presets)).to.equal(false);\n            expect(await evaluate(\"(1,2,4) < (1,2)\", presets)).to.equal(false);\n            expect(await evaluate(\"(1,2,3) < ()\", presets)).to.equal(false);\n        });\n    });\n\n    describe(\"X >= Y\", () => {\n\n        it(\"should return true if both X and Y are nothing\", async () => {\n            var presets = {fn:()=>{}, ls:[1,2,3], ns:{a:1,b:2,c:3}, T:true, F:false};\n            expect(await evaluate(\"() >= ()\", presets)).to.equal(true);\n        });\n\n        it(\"should return false if X is false and Y is true\", async () => {\n            var presets = {fn:()=>{}, ls:[1,2,3], ns:{a:1,b:2,c:3}, T:true, F:false};\n            expect(await evaluate(\"T >= T\", presets)).to.equal(true);\n            expect(await evaluate(\"F >= F\", presets)).to.equal(true);\n            expect(await evaluate(\"T >= F\", presets)).to.equal(true);\n            expect(await evaluate(\"F >= T\", presets)).to.equal(false);\n        });\n\n        it(\"should return false if X is a lower number than Y\", async () => {\n            var presets = {fn:()=>{}, ls:[1,2,3], ns:{a:1,b:2,c:3}, T:true, F:false};\n            expect(await evaluate(\"1 >= 2\", presets)).to.equal(false);\n            expect(await evaluate(\"0 >= 2\", presets)).to.equal(false);\n            expect(await evaluate(\"-1 >= 2\", presets)).to.equal(false);\n            expect(await evaluate(\"2 >= 1\", presets)).to.equal(true);\n            expect(await evaluate(\"2 >= 0\", presets)).to.equal(true);\n            expect(await evaluate(\"2 >= (-2)\", presets)).to.equal(true);\n            expect(await evaluate(\"2 >= 2\", presets)).to.equal(true);\n        });\n\n        it(\"should return false if X and Y are both strings and X precedes Y alphabetically\", async () => {\n            var presets = {fn:()=>{}, ls:[1,2,3], ns:{a:1,b:2,c:3}, T:true, F:false};\n            expect(await evaluate(\"'abc' >= 'def'\", presets)).to.equal(false);\n            expect(await evaluate(\"'abc' >= 'abd'\", presets)).to.equal(false);\n            expect(await evaluate(\"'ab' >= 'abc'\", presets)).to.equal(false);\n            expect(await evaluate(\"'' >= 'abc'\", presets)).to.equal(false);\n            expect(await evaluate(\"'abc' >= 'abc'\", presets)).to.equal(true);\n            expect(await evaluate(\"'abd' >= 'abc'\", presets)).to.equal(true);\n            expect(await evaluate(\"'abc' >= 'ab'\", presets)).to.equal(true);\n            expect(await evaluate(\"'abc' >= ''\", presets)).to.equal(true);\n        });\n\n        it(\"should return false if X and Y are both lists and X precedes Y lexicographically\", async () => {\n            var presets = {fn:()=>{}, ls:[1,2,3], ns:{a:1,b:2,c:3}, T:true, F:false};\n            expect(await evaluate(\"[1,2,3] >= [4,5,6]\", presets)).to.equal(false);\n            expect(await evaluate(\"[1,2,3] >= [1,2,4]\", presets)).to.equal(false);\n            expect(await evaluate(\"[1,2] >= [1,2,4]\", presets)).to.equal(false);\n            expect(await evaluate(\"[] >= [1,2,3]\", presets)).to.equal(false);\n            expect(await evaluate(\"[1,2,3] >= [1,2,3]\", presets)).to.equal(true);\n            expect(await evaluate(\"[1,2,4] >= [1,2,3]\", presets)).to.equal(true);\n            expect(await evaluate(\"[1,2,4] >= [1,2]\", presets)).to.equal(true);\n            expect(await evaluate(\"[1,2,3] >= []\", presets)).to.equal(true);\n        });\n\n        it(\"should return false if X is nothing and Y is not\", async () => {\n            var presets = {fn:()=>{}, ls:[1,2,3], ns:{a:1,b:2,c:3}, T:true, F:false};\n            expect(await evaluate(\"() >= ()\", presets)).to.equal(true);\n            expect(await evaluate(\"() >= T\", presets)).to.equal(false);\n            expect(await evaluate(\"() >= F\", presets)).to.equal(false);\n            expect(await evaluate(\"() >= 1\", presets)).to.equal(false);\n            expect(await evaluate(\"() >= 'abc'\", presets)).to.equal(false);\n            expect(await evaluate(\"() >= ls\", presets)).to.equal(false);\n            expect(await evaluate(\"() >= ns\", presets)).to.equal(false);\n            expect(await evaluate(\"() >= fn\", presets)).to.equal(false);\n        });\n\n        it(\"should return true if Y is nothing\", async () => {\n            var presets = {fn:()=>{}, ls:[1,2,3], ns:{a:1,b:2,c:3}, T:true, F:false};\n            expect(await evaluate(\"() >= ()\", presets)).to.equal(true);\n            expect(await evaluate(\"T >= ()\", presets)).to.equal(true);\n            expect(await evaluate(\"F >= ()\", presets)).to.equal(true);\n            expect(await evaluate(\"1 >= ()\", presets)).to.equal(true);\n            expect(await evaluate(\"'abc' >= ()\", presets)).to.equal(true);\n            expect(await evaluate(\"ls >= ()\", presets)).to.equal(true);\n            expect(await evaluate(\"ns >= ()\", presets)).to.equal(true);\n            expect(await evaluate(\"fn >= ()\", presets)).to.equal(true);\n        });\n\n        it(\"should return Undefined for any other type combination\", async () => {\n            var T=true, F=false, n=10, s=\"abc\", ls=[1,2,3], ns={a:1}, fn=x=>x;\n            for (let [L,R] of [\n                    [T,n], [T,s], [T,ls], [T,ns], [T,fn],\n                    [F,n], [F,s], [F,ls], [F,ns], [F,fn],\n                    [n,T], [n,F], [n,s], [n,ns], [n,fn],\n                    [s,T], [s,F], [s,n], [s,ls], [s,ns], [s,fn],\n                    [ls,T], [ls,F], [ls,n], [ls,s], [ls,ns], [ls,fn],\n                    [ns,T], [ns,F], [ns,n], [ns,s], [ns,ls], [ns,fn],\n                    [fn,T], [fn,F], [fn,n], [fn,s], [fn,ls], [fn,ns] ]) {\n                \n                var LType = context.type(L);\n                var RType = context.type(R);\n                expect(await evaluate(\"L >= R\", {L,R})).to.be.Undefined(\"comparison\", L, R, new Position(\"L >= R\", 2));\n            }                        \n        });\n\n        it(\"should compare tuples with lexicographical criteria\", async () => {\n            var presets = {fn:()=>{}, ls:[1,2,3], ns:{a:1,b:2,c:3}, T:true, F:false};\n            expect(await evaluate(\"(1,2,3) >= (4,5,6)\", presets)).to.equal(false);\n            expect(await evaluate(\"(1,2,3) >= (1,2,4)\", presets)).to.equal(false);\n            expect(await evaluate(\"(1,2) >= (1,2,4)\", presets)).to.equal(false);\n            expect(await evaluate(\"() >= (1,2,3)\", presets)).to.equal(false);\n            expect(await evaluate(\"(1,2,3) >= (1,2,3)\", presets)).to.equal(true);\n            expect(await evaluate(\"(1,2,4) >= (1,2,3)\", presets)).to.equal(true);\n            expect(await evaluate(\"(1,2,4) >= (1,2)\", presets)).to.equal(true);\n            expect(await evaluate(\"(1,2,3) >= ()\", presets)).to.equal(true);\n        });\n    });\n\n    describe(\"X > Y\", () => {\n\n        it(\"should return false if both X and Y are nothing\", async () => {\n            var presets = {fn:()=>{}, ls:[1,2,3], ns:{a:1,b:2,c:3}, T:true, F:false};\n            expect(await evaluate(\"() > ()\", presets)).to.equal(false);\n        });\n\n        it(\"should return true if X is true and Y is false\", async () => {\n            var presets = {fn:()=>{}, ls:[1,2,3], ns:{a:1,b:2,c:3}, T:true, F:false};\n            expect(await evaluate(\"T > T\", presets)).to.equal(false);\n            expect(await evaluate(\"F > F\", presets)).to.equal(false);\n            expect(await evaluate(\"T > F\", presets)).to.equal(true);\n            expect(await evaluate(\"F > T\", presets)).to.equal(false);\n        });\n\n        it(\"should return true if X is a higher number than Y\", async () => {\n            var presets = {fn:()=>{}, ls:[1,2,3], ns:{a:1,b:2,c:3}, T:true, F:false};\n            expect(await evaluate(\"1 > 2\", presets)).to.equal(false);\n            expect(await evaluate(\"0 > 2\", presets)).to.equal(false);\n            expect(await evaluate(\"-1 > 2\", presets)).to.equal(false);\n            expect(await evaluate(\"2 > 1\", presets)).to.equal(true);\n            expect(await evaluate(\"2 > 0\", presets)).to.equal(true);\n            expect(await evaluate(\"2 > (-2)\", presets)).to.equal(true);\n            expect(await evaluate(\"2 > 2\", presets)).to.equal(false);\n        });\n\n        it(\"should return true if X and Y are both strings and X follows Y alphabetically\", async () => {\n            var presets = {fn:()=>{}, ls:[1,2,3], ns:{a:1,b:2,c:3}, T:true, F:false};\n            expect(await evaluate(\"'abc' > 'def'\", presets)).to.equal(false);\n            expect(await evaluate(\"'abc' > 'abd'\", presets)).to.equal(false);\n            expect(await evaluate(\"'ab' > 'abc'\", presets)).to.equal(false);\n            expect(await evaluate(\"'' > 'abc'\", presets)).to.equal(false);\n            expect(await evaluate(\"'abc' > 'abc'\", presets)).to.equal(false);\n            expect(await evaluate(\"'abd' > 'abc'\", presets)).to.equal(true);\n            expect(await evaluate(\"'abc' > 'ab'\", presets)).to.equal(true);\n            expect(await evaluate(\"'abc' > ''\", presets)).to.equal(true);\n        });\n\n        it(\"should return true if X and Y are both lists and X follows Y lexicographically\", async () => {\n            var presets = {fn:()=>{}, ls:[1,2,3], ns:{a:1,b:2,c:3}, T:true, F:false};\n            expect(await evaluate(\"[1,2,3] > [4,5,6]\", presets)).to.equal(false);\n            expect(await evaluate(\"[1,2,3] > [1,2,4]\", presets)).to.equal(false);\n            expect(await evaluate(\"[1,2] > [1,2,4]\", presets)).to.equal(false);\n            expect(await evaluate(\"[] > [1,2,3]\", presets)).to.equal(false);\n            expect(await evaluate(\"[1,2,3] > [1,2,3]\", presets)).to.equal(false);\n            expect(await evaluate(\"[1,2,4] > [1,2,3]\", presets)).to.equal(true);\n            expect(await evaluate(\"[1,2,4] > [1,2]\", presets)).to.equal(true);\n            expect(await evaluate(\"[1,2,3] > []\", presets)).to.equal(true);\n        });\n\n        it(\"should return false if X is nothing\", async () => {\n            var presets = {fn:()=>{}, ls:[1,2,3], ns:{a:1,b:2,c:3}, T:true, F:false};\n            expect(await evaluate(\"() > ()\", presets)).to.equal(false);\n            expect(await evaluate(\"() > T\", presets)).to.equal(false);\n            expect(await evaluate(\"() > F\", presets)).to.equal(false);\n            expect(await evaluate(\"() > 1\", presets)).to.equal(false);\n            expect(await evaluate(\"() > 'abc'\", presets)).to.equal(false);\n            expect(await evaluate(\"() > ls\", presets)).to.equal(false);\n            expect(await evaluate(\"() > ns\", presets)).to.equal(false);\n            expect(await evaluate(\"() > fn\", presets)).to.equal(false);\n        });\n\n        it(\"should return true if Y is nothing and X is not\", async () => {\n            var presets = {fn:()=>{}, ls:[1,2,3], ns:{a:1,b:2,c:3}, T:true, F:false};\n            expect(await evaluate(\"() > ()\", presets)).to.equal(false);\n            expect(await evaluate(\"T > ()\", presets)).to.equal(true);\n            expect(await evaluate(\"F > ()\", presets)).to.equal(true);\n            expect(await evaluate(\"1 > ()\", presets)).to.equal(true);\n            expect(await evaluate(\"'abc' > ()\", presets)).to.equal(true);\n            expect(await evaluate(\"ls > ()\", presets)).to.equal(true);\n            expect(await evaluate(\"ns > ()\", presets)).to.equal(true);\n            expect(await evaluate(\"fn > ()\", presets)).to.equal(true);\n        });\n\n        it(\"should return Undefined for any other type combination\", async () => {\n            var T=true, F=false, n=10, s=\"abc\", ls=[1,2,3], ns={a:1}, fn=x=>x;\n            for (let [L,R] of [\n                    [T,n], [T,s], [T,ls], [T,ns], [T,fn],\n                    [F,n], [F,s], [F,ls], [F,ns], [F,fn],\n                    [n,T], [n,F], [n,s], [n,ns], [n,fn],\n                    [s,T], [s,F], [s,n], [s,ls], [s,ns], [s,fn],\n                    [ls,T], [ls,F], [ls,n], [ls,s], [ls,ns], [ls,fn],\n                    [ns,T], [ns,F], [ns,n], [ns,s], [ns,ls], [ns,fn],\n                    [fn,T], [fn,F], [fn,n], [fn,s], [fn,ls], [fn,ns] ]) {\n                \n                var LType = context.type(L);\n                var RType = context.type(R);\n                expect(await evaluate(\"L > R\", {L,R})).to.be.Undefined('comparison', L, R, new Position(\"L > R\", 2));\n            }                        \n        });\n\n        it(\"should compare tuples with lexicographical criteria\", async () => {\n            var presets = {fn:()=>{}, ls:[1,2,3], ns:{a:1,b:2,c:3}, T:true, F:false};\n            expect(await evaluate(\"(1,2,3) > (4,5,6)\", presets)).to.equal(false);\n            expect(await evaluate(\"(1,2,3) > (1,2,4)\", presets)).to.equal(false);\n            expect(await evaluate(\"(1,2) > (1,2,4)\", presets)).to.equal(false);\n            expect(await evaluate(\"() > (1,2,3)\", presets)).to.equal(false);\n            expect(await evaluate(\"(1,2,3) > (1,2,3)\", presets)).to.equal(false);\n            expect(await evaluate(\"(1,2,4) > (1,2,3)\", presets)).to.equal(true);\n            expect(await evaluate(\"(1,2,4) > (1,2)\", presets)).to.equal(true);\n            expect(await evaluate(\"(1,2,3) > ()\", presets)).to.equal(true);\n        });\n    });\n\n    describe(\"X <= Y\", () => {\n\n        it(\"should return true if both X and Y are nothing\", async () => {\n            var presets = {fn:()=>{}, ls:[1,2,3], ns:{a:1,b:2,c:3}, T:true, F:false};\n            expect(await evaluate(\"() <= ()\", presets)).to.equal(true);\n        });\n\n        it(\"should return false if X is true and Y is false\", async () => {\n            var presets = {fn:()=>{}, ls:[1,2,3], ns:{a:1,b:2,c:3}, T:true, F:false};\n            expect(await evaluate(\"T <= T\", presets)).to.equal(true);\n            expect(await evaluate(\"F <= F\", presets)).to.equal(true);\n            expect(await evaluate(\"T <= F\", presets)).to.equal(false);\n            expect(await evaluate(\"F <= T\", presets)).to.equal(true);\n        });\n\n        it(\"should return false if X is a higher number than Y\", async () => {\n            var presets = {fn:()=>{}, ls:[1,2,3], ns:{a:1,b:2,c:3}, T:true, F:false};\n            expect(await evaluate(\"1 <= 2\", presets)).to.equal(true);\n            expect(await evaluate(\"0 <= 2\", presets)).to.equal(true);\n            expect(await evaluate(\"-1 <= 2\", presets)).to.equal(true);\n            expect(await evaluate(\"2 <= 1\", presets)).to.equal(false);\n            expect(await evaluate(\"2 <= 0\", presets)).to.equal(false);\n            expect(await evaluate(\"2 <= (-2)\", presets)).to.equal(false);\n            expect(await evaluate(\"2 <= 2\", presets)).to.equal(true);\n        });\n\n        it(\"should return false if X and Y are both strings and X follows Y alphabetically\", async () => {\n            var presets = {fn:()=>{}, ls:[1,2,3], ns:{a:1,b:2,c:3}, T:true, F:false};\n            expect(await evaluate(\"'abc' <= 'def'\", presets)).to.equal(true);\n            expect(await evaluate(\"'abc' <= 'abd'\", presets)).to.equal(true);\n            expect(await evaluate(\"'ab' <= 'abc'\", presets)).to.equal(true);\n            expect(await evaluate(\"'' <= 'abc'\", presets)).to.equal(true);\n            expect(await evaluate(\"'abc' <= 'abc'\", presets)).to.equal(true);\n            expect(await evaluate(\"'abd' <= 'abc'\", presets)).to.equal(false);\n            expect(await evaluate(\"'abc' <= 'ab'\", presets)).to.equal(false);\n            expect(await evaluate(\"'abc' <= ''\", presets)).to.equal(false);\n        });\n\n        it(\"should return false if X and Y are both lists and X follows Y lexicographically\", async () => {\n            var presets = {fn:()=>{}, ls:[1,2,3], ns:{a:1,b:2,c:3}, T:true, F:false};\n            expect(await evaluate(\"[1,2,3] <= [4,5,6]\", presets)).to.equal(true);\n            expect(await evaluate(\"[1,2,3] <= [1,2,4]\", presets)).to.equal(true);\n            expect(await evaluate(\"[1,2] <= [1,2,4]\", presets)).to.equal(true);\n            expect(await evaluate(\"[] <= [1,2,3]\", presets)).to.equal(true);\n            expect(await evaluate(\"[1,2,3] <= [1,2,3]\", presets)).to.equal(true);\n            expect(await evaluate(\"[1,2,4] <= [1,2,3]\", presets)).to.equal(false);\n            expect(await evaluate(\"[1,2,4] <= [1,2]\", presets)).to.equal(false);\n            expect(await evaluate(\"[1,2,3] <= []\", presets)).to.equal(false);\n        });\n\n        it(\"should return true if X is nothing\", async () => {\n            var presets = {fn:()=>{}, ls:[1,2,3], ns:{a:1,b:2,c:3}, T:true, F:false};\n            expect(await evaluate(\"() <= ()\", presets)).to.equal(true);\n            expect(await evaluate(\"() <= T\", presets)).to.equal(true);\n            expect(await evaluate(\"() <= F\", presets)).to.equal(true);\n            expect(await evaluate(\"() <= 1\", presets)).to.equal(true);\n            expect(await evaluate(\"() <= 'abc'\", presets)).to.equal(true);\n            expect(await evaluate(\"() <= ls\", presets)).to.equal(true);\n            expect(await evaluate(\"() <= ns\", presets)).to.equal(true);\n            expect(await evaluate(\"() <= fn\", presets)).to.equal(true);\n        });\n\n        it(\"should return false if Y is nothing and X is not\", async () => {\n            var presets = {fn:()=>{}, ls:[1,2,3], ns:{a:1,b:2,c:3}, T:true, F:false};\n            expect(await evaluate(\"() <= ()\", presets)).to.equal(true);\n            expect(await evaluate(\"T <= ()\", presets)).to.equal(false);\n            expect(await evaluate(\"F <= ()\", presets)).to.equal(false);\n            expect(await evaluate(\"1 <= ()\", presets)).to.equal(false);\n            expect(await evaluate(\"'abc' <= ()\", presets)).to.equal(false);\n            expect(await evaluate(\"ls <= ()\", presets)).to.equal(false);\n            expect(await evaluate(\"ns <= ()\", presets)).to.equal(false);\n            expect(await evaluate(\"fn <= ()\", presets)).to.equal(false);\n        });\n\n        it(\"should return Undefined for any other type combination\", async () => {\n            var T=true, F=false, n=10, s=\"abc\", ls=[1,2,3], ns={a:1}, fn=x=>x;\n            for (let [L,R] of [\n                    [T,n], [T,s], [T,ls], [T,ns], [T,fn],\n                    [F,n], [F,s], [F,ls], [F,ns], [F,fn],\n                    [n,T], [n,F], [n,s], [n,ns], [n,fn],\n                    [s,T], [s,F], [s,n], [s,ls], [s,ns], [s,fn],\n                    [ls,T], [ls,F], [ls,n], [ls,s], [ls,ns], [ls,fn],\n                    [ns,T], [ns,F], [ns,n], [ns,s], [ns,ls], [ns,fn],\n                    [fn,T], [fn,F], [fn,n], [fn,s], [fn,ls], [fn,ns] ]) {\n                \n                var LType = context.type(L);\n                var RType = context.type(R);\n                expect(await evaluate(\"L <= R\", {L,R})).to.be.Undefined(\"comparison\", L, R, new Position(\"L <= R\", 2));\n            }                        \n        });\n\n        it(\"should compare tuples with lexicographical criteria\", async () => {\n            var presets = {fn:()=>{}, ls:[1,2,3], ns:{a:1,b:2,c:3}, T:true, F:false};\n            expect(await evaluate(\"(1,2,3) <= (4,5,6)\", presets)).to.equal(true);\n            expect(await evaluate(\"(1,2,3) <= (1,2,4)\", presets)).to.equal(true);\n            expect(await evaluate(\"(1,2) <= (1,2,4)\", presets)).to.equal(true);\n            expect(await evaluate(\"() <= (1,2,3)\", presets)).to.equal(true);\n            expect(await evaluate(\"(1,2,3) <= (1,2,3)\", presets)).to.equal(true);\n            expect(await evaluate(\"(1,2,4) <= (1,2,3)\", presets)).to.equal(false);\n            expect(await evaluate(\"(1,2,4) <= (1,2)\", presets)).to.equal(false);\n            expect(await evaluate(\"(1,2,3) <= ()\", presets)).to.equal(false);\n        });\n    });\n\n\n    // FUNCTION composition\n    \n    describe(\"G << F\", () => {\n        \n        it(\"should return the function X -> G(F(X))\", async () => {\n            var presets = {f: x=>2*x, g: x=>[x]};\n            var cf = await evaluate(\"g << f\", presets);\n            expect(cf).to.be.a(\"function\");\n            expect(await cf(2)).to.deep.equal([4]);\n        });\n        \n        it(\"should work with tuples of functions\", async () => {\n            var presets = {f2: x=>2*x, f3: x=>3*x, f4: x=>4*x, g: (...x)=>[...Tuple(...x)]};\n            var cf = await evaluate(\"g << (f2,f3,f4)\", presets);\n            expect(cf).to.be.a(\"function\");\n            expect(await cf(2)).to.deep.equal([4, 6, 8]);\n        });\n        \n        it(\"should be righ-to-left associative\", async () => {\n            var presets = {f: x=>2*x, g: x=>x**2, h: x=>[x]};\n            \n            var cf = await evaluate(\"h << g << f\", presets);\n            expect(cf).to.be.a(\"function\");\n            expect(await cf(2)).to.deep.equal([16]);            \n\n            var cf = await evaluate(\"h << f << g\", presets);\n            expect(cf).to.be.a(\"function\");\n            expect(await cf(2)).to.deep.equal([8]);            \n        });\n    });\n\n    describe(\"F >> G\", () => {\n        \n        it(\"should return the function X -> G(F(X))\", async () => {\n            var presets = {f: x=>2*x, g: x=>[x]};\n            var cf = await evaluate(\"f >> g\", presets);\n            expect(cf).to.be.a(\"function\");\n            expect(await cf(2)).to.deep.equal([4]);            \n        });\n\n        it(\"should work with tuples of functions\", async () => {\n            var presets = {f2: x=>2*x, f3: x=>3*x, f4: x=>4*x, g: (...x)=>[...Tuple(...x)]};\n            var cf = await evaluate(\"(f2,f3,f4) >> g\", presets);\n            expect(cf).to.be.a(\"function\");\n            expect(await cf(2)).to.deep.equal([4, 6, 8]);            \n        });\n    });\n\n\n    // MISCELLANEOUS\n\n    describe(\"string templates\", () => {\n\n        it(\"should evaluate string literals between accent quotes '``'\", async () => {\n            expect(await evaluate(\"`ab\\nc`\")).to.equal(\"ab\\nc\");\n            expect(await evaluate(\"``\")).to.equal(\"\");\n        });\n\n        it(\"should replace expressions between `${` and `}` with their value\", async () => {\n            expect(await evaluate(\"`aaa ${2*x} bbb`\", {x:10})).to.equal(\"aaa 20 bbb\");\n        });\n    });\n    \n    describe(\"X ?> F\", () => {\n        \n        it(\"should return X if it is not undefined\", async () => {\n            for (let X of [true, false, 10, \"abc\", [], {}, x=>x]) {\n                expect(await evaluate(\"X ?> 20\", {X})).to.equal(X);\n            }\n        });\n        \n        it(\"should execute the function F with X.args as parameters if X is Undefined\", async () => {\n            var presets = {\n                f: (operation, ...operands) => ['f result', operation, ...operands],\n                u: new Undefined('op', 1, 2, 3)\n            };\n            expect(await evaluate(`u ?> f`, presets)).to.deep.equal(['f result', 'op', 1, 2, 3]);\n        });\n        \n        it(\"should return Undefined if F is not a function\", async () => {\n            var presets = {u: new Undefined()};\n            expect(await evaluate('u ?> 10', presets)).to.be.Undefined(\"application\", 10);\n        });\n        \n        it(\"should apply the operator to each item if X is a tuple\", async () => {\n            var presets = {\n                f: (operation, ...operands) => ['f result', operation, ...operands],\n                u: new Undefined('op', 1, 2, 3)\n            };\n            expect(await evaluate(`(10, u, 20) ?> f`, presets)).to.be.Tuple([10, ['f result', 'op', 1, 2, 3], 20]);            \n        });\n    });\n\n    describe(\"operators precedence and grouping\", () => {\n\n        it(\"should execute assignment operations (`=`) before pairing operations (`,`)\", async () => {\n            var ctx = context.$extend();\n\n            await parse(\"x = 1,2,3\")(ctx);\n            expect(ctx.x).to.equal(1);\n\n            await parse(\"x = (1,2,3)\")(ctx);\n            expect(ctx.x).to.be.Tuple([1,2,3]);\n        });\n\n        it(\"should execute tuple mapping (`=>`) before assignment operations (`=`)\", async () => {\n            var ctx = context.$extend({doub:x=>2*x});\n            await parse(\"t = (1,2) => doub\")(ctx);\n            expect(ctx.t).to.be.Tuple([2,4]);\n        });\n\n        it(\"should execute function definitions (`->`) before tuple mapping operations (`=>`) and assignment operations\", async () => {\n            var ctx = context.$extend();\n\n            await parse(\"f = x -> [x]\")(ctx);\n            expect(ctx.f).to.be.a(\"function\");\n            expect(await ctx.f(1)).to.deep.equal([1]);\n\n            var retval = await parse(\"1, f = x -> [x], 2\")(ctx);\n            expect(ctx.f).to.be.a(\"function\");\n            expect(retval).to.be.Tuple([1,2]);\n\n            await parse(\"t = (1,2) => x -> [x]\")(ctx);\n            expect(ctx.t).to.be.Tuple([[1],[2]]);\n        });\n\n        it(\"should execure `;` operations before function definitions (`->`)\", async () => {\n            var ctx = context.$extend({T:true, F:false});\n            expect(await parse(\"f = (x) -> x ; 1\")(ctx)).to.equal(null);\n            expect(await ctx.f(3)).to.equal(3);\n            expect(await ctx.f()).to.equal(1);\n        });\n\n        it(\"should execure `?` operations before `;` operations\", async () => {\n            var ctx = context.$extend({T:true, F:false});\n            expect(await parse(\"f = (x,y) -> x ? 1 ; y ? 2 ; 3\")(ctx)).to.equal(null);\n            expect(await ctx.f(true, false)).to.equal(1);\n            expect(await ctx.f(true, true)).to.equal(1);\n            expect(await ctx.f(false, true)).to.equal(2);\n            expect(await ctx.f(false, false)).to.equal(3);\n        });\n\n        it(\"should execute logic operations (`&` and `|`) before `?` and `;` operations\", async () => {\n            var ctx = context.$extend({T:true, F:false});\n            expect(await parse(\"f = (x,y) -> x & y ? 1 ; x | y ? 2 ; 3\")(ctx)).to.equal(null);\n            expect(await ctx.f(true, true)).to.equal(1);\n            expect(await ctx.f(true, false)).to.equal(2);\n            expect(await ctx.f(false, true)).to.equal(2);\n            expect(await ctx.f(false, false)).to.equal(3);\n        });\n\n        it(\"should execute comparison operations (`==`,`!=`,`<`,`<=`,`>=`,`>`) before logic operations (`&` and `|`)\", async () => {\n            var ctx = context.$extend({T:true, F:false});\n            expect(await parse(\"f = x -> x==0 ? 'null' ; 0.01<=x & x<0.1 ? 'small' ; 1000>x & x>=100 ? 'big' ; 'huge' \")(ctx)).to.equal(null);\n            expect(await ctx.f(0)).to.equal('null');\n            expect(await ctx.f(0.01)).to.equal('small');\n            expect(await ctx.f(0.09)).to.equal('small');\n            expect(await ctx.f(999)).to.equal('big');\n            expect(await ctx.f(100)).to.equal('big');\n            expect(await ctx.f(1000)).to.equal('huge');\n        });\n\n        it(\"should execute sum (`+`) and subtraction (`-`) operations before comparison operations (`==`,`!=`,`<`,`<=`,`>=`,`>`)\", async () => {\n            var ctx = context.$extend({T:true, F:false});\n            expect(await parse(\"1+1<4 & 8-3==5\")(ctx)).to.equal(true);\n        });\n\n        it(\"should execute product (`*`) division (`/`) and modulo (`%`) operations before sum and subtraction operations (`+` and `-`)\", async () => {\n            var ctx = context.$extend({T:true, F:false});\n            expect(await parse(\"1+2*3-10/5+8%5\")(ctx)).to.equal(8);\n        });\n\n        it(\"should execute exponentiation (`^`) operations before product (`*`) division (`/`) and modulo (`%`) operations\", async () => {\n            var ctx = context.$extend({T:true, F:false});\n            expect(await parse(\"1+2*3^2-10/5+8%5\")(ctx)).to.equal(20);\n        });\n\n        it(\"should execute subcontexting (`.`), function calls and referencing (`@`) before arithmetic operations\", async () => {\n            var ctx = context.$extend({double:x=>2*x, b:10});\n            expect(await parse(\"double 2+3\")(ctx)).to.equal(7);\n            expect(await parse(\"double(2+3)\")(ctx)).to.equal(10);\n\n            expect(await parse(\"{a=1,b=2}.a+b\")(ctx)).to.equal(11);\n            expect(await parse(\"{a=1,b=2}.(a+b)\")(ctx)).to.equal(3);\n\n            expect(await parse(\"{f=x->2*x}.f 2\")(ctx)).to.equal(4);\n            expect(await parse(\"(x->{a=2*x}) 4 . a\")(ctx)).to.equal(8);\n\n            expect(await parse(\"[10,20,30] @ 1 + 1\")(ctx)).to.equal(21);\n        });\n    });\n    \n    describe(\"undefined value\", () => {\n        \n        it(\"should expose the constructor parametera tuple as 'args'\", async () => {\n            var u = await evaluate(\"undefined('name', 1, 2, 3)\");\n            expect(u).to.be.instanceof(Undefined);\n            expect(u.args).to.be.Tuple(['name', 1,2,3]);\n        });\n    });   \n    \n    describe(\"lexer and parser errors\", () => {\n        \n        it(\"should resolve an undefined value on lexer errors\", async () => {\n\n            // missing closing quote\n            var u = await evaluate(\"\\n'abc\", {});\n            expect(u).to.be.instanceof(Undefined);\n            var args = Array.from(u.args);\n            expect(args[0]).to.equal(\"failure\");\n            expect(args[1]).to.be.instanceof(Error);\n            expect(args[1].message).to.equal(\"Closing quote expected @2:4\");            \n\n            // missing exponent\n            var u = await evaluate(\"123E+\", {});\n            expect(u).to.be.instanceof(Undefined);\n            var args = Array.from(u.args);\n            expect(args[0]).to.equal(\"failure\");\n            expect(args[1]).to.be.instanceof(Error);\n            expect(args[1].message).to.equal(\"Expected exponent value @1:5\");            \n            \n            // invalid number\n            var u = await evaluate(\"1abc\", {});\n            expect(u).to.be.instanceof(Undefined);\n            var args = Array.from(u.args);\n            expect(args[0]).to.equal(\"failure\");\n            expect(args[1]).to.be.instanceof(Error);\n            expect(args[1].message).to.equal(\"Invalid number @1:0\");            \n\n            // unexpected period\n            var u = await evaluate(\"12.34.56\", {});\n            expect(u).to.be.instanceof(Undefined);\n            var args = Array.from(u.args);\n            expect(args[0]).to.equal(\"failure\");\n            expect(args[1]).to.be.instanceof(Error);\n            expect(args[1].message).to.equal(\"Unexpected period @1:5\");\n\n            // invalid name identifier\n            var u = await evaluate(\"$a\", {$a:1});\n            expect(u).to.be.instanceof(Undefined);\n            var args = Array.from(u.args);\n            expect(args[0]).to.equal(\"failure\");\n            expect(args[1]).to.be.instanceof(Error);\n            expect(args[1].message).to.equal(\"Unexpected character '$' @1:0\");\n        });\n        \n        it(\"should resolve an undefined value on parser errors\", async () => {\n            \n            // operand expected\n            var u = await evaluate(\"125 +\", {});\n            expect(u).to.be.instanceof(Undefined);\n            var args = Array.from(u.args);\n            expect(args[0]).to.equal(\"failure\");\n            expect(args[1]).to.be.instanceof(Error);\n            expect(args[1].message).to.equal(\"Operand expected @1:5\");\n\n            // operand expected\n            var u = await evaluate(\"(125 +\", {});\n            expect(u).to.be.instanceof(Undefined);\n            var args = Array.from(u.args);\n            expect(args[0]).to.equal(\"failure\");\n            expect(args[1]).to.be.instanceof(Error);\n            expect(args[1].message).to.equal(\"Operand expected @1:6\");\n\n            // operand expected\n            var u = await evaluate(\"125 + *\", {});\n            expect(u).to.be.instanceof(Undefined);\n            var args = Array.from(u.args);\n            expect(args[0]).to.equal(\"failure\");\n            expect(args[1]).to.be.instanceof(Error);\n            expect(args[1].message).to.equal(\"Operand expected @1:6\");\n        });\n    });\n});\n\n\n//# sourceURL=webpack:////home/marcello/mdb/Code/olojs/node_modules/@onlabsorg/swan-js/test/interpreter.js?");

/***/ }),

/***/ "../../node_modules/@onlabsorg/swan-js/test/modules.js":
/*!*************************************************************************************!*\
  !*** /home/marcello/mdb/Code/olojs/node_modules/@onlabsorg/swan-js/test/modules.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("describe(\"STANDARD LIBRARY\", () => {\n    __webpack_require__(/*! ./modules/path */ \"../../node_modules/@onlabsorg/swan-js/test/modules/path.js\");\n    __webpack_require__(/*! ./modules/text */ \"../../node_modules/@onlabsorg/swan-js/test/modules/text.js\");\n    __webpack_require__(/*! ./modules/json */ \"../../node_modules/@onlabsorg/swan-js/test/modules/json.js\");\n    __webpack_require__(/*! ./modules/list */ \"../../node_modules/@onlabsorg/swan-js/test/modules/list.js\");\n    __webpack_require__(/*! ./modules/math */ \"../../node_modules/@onlabsorg/swan-js/test/modules/math.js\");\n    __webpack_require__(/*! ./modules/date */ \"../../node_modules/@onlabsorg/swan-js/test/modules/date.js\");\n    __webpack_require__(/*! ./modules/http */ \"../../node_modules/@onlabsorg/swan-js/test/modules/http.js\");\n    __webpack_require__(/*! ./modules/debug */ \"../../node_modules/@onlabsorg/swan-js/test/modules/debug.js\");\n});\n\n\n//# sourceURL=webpack:////home/marcello/mdb/Code/olojs/node_modules/@onlabsorg/swan-js/test/modules.js?");

/***/ }),

/***/ "../../node_modules/@onlabsorg/swan-js/test/modules/date.js":
/*!******************************************************************************************!*\
  !*** /home/marcello/mdb/Code/olojs/node_modules/@onlabsorg/swan-js/test/modules/date.js ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var expect = __webpack_require__(/*! chai */ \"../../node_modules/chai/index.js\").expect;\nvar date = __webpack_require__(/*! ../../lib/modules/date */ \"../../node_modules/@onlabsorg/swan-js/lib/modules/date.js\");\n\ndescribe(\"date module\", function () {\n\n    describe(\"date(y, m, d, h, min, sec, ms)\", function () {\n        it(\"should return the number of milliseconds from epoch in UTC\", async function () {\n            var d = new Date(1977,1,26,1,50,23,560);\n            expect(await date.__apply__(1977,2,26,1,50,23,560)).to.equal(Number(d));\n        });\n    });\n\n    describe(\"date.parse(str)\", function () {\n        it(\"should convert the date string representation to the number of milliseconds from epoch\", async function () {\n            var d = new Date(1977,1,26,1,50,23,560);\n            var dstr = d.toISOString();\n            expect(await date.parse(dstr)).to.equal(Number(d));\n        });\n    });\n\n    describe(\"date.now()\", function () {\n        it(\"should convert current date in milliseconds from epoch\", async function () {\n            var d = new Date(1977,1,26,1,50,23,560);\n            var dstr = d.toISOString();\n            expect(await date.now() - Date.now() > -1000).to.be.true;\n        });\n    });\n\n    describe(\"date.stringify(d)\", function () {\n        it(\"should return the ISO representation of the given date\", async function () {\n            var d = await date.__apply__(1977,2,26,1,50,23,560);\n            expect(await date.stringify(d)).to.equal(\"1977-02-26T00:50:23.560Z\");\n        });\n    });\n\n    describe(\"date.year(d)\", () => {\n        it(\"should return the year of the given date\", async function () {\n            var d = await date.__apply__(1977,2,26,1,50,23,560);\n            expect(date.year(d)).to.equal(1977);\n        });\n    });\n\n    describe(\"date.month(d)\", () => {\n        it(\"should return the month of the given date\", async function () {\n            var d = await date.__apply__(1977,2,26,1,50,23,560);\n            expect(date.month(d)).to.equal(2);\n        });\n    });\n\n    describe(\"date.week(d)\", () => {\n        it(\"should return the ISO year week number of the given date interpreted as local date\", async function () {\n            var d = await date.__apply__(2021,2,1,1,0,0,0);\n            expect(await date.week(d)).to.equal(5);\n        });\n    });\n\n    describe(\"date.day(d)\", () => {\n        it(\"should return the day of the given date\", async function () {\n            var d = await date.__apply__(1977,2,26,1,50,23,560);\n            expect(date.day(d)).to.equal(26);\n        });\n    });\n\n    describe(\"date.hours(d)\", () => {\n        it(\"should return the hours of the given date\", async function () {\n            var d = await date.__apply__(1977,2,26,1,50,23,560);\n            expect(date.hours(d)).to.equal(1);\n        });\n    });\n\n    describe(\"date.minutes(d)\", () => {\n        it(\"should return the minutes of the given date\", async function () {\n            var d = await date.__apply__(1977,2,26,1,50,23,560);\n            expect(date.minutes(d)).to.equal(50);\n        });\n    });\n\n    describe(\"date.seconds(d)\", () => {\n        it(\"should return the seconds of the given date\", async function () {\n            var d = await date.__apply__(1977,2,26,1,50,23,560);\n            expect(date.seconds(d)).to.equal(23);\n        });\n    });\n\n    describe(\"date.milliseconds(d)\", () => {\n        it(\"should return the milliseconds of the given date\", async function () {\n            var d = await date.__apply__(1977,2,26,1,50,23,560);\n            expect(date.milliseconds(d)).to.equal(560);\n        });\n    });\n\n    describe(\"date.timezone\", () => {\n        it(\"should return the local timezone in hours\", async function () {\n            expect(-date.timezone*60).to.equal((new Date()).getTimezoneOffset());\n        });\n    });\n\n    describe(\"date.UTC(y, m, d, h, min, sec, ms)\", function () {\n        it(\"should return the number of milliseconds from epoch in UTC\", async function () {\n            var d = Date.UTC(1977,1,26,1,50,23,560);\n            expect(await date.UTC.__apply__(1977,2,26,1,50,23,560)).to.equal(Number(d));\n        });\n    });\n\n    describe(\"date.UTC.year(d)\", () => {\n        it(\"should return the UTC year of the given date\", async function () {\n            var d = await date.UTC.__apply__(1977,2,26,1,50,23,560);\n            expect(date.UTC.year(d)).to.equal(1977);\n        });\n    });\n\n    describe(\"date.UTC.month(d)\", () => {\n        it(\"should return the month of the given date\", async function () {\n            var d = await date.UTC.__apply__(1977,2,26,1,50,23,560);\n            expect(date.UTC.month(d)).to.equal(2);\n        });\n    });\n\n    describe(\"date.UTC.day(d)\", () => {\n        it(\"should return the day of the given date\", async function () {\n            var d = await date.UTC.__apply__(1977,2,26,1,50,23,560);\n            expect(date.UTC.day(d)).to.equal(26);\n        });\n    });\n\n    describe(\"date.UTC.hours(d)\", () => {\n        it(\"should return the UTC hours of the given date\", async function () {\n            var d = await date.UTC.__apply__(1977,2,26,1,50,23,560);\n            expect(date.UTC.hours(d)).to.equal(1);\n        });\n    });\n\n    describe(\"date.UTC.minutes(d)\", () => {\n        it(\"should return the UTC minutes of the given date\", async function () {\n            var d = await date.UTC.__apply__(1977,2,26,1,50,23,560);\n            expect(date.UTC.minutes(d)).to.equal(50);\n        });\n    });\n\n    describe(\"date.UTC.seconds(d)\", () => {\n        it(\"should return the UTC seconds of the given date\", async function () {\n            var d = await date.UTC.__apply__(1977,2,26,1,50,23,560);\n            expect(date.UTC.seconds(d)).to.equal(23);\n        });\n    });\n\n    describe(\"date.UTC.milliseconds(d)\", () => {\n        it(\"should return the UTC milliseconds of the given date\", async function () {\n            var d = await date.UTC.__apply__(1977,2,26,1,50,23,560);\n            expect(date.UTC.milliseconds(d)).to.equal(560);\n        });\n    });\n});\n\n\n//# sourceURL=webpack:////home/marcello/mdb/Code/olojs/node_modules/@onlabsorg/swan-js/test/modules/date.js?");

/***/ }),

/***/ "../../node_modules/@onlabsorg/swan-js/test/modules/debug.js":
/*!*******************************************************************************************!*\
  !*** /home/marcello/mdb/Code/olojs/node_modules/@onlabsorg/swan-js/test/modules/debug.js ***!
  \*******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var expect = __webpack_require__(/*! chai */ \"../../node_modules/chai/index.js\").expect;\nvar loadlib = __webpack_require__(/*! ../../lib/modules */ \"../../node_modules/@onlabsorg/swan-js/lib/modules.js\").require;\nvar {context, Tuple, Undefined} = __webpack_require__(/*! ../../lib/interpreter */ \"../../node_modules/@onlabsorg/swan-js/lib/interpreter.js\");\n\n\ndescribe(\"debug module\", function () {\n    \n    describe(\"debug.log\", () => {\n        var jslog, logId, logged;\n        \n        before(() => {\n            jslog = console.log;\n            console.log = (id, value) => {\n                logId = id;\n                logged = value;\n            }\n        });\n        \n        it(\"should log the passed arguments to the console\", async () => {\n            const debug = await loadlib('debug');\n            \n            await debug.log.call(context, 10,'abc',{x:1});\n            expect(logId).to.equal(\"Log 1:\");\n            expect(logged).to.be.instanceof(Tuple);\n            expect(Array.from(logged)).to.deep.equal([10,'abc',{x:1}]);\n\n            await debug.log.call(context, 11);\n            expect(logId).to.equal(\"Log 2:\");\n            expect(logged).to.equal(11);\n        });\n        \n        it(\"should return the log number\", async () => {\n            const debug = await loadlib('debug');\n            expect(await debug.log.call(context, 10,'abc',{x:1})).to.equal(\"[[Log 3]]\");\n        });\n        \n        after(() => {\n            console.log = jslog;\n        });\n    });\n    \n    describe(\"debug.inspect\", () => {\n        it(\"should return a descriptor of the passed argument\", async () => {\n            const debug = await loadlib('debug');\n\n            var descriptor = await debug.inspect.call(context, true);\n            expect(descriptor).to.deep.equal({type:\"Boolean\", data:true});\n\n            var descriptor = await debug.inspect.call(context, 10);\n            expect(descriptor).to.deep.equal({type:\"Number\", data:10});\n\n            var descriptor = await debug.inspect.call(context, 'abc');\n            expect(descriptor).to.deep.equal({type:\"String\", data:'abc'});\n\n            var f = x => x;\n            var descriptor = await debug.inspect.call(context, f);\n            expect(descriptor).to.deep.equal({type:\"Function\", data:f});\n\n            var descriptor = await debug.inspect.call(context, [1,'abc']);\n            expect(descriptor).to.deep.equal({\n                type: \"List\", \n                data: [\n                    {type:\"Number\", data:1},\n                    {type:\"String\", data:'abc'}\n                ]\n            });\n\n            var descriptor = await debug.inspect.call(context, {x:10, s:'abc'});\n            expect(descriptor).to.deep.equal({\n                type: \"Namespace\", \n                data: {\n                    x: {type:\"Number\", data:10},\n                    s: {type:\"String\", data:'abc'}\n                }\n            });\n\n            var e = new Error();\n            var descriptor = await debug.inspect.call(context, e);\n            expect(descriptor).to.deep.equal({\n                type: \"Error\", \n                data: e\n            });\n            \n            var descriptor = await debug.inspect.call(context, 10, 'abc');\n            expect(descriptor).to.deep.equal({\n                type: \"Tuple\", \n                data: [\n                    {type:\"Number\", data:10},\n                    {type:\"String\", data:'abc'}\n                ]\n            });\n            \n            var u = new Undefined(10, 'abc');\n            var descriptor = await debug.inspect.call(context, u);\n            expect(descriptor).to.deep.equal({\n                type: \"Undefined\", \n                data: [\n                    {type:\"Number\", data:10},\n                    {type:\"String\", data:'abc'}\n                ]\n            });            \n        });\n    });\n});\n\n\n\n//# sourceURL=webpack:////home/marcello/mdb/Code/olojs/node_modules/@onlabsorg/swan-js/test/modules/debug.js?");

/***/ }),

/***/ "../../node_modules/@onlabsorg/swan-js/test/modules/http.js":
/*!******************************************************************************************!*\
  !*** /home/marcello/mdb/Code/olojs/node_modules/@onlabsorg/swan-js/test/modules/http.js ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var expect = __webpack_require__(/*! chai */ \"../../node_modules/chai/index.js\").expect;\nvar loadlib = __webpack_require__(/*! ../../lib/modules */ \"../../node_modules/@onlabsorg/swan-js/lib/modules.js\").require;\n\ndescribe(\"http module\", function () {\n\n    describe(\"http.get(url, options)\", function () {\n\n        it(\"should fetch the text at the given url\", async function () {\n            this.timeout(500);\n            var http = await loadlib(\"http\");\n            var url = \"https://raw.githubusercontent.com/onlabsorg/olojs/master/README.md\";\n            var response = await fetch(url);\n            var content = await response.text();\n            expect(await http.get(url)).to.equal(content);\n        });\n\n        it(\"should throw an error if the response status is not 2XX\", async () => {\n            var http = await loadlib(\"http\");\n            var url = \"https://raw.githubusercontent.com/onlabsorg/olojs/master/NON_EXISTING_FILE\";\n            try {\n                await http.get(url);\n                throw new Error(\"it didn't throw\");\n            } catch (error) {\n                expect(error.message).to.equal(\"404\");\n            }\n        });\n    });\n});\n\n\n//# sourceURL=webpack:////home/marcello/mdb/Code/olojs/node_modules/@onlabsorg/swan-js/test/modules/http.js?");

/***/ }),

/***/ "../../node_modules/@onlabsorg/swan-js/test/modules/json.js":
/*!******************************************************************************************!*\
  !*** /home/marcello/mdb/Code/olojs/node_modules/@onlabsorg/swan-js/test/modules/json.js ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var expect = __webpack_require__(/*! chai */ \"../../node_modules/chai/index.js\").expect;\nvar loadlib = __webpack_require__(/*! ../../lib/modules */ \"../../node_modules/@onlabsorg/swan-js/lib/modules.js\").require;\n\n\ndescribe(\"json module\", () => {\n\n    describe(\"json.parse(str)\", () => {\n        it(\"should convert the passed json string to a javascript object\", async () => {\n            var json = await loadlib(\"json\");\n            expect(json.parse(`{\"a\":1, \"b\":true}`)).to.deep.equal({a:1, b:true});\n        });\n    });\n\n    describe(\"json.stringify(n)\", () => {\n        it(\"should return a function that takes an object and returns its json representation with `n` indentation spaces\", async () => {\n            var json = await loadlib(\"json\");\n            expect(json.stringify(0)({a:1})).to.equal(`{\"a\":1}`);\n            expect(json.stringify(2)({a:1})).to.equal(`{\\n  \"a\": 1\\n}`);\n        });\n    });\n});\n\n\n//# sourceURL=webpack:////home/marcello/mdb/Code/olojs/node_modules/@onlabsorg/swan-js/test/modules/json.js?");

/***/ }),

/***/ "../../node_modules/@onlabsorg/swan-js/test/modules/list.js":
/*!******************************************************************************************!*\
  !*** /home/marcello/mdb/Code/olojs/node_modules/@onlabsorg/swan-js/test/modules/list.js ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var expect = __webpack_require__(/*! chai */ \"../../node_modules/chai/index.js\").expect;\nvar loadlib = __webpack_require__(/*! ../../lib/modules */ \"../../node_modules/@onlabsorg/swan-js/lib/modules.js\").require;\nvar swan = __webpack_require__(/*! ../.. */ \"../../node_modules/@onlabsorg/swan-js/index.js\");\n\n\ndescribe(\"list module\", () => {\n\n    describe(\"list.find(list, item)\", () => {\n\n        it(\"should return the first index of subStr in str\", async () => {\n            var list = await loadlib(\"list\");\n            expect(await list.find([0,10,20,10,20], 20)).to.equal(2);\n        });\n\n        it(\"should return -1 if no match is found\", async () => {\n            var list = await loadlib(\"list\");\n            expect(await list.find([0,10,20,10,20], 50)).to.equal(-1);\n        });\n    });\n\n    describe(\"text.rfind(str, subStr)\", () => {\n\n        it(\"should return the first index of subStr in str\", async () => {\n            var list = await loadlib(\"list\");\n            expect(await list.rfind([0,10,20,10,20], 20)).to.equal(4);\n        });\n\n        it(\"should return -1 if no match is found\", async () => {\n            var list = await loadlib(\"list\");\n            expect(await list.rfind([0,10,20,10,20], 50)).to.equal(-1);\n        });\n    });\n\n    describe(\"text.slice(list, firstIndex, lastIndex)\", () => {\n\n        it(\"should return a slice of the given string from firstIndex to lastIndex\", async () => {\n            var list = await loadlib(\"list\");\n            expect(await list.slice([0,10,20,30,40,50,60], 2, 5)).to.deep.equal([20,30,40]);\n        });\n\n        it(\"should allow negative indexing\", async () => {\n            var list = await loadlib(\"list\");\n            expect(await list.slice([0,10,20,30,40,50,60], -5, -2)).to.deep.equal([20,30,40]);\n        });\n\n        it(\"should slice till the end of the string if lastIndex is omitted\", async () => {\n            var list = await loadlib(\"list\");\n            expect(await list.slice([0,10,20,30,40,50,60], 3)).to.deep.equal([30,40,50,60]);\n        });\n    });\n\n    describe(\"text.reverse(list)\", () => {\n\n        it(\"should return a copy of the passed list, in reversed order\", async () => {\n            var list = await loadlib(\"list\");\n            var l1 = [1,2,3,4,5];\n            var l2 = await list.reverse(l1);\n            expect(l1).to.not.equal(l2);\n            expect(l2).to.deep.equal([5,4,3,2,1]);\n        });\n    });\n\n    describe(\"text.join(list, separator)\", () => {\n\n        it(\"should return a string obtaining by concatenating the list item with interposed separator\", async () => {\n            var list = await loadlib(\"list\");\n            expect(await list.join([\"a\",\"b\",\"c\"],\",\")).to.equal(\"a,b,c\");\n        });\n    });\n});\n\n\n//# sourceURL=webpack:////home/marcello/mdb/Code/olojs/node_modules/@onlabsorg/swan-js/test/modules/list.js?");

/***/ }),

/***/ "../../node_modules/@onlabsorg/swan-js/test/modules/math.js":
/*!******************************************************************************************!*\
  !*** /home/marcello/mdb/Code/olojs/node_modules/@onlabsorg/swan-js/test/modules/math.js ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var expect = __webpack_require__(/*! chai */ \"../../node_modules/chai/index.js\").expect;\nvar loadlib = __webpack_require__(/*! ../../lib/modules */ \"../../node_modules/@onlabsorg/swan-js/lib/modules.js\").require;\n\ndescribe(\"math module\", () => {\n\n    describe(\"math.E\", () => {\n        it(\"should return the Euler's number\", async () => {\n            var math = await loadlib(\"math\");\n            expect(math.PI).to.equal(Math.PI);\n        });\n    });\n\n    describe(\"math.PI\", () => {\n        it(\"should return the Pi number\", async () => {\n            var math = await loadlib(\"math\");\n            expect(math.PI).to.equal(Math.PI);\n        });\n    });\n\n    describe(\"math.abs(x)\", () => {\n        it(\"should return the absolute value of a number\", async () => {\n            var math = await loadlib(\"math\");\n            expect(await math.abs(-123.45)).to.equal(123.45);\n            expect(await math.abs(0)).to.equal(0);\n            expect(await math.abs(123.45)).to.equal(123.45);\n        });\n    });\n\n    describe(\"math.acos(x)\", () => {\n        it(\"should return the arc-cosine of a number\", async () => {\n            var math = await loadlib(\"math\");\n            expect(await math.acos(0.5)).to.equal(Math.acos(0.5));\n        });\n    });\n\n    describe(\"math.acosh(x)\", () => {\n        it(\"should return the arc-hyperbolic-cosine of a number\", async () => {\n            var math = await loadlib(\"math\");\n            expect(await math.acosh(2)).to.equal(Math.acosh(2));\n        });\n    });\n\n    describe(\"math.asin(x)\", () => {\n        it(\"should return the arc-sine of a number\", async () => {\n            var math = await loadlib(\"math\");\n            expect(await math.asin(0.5)).to.equal(Math.asin(0.5));\n        });\n    });\n\n    describe(\"math.asinh(x)\", () => {\n        it(\"should return the arc-hyperbolic-sine of a number\", async () => {\n            var math = await loadlib(\"math\");\n            expect(await math.asinh(2)).to.equal(Math.asinh(2));\n        });\n    });\n\n    describe(\"math.atan(x)\", () => {\n        it(\"should return the arc-tangent of a number\", async () => {\n            var math = await loadlib(\"math\");\n            expect(await math.atan(0.5)).to.equal(Math.atan(0.5));\n        });\n    });\n\n    describe(\"math.atanh(x)\", () => {\n        it(\"should return the arc-hyperbolic-tangent of a number\", async () => {\n            var math = await loadlib(\"math\");\n            expect(await math.atanh(0.5)).to.equal(Math.atanh(0.5));\n        });\n    });\n\n    describe(\"math.ceil(x)\", () => {\n        it(\"should round up a number to the closest largest integer\", async () => {\n            var math = await loadlib(\"math\");\n            expect(math.ceil(12.345)).to.equal(13);\n            expect(math.ceil(-12.345)).to.equal(-12);\n        });\n    });\n\n    describe(\"math.cos(x)\", () => {\n        it(\"should return the cosine of a number\", async () => {\n            var math = await loadlib(\"math\");\n            expect(math.cos(0.5)).to.equal(Math.cos(0.5));\n        });\n    });\n\n    describe(\"math.cosh(x)\", () => {\n        it(\"should return the hyperbolic cosine of a number\", async () => {\n            var math = await loadlib(\"math\");\n            expect(math.cosh(0.5)).to.equal(Math.cosh(0.5));\n        });\n    });\n\n    describe(\"math.exp(x)\", () => {\n        it(\"should return E to the power of a number\", async () => {\n            var math = await loadlib(\"math\");\n            expect(math.exp(0.5)).to.equal(math.E**0.5);\n        });\n    });\n\n    describe(\"math.floor(x)\", () => {\n        it(\"should round up a number to the closest smallest integer\", async () => {\n            var math = await loadlib(\"math\");\n            expect(math.floor(12.345)).to.equal(12);\n            expect(math.floor(-12.345)).to.equal(-13);\n        });\n    });\n\n    describe(\"math.log(x)\", () => {\n        it(\"should return the natural logaritm of a number\", async () => {\n            var math = await loadlib(\"math\");\n            expect(await math.log(2)).to.equal(Math.log(2));\n            expect(await math.log(Math.E**2)).to.equal(2);\n        });\n    });\n\n    describe(\"math.log10(x)\", () => {\n        it(\"should return the logaritm with base 10 of a number\", async () => {\n            var math = await loadlib(\"math\");\n            expect(await math.log10(2)).to.equal(Math.log10(2));\n            expect(await math.log10(100)).to.equal(2);\n        });\n    });\n\n    describe(\"math.max(x1, x2, x3, ...)\", () => {\n        it(\"should return the maximum of a list of numbers\", async () => {\n            var math = await loadlib(\"math\");\n            expect(await math.max(23,1,13,56,22,-108)).to.equal(56);\n        });\n    });\n\n    describe(\"math.min(x1, x2, x3, ...)\", () => {\n        it(\"should return the minimum of a list of numbers\", async () => {\n            var math = await loadlib(\"math\");\n            expect(await math.min(23,1,13,56,22,-108)).to.equal(-108);\n        });\n    });\n\n    describe(\"math.random(x)\", () => {\n        it(\"should return a random number between 0 and x\", async () => {\n            var math = await loadlib(\"math\");\n\n            var y1 = await math.random(2);\n            expect(0 <= y1 && y1 <= 2).to.be.true;\n\n            var y2 = await math.random(2);\n            var y3 = await math.random(2);\n\n            expect(y1).to.not.equal(y2);\n            expect(y1).to.not.equal(y3);\n            expect(y2).to.not.equal(y3);\n        });\n    });\n\n    describe(\"math.round(x)\", () => {\n        it(\"should round the given number to the closest integer\", async () => {\n            var math = await loadlib(\"math\");\n\n            expect(await math.round(12.345)).to.equal(12);\n            expect(await math.round(6.789)).to.equal(7);\n            expect(await math.round(10.5)).to.equal(11);\n\n            expect(await math.round(-12.345)).to.equal(-12);\n            expect(await math.round(-6.789)).to.equal(-7);\n            expect(await math.round(-10.5)).to.equal(-10);\n        });\n    });\n\n    describe(\"math.sin(x)\", () => {\n        it(\"should return the sine of a number\", async () => {\n            var math = await loadlib(\"math\");\n            expect(math.sin(0.5)).to.equal(Math.sin(0.5));\n        });\n    });\n\n    describe(\"math.sinh(x)\", () => {\n        it(\"should return the hyperbolic sine of a number\", async () => {\n            var math = await loadlib(\"math\");\n            expect(math.sinh(0.5)).to.equal(Math.sinh(0.5));\n        });\n    });\n\n    describe(\"math.sqrt(x)\", () => {\n        it(\"should return the square root of a number\", async () => {\n            var math = await loadlib(\"math\");\n            expect(await math.sqrt(4)).to.equal(2);\n            expect(await math.sqrt(34.5)).to.equal(34.5**0.5);\n        });\n    });\n\n    describe(\"math.tan(x)\", () => {\n        it(\"should return the tangent of a number\", async () => {\n            var math = await loadlib(\"math\");\n            expect(math.tan(0.5)).to.equal(Math.tan(0.5));\n        });\n    });\n\n    describe(\"math.tanh(x)\", () => {\n        it(\"should return the hyperbolic tangent of a number\", async () => {\n            var math = await loadlib(\"math\");\n            expect(math.tanh(0.5)).to.equal(Math.tanh(0.5));\n        });\n    });\n\n    describe(\"math.trunc(x)\", () => {\n        it(\"should return the integer part of a number\", async () => {\n            var math = await loadlib(\"math\");\n\n            expect(await math.trunc(12.345)).to.equal(12);\n            expect(await math.trunc(6.789)).to.equal(6);\n            expect(await math.trunc(10.5)).to.equal(10);\n\n            expect(await math.trunc(-12.345)).to.equal(-12);\n            expect(await math.trunc(-6.789)).to.equal(-6);\n            expect(await math.trunc(-10.5)).to.equal(-10);\n        });\n    });\n\n    describe(\"math.hex(s)\", () => {\n        it(\"should return a number given his hexadecimal string representation\", async () => {\n            var math = await loadlib(\"math\");\n            expect(await math.hex('FF')).to.equal(255);\n        });\n    });\n\n    describe(\"math.oct(s)\", () => {\n        it(\"should return a number given his octal string representation\", async () => {\n            var math = await loadlib(\"math\");\n            expect(await math.oct('77')).to.equal(63);\n        });\n    });\n\n    describe(\"math.bin(s)\", () => {\n        it(\"should return a number given his binary string representation\", async () => {\n            var math = await loadlib(\"math\");\n            expect(await math.bin('11')).to.equal(3);\n        });\n    });\n});\n\n\n//# sourceURL=webpack:////home/marcello/mdb/Code/olojs/node_modules/@onlabsorg/swan-js/test/modules/math.js?");

/***/ }),

/***/ "../../node_modules/@onlabsorg/swan-js/test/modules/path.js":
/*!******************************************************************************************!*\
  !*** /home/marcello/mdb/Code/olojs/node_modules/@onlabsorg/swan-js/test/modules/path.js ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var expect = __webpack_require__(/*! chai */ \"../../node_modules/chai/index.js\").expect;\nvar path = __webpack_require__(/*! ../../lib/modules/path */ \"../../node_modules/@onlabsorg/swan-js/lib/modules/path.js\");\n\n\ndescribe(\"path module\", () => {\n\n    describe(\"path.dir(path)\", () => {\n        it(\"should return the path without the last portion\", async () => {\n            expect(await path.dir('/path/to/name.ext')).to.equal('/path/to');\n        });\n    });\n\n    describe(\"path.fullName(path)\", () => {\n        it(\"should return the last portion of the path\", async () => {\n            expect(await path.fullName('/path/to/name.ext')).to.equal('name.ext');\n        });\n    });\n\n    describe(\"path.name(path)\", () => {\n        it(\"should return the last portion of the path, without extension\", async () => {\n            expect(await path.name('/path/to/fname.ext')).to.equal('fname');\n        });\n    });\n\n    describe(\"path.ext(path)\", () => {\n        it(\"should return the file extension\", async () => {\n            expect(await path.ext('/path/to/name.ext')).to.equal('.ext');\n        });\n    });\n\n    describe(\"path.nomalize(path)\", () => {\n        it(\"should resolve `.`, `..` and multiple `/`\", async () => {\n            expect(await path.normalize('/foo/bar//baz/asdf/quux/..')).to.equal('/foo/bar/baz/asdf');\n        });\n    });\n\n    describe(\"path.join(...paths)\", () => {\n        it(\"should join and normalize the passed paths\", async () => {\n            expect(await path.join('/foo/bar', './baz/asdf', '/quux/..')).to.equal('/foo/bar/baz/asdf');\n        });\n    });\n\n    describe(\"path.resolve(...paths)\", () => {\n        it(\"should resolve and normalize the passed paths\", async () => {\n            expect(await path.resolve('/foo/bar', './baz/asdf', 'quux/..')).to.equal('/foo/bar/baz/asdf');\n            expect(await path.resolve('foo/bar', './baz/asdf', 'quux/..')).to.equal('/foo/bar/baz/asdf');\n            expect(await path.resolve('/foo/bar', '/baz/asdf', 'quux/..')).to.equal('/baz/asdf');\n        });\n    });\n});\n\n\n//# sourceURL=webpack:////home/marcello/mdb/Code/olojs/node_modules/@onlabsorg/swan-js/test/modules/path.js?");

/***/ }),

/***/ "../../node_modules/@onlabsorg/swan-js/test/modules/text.js":
/*!******************************************************************************************!*\
  !*** /home/marcello/mdb/Code/olojs/node_modules/@onlabsorg/swan-js/test/modules/text.js ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var expect = __webpack_require__(/*! chai */ \"../../node_modules/chai/index.js\").expect;\nvar loadlib = __webpack_require__(/*! ../../lib/modules */ \"../../node_modules/@onlabsorg/swan-js/lib/modules.js\").require;\n\n\ndescribe(\"text module\", () => {\n\n    describe(\"text.find(str, subStr)\", () => {\n\n        it(\"should return the first index of subStr in str\", async () => {\n            var text = await loadlib(\"text\");\n            expect(await text.find(\"__Abc__def__Abc\", \"Abc\")).to.equal(2);\n        });\n\n        it(\"should return -1 if no match is found\", async () => {\n            var text = await loadlib(\"text\");\n            expect(await text.find(\"__Abc__def__Abc\", \"xxx\")).to.equal(-1);\n        });\n    });\n\n    describe(\"text.rfind(str, subStr)\", () => {\n\n        it(\"should return the last index of subStr in str\", async () => {\n            var text = await loadlib(\"text\");\n            expect(await text.rfind(\"__Abc__def__Abc\", \"Abc\")).to.equal(12);\n        });\n\n        it(\"should return -1 if no match is found\", async () => {\n            var text = await loadlib(\"text\");\n            expect(await text.rfind(\"__Abc__def__Abc\", \"xxx\")).to.equal(-1);\n        });\n    });\n\n    describe(\"text.lower(str)\", () => {\n\n        it(\"should return the given string converted to lower case characters\", async () => {\n            var text = await loadlib(\"text\");\n            expect(await text.lower(\"AbcDef\")).to.equal(\"abcdef\");\n        });\n    });\n\n    describe(\"text.upper(str)\", () => {\n\n        it(\"should return the given string converted to upper case characters\", async () => {\n            var text = await loadlib(\"text\");\n            expect(await text.upper(\"AbcDef\")).to.equal(\"ABCDEF\");\n        });\n    });\n\n    describe(\"text.char(...charCodes)\", () => {\n\n        it(\"should return the string made of the given UTF char codes\", async () => {\n            var text = await loadlib(\"text\");\n            expect(await text.char(65, 98, 99)).to.equal(\"Abc\");\n        });\n    });\n\n    describe(\"text.code(str)\", () => {\n\n        it(\"should return the list of UTF char codes of the given string\", async () => {\n            var text = await loadlib(\"text\");\n            expect(await text.code(\"Abc\")).to.deep.equal([65, 98, 99]);\n        });\n    });\n\n    describe(\"text.slice(str, firstIndex, lastIndex)\", () => {\n\n        it(\"should return a slice of the given string from firstIndex to lastIndex\", async () => {\n            var text = await loadlib(\"text\");\n            expect(await text.slice(\"0123456789\", 2, 5)).to.equal(\"234\");\n        });\n\n        it(\"should allow negative indexing\", async () => {\n            var text = await loadlib(\"text\");\n            expect(await text.slice(\"0123456789\", -8, -5)).to.equal(\"234\");\n        });\n\n        it(\"should slice till the end of the string if lastIndex is omitted\", async () => {\n            var text = await loadlib(\"text\");\n            expect(await text.slice(\"0123456789\", 4)).to.equal(\"456789\");\n        });\n    });\n\n    describe(\"text.split(str, divider)\", () => {\n\n        it(\"should return the list of `str` substrings between `divider` substrings\", async () => {\n            var text = await loadlib(\"text\");\n            expect(await text.split(\"Abc,def,hij\", \",\")).to.deep.equal([\"Abc\", \"def\", \"hij\"]);\n        });\n    });\n\n    describe(\"text.replace(str, subStr, newSubStr)\", () => {\n\n        it(\"should replace all the occurencies of `subStr` with `newSubStr`\", async () => {\n            var text = await loadlib(\"text\");\n            expect(await text.replace(\"abcXYdefXYghi\", \"XY\", \"Z\")).to.equal(\"abcZdefZghi\");\n        });\n    });\n\n    describe(\"text.trimStart(str)\", () => {\n        it(\"should remove the leading spaces\", async () => {\n            var text = await loadlib(\"text\");\n            expect(await text.trimStart(\"   abc   \")).to.equal(\"abc   \");\n        });\n    });\n\n    describe(\"text.trimEnd(str)\", () => {\n        it(\"should remove the trailing spaces\", async () => {\n            var text = await loadlib(\"text\");\n            expect(await text.trimEnd(\"   abc   \")).to.equal(\"   abc\");\n        });\n    });\n\n    describe(\"text.trim(str)\", () => {\n        it(\"should remove both leading and trailing spaces\", async () => {\n            var text = await loadlib(\"text\");\n            expect(await text.trim(\"   abc   \")).to.equal(\"abc\");\n        });\n    });\n});\n\n\n//# sourceURL=webpack:////home/marcello/mdb/Code/olojs/node_modules/@onlabsorg/swan-js/test/modules/text.js?");

/***/ }),

/***/ "../../node_modules/@onlabsorg/swan-js/test/tuple.js":
/*!***********************************************************************************!*\
  !*** /home/marcello/mdb/Code/olojs/node_modules/@onlabsorg/swan-js/test/tuple.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var expect = __webpack_require__(/*! chai */ \"../../node_modules/chai/index.js\").expect;\nvar {Tuple} = __webpack_require__(/*! ../lib/interpreter */ \"../../node_modules/@onlabsorg/swan-js/lib/interpreter.js\");\n\ndescribe(\"SWAN TUPLE DATA TYPE: tuple = Tuple(...items)\", () => {\n    \n    it(\"should return an instance of Tuple\", () => {\n        expect(Tuple()).to.be.instanceof(Tuple);\n    });\n    \n    it(\"should eturn an iterator object\", () => {\n        var tuple = Tuple();\n        expect(tuple).to.be.instanceof(Tuple);\n    });\n    \n    it(\"should iterate over all the passed iterms\", () => {\n        var tuple = Tuple(10,20,30);\n        expect(tuple).to.be.instanceof(Tuple);\n        expect(Array.from(tuple)).to.deep.equal([10,20,30]);\n    });\n    \n    it(\"should flatten nested tuples\", () => {\n        var tuple1 = Tuple(11,12);\n        var tuple2 = Tuple(10, tuple1);\n        var tuple3 = Tuple(tuple2, 13);\n        expect(tuple3).to.be.instanceof(Tuple);\n        expect(Array.from(tuple3)).to.deep.equal([10,11,12,13]);\n    });\n    \n    it(\"should ignore empty tuples, null, NaN and undefined\", () => {\n        var tuple = Tuple(10,null,20,undefined,30,NaN,40,Tuple());\n        expect(tuple).to.be.instanceof(Tuple);\n        expect(Array.from(tuple)).to.deep.equal([10,20,30,40]);\n    });\n    \n    it(\"should return the argument itself if it is a single tuple\", () => {\n        var tuple = Tuple(1,2,3);\n        expect(Tuple(tuple)).to.equal(tuple);\n    });\n    \n    describe(\"bool = tuple.isEmpty()\", () => {\n        \n        it(\"should return true if the tuple contanis no items\", () => {\n            expect(Tuple().isEmpty()).to.be.true;\n            expect(Tuple(null).isEmpty()).to.be.true;\n            expect(Tuple(NaN).isEmpty()).to.be.true;\n            expect(Tuple(null, NaN, Tuple(null)).isEmpty()).to.be.true;\n\n            expect(Tuple(0).isEmpty()).to.be.false;\n            expect(Tuple(null, NaN, Tuple(1)).isEmpty()).to.be.false;\n        });\n    });\n\n    describe(\"image = await tuple.mapSync(asyncFunc)\", () => {\n        \n        it(\"should resolve a tuple obtaining by applying f to each item of the mapped tuple\", () => {\n            var tuple = Tuple(1,2,3);\n            var tmap = tuple.mapSync(item => 2*item);\n            expect(tmap).to.be.instanceof(Tuple);\n            expect(Array.from(tmap)).to.deep.equal([2,4,6]);\n        });\n        \n        it(\"should treat single items as tuples made of one elements\", () => {\n            var tmap = Tuple(10).mapSync(item => 2*item);\n            expect(tmap).to.be.instanceof(Tuple);\n            expect(Array.from(tmap)).to.deep.equal([20]);            \n\n            var tmap = Tuple(\"abc\").mapSync(item => `_${item}_`);\n            expect(tmap).to.be.instanceof(Tuple);\n            expect(Array.from(tmap)).to.deep.equal([\"_abc_\"]);            \n        });\n        \n        it(\"should resolve an empty tuple if the passed tuple is an empty tuple, null, undefined or NaN\", () => {\n            var tmap = Tuple().mapSync(item => 2*item);\n            expect(tmap).to.be.instanceof(Tuple);\n            expect(Array.from(tmap)).to.deep.equal([]);            \n\n            var tmap = Tuple(null).mapSync(item => 2*item);\n            expect(tmap).to.be.instanceof(Tuple);\n            expect(Array.from(tmap)).to.deep.equal([]);            \n\n            var tmap = Tuple(NaN).mapSync(item => 2*item);\n            expect(tmap).to.be.instanceof(Tuple);\n            expect(Array.from(tmap)).to.deep.equal([]);            \n        });\n    });\n    \n    describe(\"image = await tuple.mapAsync(asyncFunc)\", () => {\n        \n        it(\"should resolve a tuple obtaining by applying f to each item of the mapped tuple\", async () => {\n            var tuple = Tuple(1,2,3);\n            var tmap = await tuple.mapAsync(async item => 2*item);\n            expect(tmap).to.be.instanceof(Tuple);\n            expect(Array.from(tmap)).to.deep.equal([2,4,6]);\n        });\n        \n        it(\"should treat single items as tuples made of one elements\", async () => {\n            var tmap = await Tuple(10).mapAsync(async item => 2*item);\n            expect(tmap).to.be.instanceof(Tuple);\n            expect(Array.from(tmap)).to.deep.equal([20]);            \n\n            var tmap = await Tuple(\"abc\").mapAsync(async item => `_${item}_`);\n            expect(tmap).to.be.instanceof(Tuple);\n            expect(Array.from(tmap)).to.deep.equal([\"_abc_\"]);            \n        });\n        \n        it(\"should resolve an empty tuple if the passed tuple is an empty tuple, null, undefined or NaN\", async () => {\n            var tmap = await Tuple().mapAsync(async item => 2*item);\n            expect(tmap).to.be.instanceof(Tuple);\n            expect(Array.from(tmap)).to.deep.equal([]);            \n\n            var tmap = await Tuple(null).mapAsync(async item => 2*item);\n            expect(tmap).to.be.instanceof(Tuple);\n            expect(Array.from(tmap)).to.deep.equal([]);            \n\n            var tmap = await Tuple(NaN).mapAsync(async item => 2*item);\n            expect(tmap).to.be.instanceof(Tuple);\n            expect(Array.from(tmap)).to.deep.equal([]);            \n        });\n    });\n    \n    describe(\"value = tuple.normalize()\", () => {\n        \n        it(\"should return null if the passed tuple is empty\", () => {\n            expect(Tuple().normalize()).to.be.null;\n            expect(Tuple(null).normalize()).to.be.null;\n            expect(Tuple(NaN).normalize()).to.be.null;\n            expect(Tuple(null, NaN, Tuple(null)).normalize()).to.be.null;\n        });\n\n        it(\"should return the only tuple item if the tuple contains only one item\", () => {\n            expect(Tuple(10).normalize()).to.equal(10);\n            expect(Tuple(null, 10, NaN, undefined).normalize()).to.equal(10);\n            expect(Tuple('abc').normalize()).to.equal('abc');\n            expect(Tuple([1,2,3]).normalize()).to.deep.equal([1,2,3]);\n        });\n        \n        it(\"should return the tuple itself, if it contains more than one item\", () => {\n            var tuple = Tuple(10,20,30);\n            expect(tuple.normalize()).to.equal(tuple);            \n        });\n    });\n});\n\n\n//# sourceURL=webpack:////home/marcello/mdb/Code/olojs/node_modules/@onlabsorg/swan-js/test/tuple.js?");

/***/ }),

/***/ "../../node_modules/assertion-error/index.js":
/*!***************************************************************************!*\
  !*** /home/marcello/mdb/Code/olojs/node_modules/assertion-error/index.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/*!\n * assertion-error\n * Copyright(c) 2013 Jake Luer <jake@qualiancy.com>\n * MIT Licensed\n */\n\n/*!\n * Return a function that will copy properties from\n * one object to another excluding any originally\n * listed. Returned function will create a new `{}`.\n *\n * @param {String} excluded properties ...\n * @return {Function}\n */\n\nfunction exclude () {\n  var excludes = [].slice.call(arguments);\n\n  function excludeProps (res, obj) {\n    Object.keys(obj).forEach(function (key) {\n      if (!~excludes.indexOf(key)) res[key] = obj[key];\n    });\n  }\n\n  return function extendExclude () {\n    var args = [].slice.call(arguments)\n      , i = 0\n      , res = {};\n\n    for (; i < args.length; i++) {\n      excludeProps(res, args[i]);\n    }\n\n    return res;\n  };\n};\n\n/*!\n * Primary Exports\n */\n\nmodule.exports = AssertionError;\n\n/**\n * ### AssertionError\n *\n * An extension of the JavaScript `Error` constructor for\n * assertion and validation scenarios.\n *\n * @param {String} message\n * @param {Object} properties to include (optional)\n * @param {callee} start stack function (optional)\n */\n\nfunction AssertionError (message, _props, ssf) {\n  var extend = exclude('name', 'message', 'stack', 'constructor', 'toJSON')\n    , props = extend(_props || {});\n\n  // default values\n  this.message = message || 'Unspecified AssertionError';\n  this.showDiff = false;\n\n  // copy from properties\n  for (var key in props) {\n    this[key] = props[key];\n  }\n\n  // capture stack trace\n  ssf = ssf || AssertionError;\n  if (Error.captureStackTrace) {\n    Error.captureStackTrace(this, ssf);\n  } else {\n    try {\n      throw new Error();\n    } catch(e) {\n      this.stack = e.stack;\n    }\n  }\n}\n\n/*!\n * Inherit from Error.prototype\n */\n\nAssertionError.prototype = Object.create(Error.prototype);\n\n/*!\n * Statically set name\n */\n\nAssertionError.prototype.name = 'AssertionError';\n\n/*!\n * Ensure correct constructor\n */\n\nAssertionError.prototype.constructor = AssertionError;\n\n/**\n * Allow errors to be converted to JSON for static transfer.\n *\n * @param {Boolean} include stack (default: `true`)\n * @return {Object} object that can be `JSON.stringify`\n */\n\nAssertionError.prototype.toJSON = function (stack) {\n  var extend = exclude('constructor', 'toJSON', 'stack')\n    , props = extend({ name: this.name }, this);\n\n  // include stack if exists and not turned off\n  if (false !== stack && this.stack) {\n    props.stack = this.stack;\n  }\n\n  return props;\n};\n\n\n//# sourceURL=webpack:////home/marcello/mdb/Code/olojs/node_modules/assertion-error/index.js?");

/***/ }),

/***/ "../../node_modules/chai/index.js":
/*!****************************************************************!*\
  !*** /home/marcello/mdb/Code/olojs/node_modules/chai/index.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! ./lib/chai */ \"../../node_modules/chai/lib/chai.js\");\n\n\n//# sourceURL=webpack:////home/marcello/mdb/Code/olojs/node_modules/chai/index.js?");

/***/ }),

/***/ "../../node_modules/chai/lib/chai.js":
/*!*******************************************************************!*\
  !*** /home/marcello/mdb/Code/olojs/node_modules/chai/lib/chai.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/*!\n * chai\n * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\nvar used = [];\n\n/*!\n * Chai version\n */\n\nexports.version = '4.2.0';\n\n/*!\n * Assertion Error\n */\n\nexports.AssertionError = __webpack_require__(/*! assertion-error */ \"../../node_modules/assertion-error/index.js\");\n\n/*!\n * Utils for plugins (not exported)\n */\n\nvar util = __webpack_require__(/*! ./chai/utils */ \"../../node_modules/chai/lib/chai/utils/index.js\");\n\n/**\n * # .use(function)\n *\n * Provides a way to extend the internals of Chai.\n *\n * @param {Function}\n * @returns {this} for chaining\n * @api public\n */\n\nexports.use = function (fn) {\n  if (!~used.indexOf(fn)) {\n    fn(exports, util);\n    used.push(fn);\n  }\n\n  return exports;\n};\n\n/*!\n * Utility Functions\n */\n\nexports.util = util;\n\n/*!\n * Configuration\n */\n\nvar config = __webpack_require__(/*! ./chai/config */ \"../../node_modules/chai/lib/chai/config.js\");\nexports.config = config;\n\n/*!\n * Primary `Assertion` prototype\n */\n\nvar assertion = __webpack_require__(/*! ./chai/assertion */ \"../../node_modules/chai/lib/chai/assertion.js\");\nexports.use(assertion);\n\n/*!\n * Core Assertions\n */\n\nvar core = __webpack_require__(/*! ./chai/core/assertions */ \"../../node_modules/chai/lib/chai/core/assertions.js\");\nexports.use(core);\n\n/*!\n * Expect interface\n */\n\nvar expect = __webpack_require__(/*! ./chai/interface/expect */ \"../../node_modules/chai/lib/chai/interface/expect.js\");\nexports.use(expect);\n\n/*!\n * Should interface\n */\n\nvar should = __webpack_require__(/*! ./chai/interface/should */ \"../../node_modules/chai/lib/chai/interface/should.js\");\nexports.use(should);\n\n/*!\n * Assert interface\n */\n\nvar assert = __webpack_require__(/*! ./chai/interface/assert */ \"../../node_modules/chai/lib/chai/interface/assert.js\");\nexports.use(assert);\n\n\n//# sourceURL=webpack:////home/marcello/mdb/Code/olojs/node_modules/chai/lib/chai.js?");

/***/ }),

/***/ "../../node_modules/chai/lib/chai/assertion.js":
/*!*****************************************************************************!*\
  !*** /home/marcello/mdb/Code/olojs/node_modules/chai/lib/chai/assertion.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/*!\n * chai\n * http://chaijs.com\n * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\nvar config = __webpack_require__(/*! ./config */ \"../../node_modules/chai/lib/chai/config.js\");\n\nmodule.exports = function (_chai, util) {\n  /*!\n   * Module dependencies.\n   */\n\n  var AssertionError = _chai.AssertionError\n    , flag = util.flag;\n\n  /*!\n   * Module export.\n   */\n\n  _chai.Assertion = Assertion;\n\n  /*!\n   * Assertion Constructor\n   *\n   * Creates object for chaining.\n   *\n   * `Assertion` objects contain metadata in the form of flags. Three flags can\n   * be assigned during instantiation by passing arguments to this constructor:\n   *\n   * - `object`: This flag contains the target of the assertion. For example, in\n   *   the assertion `expect(numKittens).to.equal(7);`, the `object` flag will\n   *   contain `numKittens` so that the `equal` assertion can reference it when\n   *   needed.\n   *\n   * - `message`: This flag contains an optional custom error message to be\n   *   prepended to the error message that's generated by the assertion when it\n   *   fails.\n   *\n   * - `ssfi`: This flag stands for \"start stack function indicator\". It\n   *   contains a function reference that serves as the starting point for\n   *   removing frames from the stack trace of the error that's created by the\n   *   assertion when it fails. The goal is to provide a cleaner stack trace to\n   *   end users by removing Chai's internal functions. Note that it only works\n   *   in environments that support `Error.captureStackTrace`, and only when\n   *   `Chai.config.includeStack` hasn't been set to `false`.\n   *\n   * - `lockSsfi`: This flag controls whether or not the given `ssfi` flag\n   *   should retain its current value, even as assertions are chained off of\n   *   this object. This is usually set to `true` when creating a new assertion\n   *   from within another assertion. It's also temporarily set to `true` before\n   *   an overwritten assertion gets called by the overwriting assertion.\n   *\n   * @param {Mixed} obj target of the assertion\n   * @param {String} msg (optional) custom error message\n   * @param {Function} ssfi (optional) starting point for removing stack frames\n   * @param {Boolean} lockSsfi (optional) whether or not the ssfi flag is locked\n   * @api private\n   */\n\n  function Assertion (obj, msg, ssfi, lockSsfi) {\n    flag(this, 'ssfi', ssfi || Assertion);\n    flag(this, 'lockSsfi', lockSsfi);\n    flag(this, 'object', obj);\n    flag(this, 'message', msg);\n\n    return util.proxify(this);\n  }\n\n  Object.defineProperty(Assertion, 'includeStack', {\n    get: function() {\n      console.warn('Assertion.includeStack is deprecated, use chai.config.includeStack instead.');\n      return config.includeStack;\n    },\n    set: function(value) {\n      console.warn('Assertion.includeStack is deprecated, use chai.config.includeStack instead.');\n      config.includeStack = value;\n    }\n  });\n\n  Object.defineProperty(Assertion, 'showDiff', {\n    get: function() {\n      console.warn('Assertion.showDiff is deprecated, use chai.config.showDiff instead.');\n      return config.showDiff;\n    },\n    set: function(value) {\n      console.warn('Assertion.showDiff is deprecated, use chai.config.showDiff instead.');\n      config.showDiff = value;\n    }\n  });\n\n  Assertion.addProperty = function (name, fn) {\n    util.addProperty(this.prototype, name, fn);\n  };\n\n  Assertion.addMethod = function (name, fn) {\n    util.addMethod(this.prototype, name, fn);\n  };\n\n  Assertion.addChainableMethod = function (name, fn, chainingBehavior) {\n    util.addChainableMethod(this.prototype, name, fn, chainingBehavior);\n  };\n\n  Assertion.overwriteProperty = function (name, fn) {\n    util.overwriteProperty(this.prototype, name, fn);\n  };\n\n  Assertion.overwriteMethod = function (name, fn) {\n    util.overwriteMethod(this.prototype, name, fn);\n  };\n\n  Assertion.overwriteChainableMethod = function (name, fn, chainingBehavior) {\n    util.overwriteChainableMethod(this.prototype, name, fn, chainingBehavior);\n  };\n\n  /**\n   * ### .assert(expression, message, negateMessage, expected, actual, showDiff)\n   *\n   * Executes an expression and check expectations. Throws AssertionError for reporting if test doesn't pass.\n   *\n   * @name assert\n   * @param {Philosophical} expression to be tested\n   * @param {String|Function} message or function that returns message to display if expression fails\n   * @param {String|Function} negatedMessage or function that returns negatedMessage to display if negated expression fails\n   * @param {Mixed} expected value (remember to check for negation)\n   * @param {Mixed} actual (optional) will default to `this.obj`\n   * @param {Boolean} showDiff (optional) when set to `true`, assert will display a diff in addition to the message if expression fails\n   * @api private\n   */\n\n  Assertion.prototype.assert = function (expr, msg, negateMsg, expected, _actual, showDiff) {\n    var ok = util.test(this, arguments);\n    if (false !== showDiff) showDiff = true;\n    if (undefined === expected && undefined === _actual) showDiff = false;\n    if (true !== config.showDiff) showDiff = false;\n\n    if (!ok) {\n      msg = util.getMessage(this, arguments);\n      var actual = util.getActual(this, arguments);\n      throw new AssertionError(msg, {\n          actual: actual\n        , expected: expected\n        , showDiff: showDiff\n      }, (config.includeStack) ? this.assert : flag(this, 'ssfi'));\n    }\n  };\n\n  /*!\n   * ### ._obj\n   *\n   * Quick reference to stored `actual` value for plugin developers.\n   *\n   * @api private\n   */\n\n  Object.defineProperty(Assertion.prototype, '_obj',\n    { get: function () {\n        return flag(this, 'object');\n      }\n    , set: function (val) {\n        flag(this, 'object', val);\n      }\n  });\n};\n\n\n//# sourceURL=webpack:////home/marcello/mdb/Code/olojs/node_modules/chai/lib/chai/assertion.js?");

/***/ }),

/***/ "../../node_modules/chai/lib/chai/config.js":
/*!**************************************************************************!*\
  !*** /home/marcello/mdb/Code/olojs/node_modules/chai/lib/chai/config.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = {\n\n  /**\n   * ### config.includeStack\n   *\n   * User configurable property, influences whether stack trace\n   * is included in Assertion error message. Default of false\n   * suppresses stack trace in the error message.\n   *\n   *     chai.config.includeStack = true;  // enable stack on error\n   *\n   * @param {Boolean}\n   * @api public\n   */\n\n  includeStack: false,\n\n  /**\n   * ### config.showDiff\n   *\n   * User configurable property, influences whether or not\n   * the `showDiff` flag should be included in the thrown\n   * AssertionErrors. `false` will always be `false`; `true`\n   * will be true when the assertion has requested a diff\n   * be shown.\n   *\n   * @param {Boolean}\n   * @api public\n   */\n\n  showDiff: true,\n\n  /**\n   * ### config.truncateThreshold\n   *\n   * User configurable property, sets length threshold for actual and\n   * expected values in assertion errors. If this threshold is exceeded, for\n   * example for large data structures, the value is replaced with something\n   * like `[ Array(3) ]` or `{ Object (prop1, prop2) }`.\n   *\n   * Set it to zero if you want to disable truncating altogether.\n   *\n   * This is especially userful when doing assertions on arrays: having this\n   * set to a reasonable large value makes the failure messages readily\n   * inspectable.\n   *\n   *     chai.config.truncateThreshold = 0;  // disable truncating\n   *\n   * @param {Number}\n   * @api public\n   */\n\n  truncateThreshold: 40,\n\n  /**\n   * ### config.useProxy\n   *\n   * User configurable property, defines if chai will use a Proxy to throw\n   * an error when a non-existent property is read, which protects users\n   * from typos when using property-based assertions.\n   *\n   * Set it to false if you want to disable this feature.\n   *\n   *     chai.config.useProxy = false;  // disable use of Proxy\n   *\n   * This feature is automatically disabled regardless of this config value\n   * in environments that don't support proxies.\n   *\n   * @param {Boolean}\n   * @api public\n   */\n\n  useProxy: true,\n\n  /**\n   * ### config.proxyExcludedKeys\n   *\n   * User configurable property, defines which properties should be ignored\n   * instead of throwing an error if they do not exist on the assertion.\n   * This is only applied if the environment Chai is running in supports proxies and\n   * if the `useProxy` configuration setting is enabled.\n   * By default, `then` and `inspect` will not throw an error if they do not exist on the\n   * assertion object because the `.inspect` property is read by `util.inspect` (for example, when\n   * using `console.log` on the assertion object) and `.then` is necessary for promise type-checking.\n   *\n   *     // By default these keys will not throw an error if they do not exist on the assertion object\n   *     chai.config.proxyExcludedKeys = ['then', 'inspect'];\n   *\n   * @param {Array}\n   * @api public\n   */\n\n  proxyExcludedKeys: ['then', 'catch', 'inspect', 'toJSON']\n};\n\n\n//# sourceURL=webpack:////home/marcello/mdb/Code/olojs/node_modules/chai/lib/chai/config.js?");

/***/ }),

/***/ "../../node_modules/chai/lib/chai/core/assertions.js":
/*!***********************************************************************************!*\
  !*** /home/marcello/mdb/Code/olojs/node_modules/chai/lib/chai/core/assertions.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/*!\n * chai\n * http://chaijs.com\n * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\nmodule.exports = function (chai, _) {\n  var Assertion = chai.Assertion\n    , AssertionError = chai.AssertionError\n    , flag = _.flag;\n\n  /**\n   * ### Language Chains\n   *\n   * The following are provided as chainable getters to improve the readability\n   * of your assertions.\n   *\n   * **Chains**\n   *\n   * - to\n   * - be\n   * - been\n   * - is\n   * - that\n   * - which\n   * - and\n   * - has\n   * - have\n   * - with\n   * - at\n   * - of\n   * - same\n   * - but\n   * - does\n   * - still\n   *\n   * @name language chains\n   * @namespace BDD\n   * @api public\n   */\n\n  [ 'to', 'be', 'been', 'is'\n  , 'and', 'has', 'have', 'with'\n  , 'that', 'which', 'at', 'of'\n  , 'same', 'but', 'does', 'still' ].forEach(function (chain) {\n    Assertion.addProperty(chain);\n  });\n\n  /**\n   * ### .not\n   *\n   * Negates all assertions that follow in the chain.\n   *\n   *     expect(function () {}).to.not.throw();\n   *     expect({a: 1}).to.not.have.property('b');\n   *     expect([1, 2]).to.be.an('array').that.does.not.include(3);\n   *\n   * Just because you can negate any assertion with `.not` doesn't mean you\n   * should. With great power comes great responsibility. It's often best to\n   * assert that the one expected output was produced, rather than asserting\n   * that one of countless unexpected outputs wasn't produced. See individual\n   * assertions for specific guidance.\n   *\n   *     expect(2).to.equal(2); // Recommended\n   *     expect(2).to.not.equal(1); // Not recommended\n   *\n   * @name not\n   * @namespace BDD\n   * @api public\n   */\n\n  Assertion.addProperty('not', function () {\n    flag(this, 'negate', true);\n  });\n\n  /**\n   * ### .deep\n   *\n   * Causes all `.equal`, `.include`, `.members`, `.keys`, and `.property`\n   * assertions that follow in the chain to use deep equality instead of strict\n   * (`===`) equality. See the `deep-eql` project page for info on the deep\n   * equality algorithm: https://github.com/chaijs/deep-eql.\n   *\n   *     // Target object deeply (but not strictly) equals `{a: 1}`\n   *     expect({a: 1}).to.deep.equal({a: 1});\n   *     expect({a: 1}).to.not.equal({a: 1});\n   *\n   *     // Target array deeply (but not strictly) includes `{a: 1}`\n   *     expect([{a: 1}]).to.deep.include({a: 1});\n   *     expect([{a: 1}]).to.not.include({a: 1});\n   *\n   *     // Target object deeply (but not strictly) includes `x: {a: 1}`\n   *     expect({x: {a: 1}}).to.deep.include({x: {a: 1}});\n   *     expect({x: {a: 1}}).to.not.include({x: {a: 1}});\n   *\n   *     // Target array deeply (but not strictly) has member `{a: 1}`\n   *     expect([{a: 1}]).to.have.deep.members([{a: 1}]);\n   *     expect([{a: 1}]).to.not.have.members([{a: 1}]);\n   *\n   *     // Target set deeply (but not strictly) has key `{a: 1}`\n   *     expect(new Set([{a: 1}])).to.have.deep.keys([{a: 1}]);\n   *     expect(new Set([{a: 1}])).to.not.have.keys([{a: 1}]);\n   *\n   *     // Target object deeply (but not strictly) has property `x: {a: 1}`\n   *     expect({x: {a: 1}}).to.have.deep.property('x', {a: 1});\n   *     expect({x: {a: 1}}).to.not.have.property('x', {a: 1});\n   *\n   * @name deep\n   * @namespace BDD\n   * @api public\n   */\n\n  Assertion.addProperty('deep', function () {\n    flag(this, 'deep', true);\n  });\n\n  /**\n   * ### .nested\n   *\n   * Enables dot- and bracket-notation in all `.property` and `.include`\n   * assertions that follow in the chain.\n   *\n   *     expect({a: {b: ['x', 'y']}}).to.have.nested.property('a.b[1]');\n   *     expect({a: {b: ['x', 'y']}}).to.nested.include({'a.b[1]': 'y'});\n   *\n   * If `.` or `[]` are part of an actual property name, they can be escaped by\n   * adding two backslashes before them.\n   *\n   *     expect({'.a': {'[b]': 'x'}}).to.have.nested.property('\\\\.a.\\\\[b\\\\]');\n   *     expect({'.a': {'[b]': 'x'}}).to.nested.include({'\\\\.a.\\\\[b\\\\]': 'x'});\n   *\n   * `.nested` cannot be combined with `.own`.\n   *\n   * @name nested\n   * @namespace BDD\n   * @api public\n   */\n\n  Assertion.addProperty('nested', function () {\n    flag(this, 'nested', true);\n  });\n\n  /**\n   * ### .own\n   *\n   * Causes all `.property` and `.include` assertions that follow in the chain\n   * to ignore inherited properties.\n   *\n   *     Object.prototype.b = 2;\n   *\n   *     expect({a: 1}).to.have.own.property('a');\n   *     expect({a: 1}).to.have.property('b');\n   *     expect({a: 1}).to.not.have.own.property('b');\n   *\n   *     expect({a: 1}).to.own.include({a: 1});\n   *     expect({a: 1}).to.include({b: 2}).but.not.own.include({b: 2});\n   *\n   * `.own` cannot be combined with `.nested`.\n   *\n   * @name own\n   * @namespace BDD\n   * @api public\n   */\n\n  Assertion.addProperty('own', function () {\n    flag(this, 'own', true);\n  });\n\n  /**\n   * ### .ordered\n   *\n   * Causes all `.members` assertions that follow in the chain to require that\n   * members be in the same order.\n   *\n   *     expect([1, 2]).to.have.ordered.members([1, 2])\n   *       .but.not.have.ordered.members([2, 1]);\n   *\n   * When `.include` and `.ordered` are combined, the ordering begins at the\n   * start of both arrays.\n   *\n   *     expect([1, 2, 3]).to.include.ordered.members([1, 2])\n   *       .but.not.include.ordered.members([2, 3]);\n   *\n   * @name ordered\n   * @namespace BDD\n   * @api public\n   */\n\n  Assertion.addProperty('ordered', function () {\n    flag(this, 'ordered', true);\n  });\n\n  /**\n   * ### .any\n   *\n   * Causes all `.keys` assertions that follow in the chain to only require that\n   * the target have at least one of the given keys. This is the opposite of\n   * `.all`, which requires that the target have all of the given keys.\n   *\n   *     expect({a: 1, b: 2}).to.not.have.any.keys('c', 'd');\n   *\n   * See the `.keys` doc for guidance on when to use `.any` or `.all`.\n   *\n   * @name any\n   * @namespace BDD\n   * @api public\n   */\n\n  Assertion.addProperty('any', function () {\n    flag(this, 'any', true);\n    flag(this, 'all', false);\n  });\n\n  /**\n   * ### .all\n   *\n   * Causes all `.keys` assertions that follow in the chain to require that the\n   * target have all of the given keys. This is the opposite of `.any`, which\n   * only requires that the target have at least one of the given keys.\n   *\n   *     expect({a: 1, b: 2}).to.have.all.keys('a', 'b');\n   *\n   * Note that `.all` is used by default when neither `.all` nor `.any` are\n   * added earlier in the chain. However, it's often best to add `.all` anyway\n   * because it improves readability.\n   *\n   * See the `.keys` doc for guidance on when to use `.any` or `.all`.\n   *\n   * @name all\n   * @namespace BDD\n   * @api public\n   */\n\n  Assertion.addProperty('all', function () {\n    flag(this, 'all', true);\n    flag(this, 'any', false);\n  });\n\n  /**\n   * ### .a(type[, msg])\n   *\n   * Asserts that the target's type is equal to the given string `type`. Types\n   * are case insensitive. See the `type-detect` project page for info on the\n   * type detection algorithm: https://github.com/chaijs/type-detect.\n   *\n   *     expect('foo').to.be.a('string');\n   *     expect({a: 1}).to.be.an('object');\n   *     expect(null).to.be.a('null');\n   *     expect(undefined).to.be.an('undefined');\n   *     expect(new Error).to.be.an('error');\n   *     expect(Promise.resolve()).to.be.a('promise');\n   *     expect(new Float32Array).to.be.a('float32array');\n   *     expect(Symbol()).to.be.a('symbol');\n   *\n   * `.a` supports objects that have a custom type set via `Symbol.toStringTag`.\n   *\n   *     var myObj = {\n   *       [Symbol.toStringTag]: 'myCustomType'\n   *     };\n   *\n   *     expect(myObj).to.be.a('myCustomType').but.not.an('object');\n   *\n   * It's often best to use `.a` to check a target's type before making more\n   * assertions on the same target. That way, you avoid unexpected behavior from\n   * any assertion that does different things based on the target's type.\n   *\n   *     expect([1, 2, 3]).to.be.an('array').that.includes(2);\n   *     expect([]).to.be.an('array').that.is.empty;\n   *\n   * Add `.not` earlier in the chain to negate `.a`. However, it's often best to\n   * assert that the target is the expected type, rather than asserting that it\n   * isn't one of many unexpected types.\n   *\n   *     expect('foo').to.be.a('string'); // Recommended\n   *     expect('foo').to.not.be.an('array'); // Not recommended\n   *\n   * `.a` accepts an optional `msg` argument which is a custom error message to\n   * show when the assertion fails. The message can also be given as the second\n   * argument to `expect`.\n   *\n   *     expect(1).to.be.a('string', 'nooo why fail??');\n   *     expect(1, 'nooo why fail??').to.be.a('string');\n   *\n   * `.a` can also be used as a language chain to improve the readability of\n   * your assertions.\n   *\n   *     expect({b: 2}).to.have.a.property('b');\n   *\n   * The alias `.an` can be used interchangeably with `.a`.\n   *\n   * @name a\n   * @alias an\n   * @param {String} type\n   * @param {String} msg _optional_\n   * @namespace BDD\n   * @api public\n   */\n\n  function an (type, msg) {\n    if (msg) flag(this, 'message', msg);\n    type = type.toLowerCase();\n    var obj = flag(this, 'object')\n      , article = ~[ 'a', 'e', 'i', 'o', 'u' ].indexOf(type.charAt(0)) ? 'an ' : 'a ';\n\n    this.assert(\n        type === _.type(obj).toLowerCase()\n      , 'expected #{this} to be ' + article + type\n      , 'expected #{this} not to be ' + article + type\n    );\n  }\n\n  Assertion.addChainableMethod('an', an);\n  Assertion.addChainableMethod('a', an);\n\n  /**\n   * ### .include(val[, msg])\n   *\n   * When the target is a string, `.include` asserts that the given string `val`\n   * is a substring of the target.\n   *\n   *     expect('foobar').to.include('foo');\n   *\n   * When the target is an array, `.include` asserts that the given `val` is a\n   * member of the target.\n   *\n   *     expect([1, 2, 3]).to.include(2);\n   *\n   * When the target is an object, `.include` asserts that the given object\n   * `val`'s properties are a subset of the target's properties.\n   *\n   *     expect({a: 1, b: 2, c: 3}).to.include({a: 1, b: 2});\n   *\n   * When the target is a Set or WeakSet, `.include` asserts that the given `val` is a\n   * member of the target. SameValueZero equality algorithm is used.\n   *\n   *     expect(new Set([1, 2])).to.include(2);\n   *\n   * When the target is a Map, `.include` asserts that the given `val` is one of\n   * the values of the target. SameValueZero equality algorithm is used.\n   *\n   *     expect(new Map([['a', 1], ['b', 2]])).to.include(2);\n   *\n   * Because `.include` does different things based on the target's type, it's\n   * important to check the target's type before using `.include`. See the `.a`\n   * doc for info on testing a target's type.\n   *\n   *     expect([1, 2, 3]).to.be.an('array').that.includes(2);\n   *\n   * By default, strict (`===`) equality is used to compare array members and\n   * object properties. Add `.deep` earlier in the chain to use deep equality\n   * instead (WeakSet targets are not supported). See the `deep-eql` project\n   * page for info on the deep equality algorithm: https://github.com/chaijs/deep-eql.\n   *\n   *     // Target array deeply (but not strictly) includes `{a: 1}`\n   *     expect([{a: 1}]).to.deep.include({a: 1});\n   *     expect([{a: 1}]).to.not.include({a: 1});\n   *\n   *     // Target object deeply (but not strictly) includes `x: {a: 1}`\n   *     expect({x: {a: 1}}).to.deep.include({x: {a: 1}});\n   *     expect({x: {a: 1}}).to.not.include({x: {a: 1}});\n   *\n   * By default, all of the target's properties are searched when working with\n   * objects. This includes properties that are inherited and/or non-enumerable.\n   * Add `.own` earlier in the chain to exclude the target's inherited\n   * properties from the search.\n   *\n   *     Object.prototype.b = 2;\n   *\n   *     expect({a: 1}).to.own.include({a: 1});\n   *     expect({a: 1}).to.include({b: 2}).but.not.own.include({b: 2});\n   *\n   * Note that a target object is always only searched for `val`'s own\n   * enumerable properties.\n   *\n   * `.deep` and `.own` can be combined.\n   *\n   *     expect({a: {b: 2}}).to.deep.own.include({a: {b: 2}});\n   *\n   * Add `.nested` earlier in the chain to enable dot- and bracket-notation when\n   * referencing nested properties.\n   *\n   *     expect({a: {b: ['x', 'y']}}).to.nested.include({'a.b[1]': 'y'});\n   *\n   * If `.` or `[]` are part of an actual property name, they can be escaped by\n   * adding two backslashes before them.\n   *\n   *     expect({'.a': {'[b]': 2}}).to.nested.include({'\\\\.a.\\\\[b\\\\]': 2});\n   *\n   * `.deep` and `.nested` can be combined.\n   *\n   *     expect({a: {b: [{c: 3}]}}).to.deep.nested.include({'a.b[0]': {c: 3}});\n   *\n   * `.own` and `.nested` cannot be combined.\n   *\n   * Add `.not` earlier in the chain to negate `.include`.\n   *\n   *     expect('foobar').to.not.include('taco');\n   *     expect([1, 2, 3]).to.not.include(4);\n   *\n   * However, it's dangerous to negate `.include` when the target is an object.\n   * The problem is that it creates uncertain expectations by asserting that the\n   * target object doesn't have all of `val`'s key/value pairs but may or may\n   * not have some of them. It's often best to identify the exact output that's\n   * expected, and then write an assertion that only accepts that exact output.\n   *\n   * When the target object isn't even expected to have `val`'s keys, it's\n   * often best to assert exactly that.\n   *\n   *     expect({c: 3}).to.not.have.any.keys('a', 'b'); // Recommended\n   *     expect({c: 3}).to.not.include({a: 1, b: 2}); // Not recommended\n   *\n   * When the target object is expected to have `val`'s keys, it's often best to\n   * assert that each of the properties has its expected value, rather than\n   * asserting that each property doesn't have one of many unexpected values.\n   *\n   *     expect({a: 3, b: 4}).to.include({a: 3, b: 4}); // Recommended\n   *     expect({a: 3, b: 4}).to.not.include({a: 1, b: 2}); // Not recommended\n   *\n   * `.include` accepts an optional `msg` argument which is a custom error\n   * message to show when the assertion fails. The message can also be given as\n   * the second argument to `expect`.\n   *\n   *     expect([1, 2, 3]).to.include(4, 'nooo why fail??');\n   *     expect([1, 2, 3], 'nooo why fail??').to.include(4);\n   *\n   * `.include` can also be used as a language chain, causing all `.members` and\n   * `.keys` assertions that follow in the chain to require the target to be a\n   * superset of the expected set, rather than an identical set. Note that\n   * `.members` ignores duplicates in the subset when `.include` is added.\n   *\n   *     // Target object's keys are a superset of ['a', 'b'] but not identical\n   *     expect({a: 1, b: 2, c: 3}).to.include.all.keys('a', 'b');\n   *     expect({a: 1, b: 2, c: 3}).to.not.have.all.keys('a', 'b');\n   *\n   *     // Target array is a superset of [1, 2] but not identical\n   *     expect([1, 2, 3]).to.include.members([1, 2]);\n   *     expect([1, 2, 3]).to.not.have.members([1, 2]);\n   *\n   *     // Duplicates in the subset are ignored\n   *     expect([1, 2, 3]).to.include.members([1, 2, 2, 2]);\n   *\n   * Note that adding `.any` earlier in the chain causes the `.keys` assertion\n   * to ignore `.include`.\n   *\n   *     // Both assertions are identical\n   *     expect({a: 1}).to.include.any.keys('a', 'b');\n   *     expect({a: 1}).to.have.any.keys('a', 'b');\n   *\n   * The aliases `.includes`, `.contain`, and `.contains` can be used\n   * interchangeably with `.include`.\n   *\n   * @name include\n   * @alias contain\n   * @alias includes\n   * @alias contains\n   * @param {Mixed} val\n   * @param {String} msg _optional_\n   * @namespace BDD\n   * @api public\n   */\n\n  function SameValueZero(a, b) {\n    return (_.isNaN(a) && _.isNaN(b)) || a === b;\n  }\n\n  function includeChainingBehavior () {\n    flag(this, 'contains', true);\n  }\n\n  function include (val, msg) {\n    if (msg) flag(this, 'message', msg);\n\n    var obj = flag(this, 'object')\n      , objType = _.type(obj).toLowerCase()\n      , flagMsg = flag(this, 'message')\n      , negate = flag(this, 'negate')\n      , ssfi = flag(this, 'ssfi')\n      , isDeep = flag(this, 'deep')\n      , descriptor = isDeep ? 'deep ' : '';\n\n    flagMsg = flagMsg ? flagMsg + ': ' : '';\n\n    var included = false;\n\n    switch (objType) {\n      case 'string':\n        included = obj.indexOf(val) !== -1;\n        break;\n\n      case 'weakset':\n        if (isDeep) {\n          throw new AssertionError(\n            flagMsg + 'unable to use .deep.include with WeakSet',\n            undefined,\n            ssfi\n          );\n        }\n\n        included = obj.has(val);\n        break;\n\n      case 'map':\n        var isEql = isDeep ? _.eql : SameValueZero;\n        obj.forEach(function (item) {\n          included = included || isEql(item, val);\n        });\n        break;\n\n      case 'set':\n        if (isDeep) {\n          obj.forEach(function (item) {\n            included = included || _.eql(item, val);\n          });\n        } else {\n          included = obj.has(val);\n        }\n        break;\n\n      case 'array':\n        if (isDeep) {\n          included = obj.some(function (item) {\n            return _.eql(item, val);\n          })\n        } else {\n          included = obj.indexOf(val) !== -1;\n        }\n        break;\n\n      default:\n        // This block is for asserting a subset of properties in an object.\n        // `_.expectTypes` isn't used here because `.include` should work with\n        // objects with a custom `@@toStringTag`.\n        if (val !== Object(val)) {\n          throw new AssertionError(\n            flagMsg + 'object tested must be an array, a map, an object,'\n              + ' a set, a string, or a weakset, but ' + objType + ' given',\n            undefined,\n            ssfi\n          );\n        }\n\n        var props = Object.keys(val)\n          , firstErr = null\n          , numErrs = 0;\n\n        props.forEach(function (prop) {\n          var propAssertion = new Assertion(obj);\n          _.transferFlags(this, propAssertion, true);\n          flag(propAssertion, 'lockSsfi', true);\n\n          if (!negate || props.length === 1) {\n            propAssertion.property(prop, val[prop]);\n            return;\n          }\n\n          try {\n            propAssertion.property(prop, val[prop]);\n          } catch (err) {\n            if (!_.checkError.compatibleConstructor(err, AssertionError)) {\n              throw err;\n            }\n            if (firstErr === null) firstErr = err;\n            numErrs++;\n          }\n        }, this);\n\n        // When validating .not.include with multiple properties, we only want\n        // to throw an assertion error if all of the properties are included,\n        // in which case we throw the first property assertion error that we\n        // encountered.\n        if (negate && props.length > 1 && numErrs === props.length) {\n          throw firstErr;\n        }\n        return;\n    }\n\n    // Assert inclusion in collection or substring in a string.\n    this.assert(\n      included\n      , 'expected #{this} to ' + descriptor + 'include ' + _.inspect(val)\n      , 'expected #{this} to not ' + descriptor + 'include ' + _.inspect(val));\n  }\n\n  Assertion.addChainableMethod('include', include, includeChainingBehavior);\n  Assertion.addChainableMethod('contain', include, includeChainingBehavior);\n  Assertion.addChainableMethod('contains', include, includeChainingBehavior);\n  Assertion.addChainableMethod('includes', include, includeChainingBehavior);\n\n  /**\n   * ### .ok\n   *\n   * Asserts that the target is a truthy value (considered `true` in boolean context).\n   * However, it's often best to assert that the target is strictly (`===`) or\n   * deeply equal to its expected value.\n   *\n   *     expect(1).to.equal(1); // Recommended\n   *     expect(1).to.be.ok; // Not recommended\n   *\n   *     expect(true).to.be.true; // Recommended\n   *     expect(true).to.be.ok; // Not recommended\n   *\n   * Add `.not` earlier in the chain to negate `.ok`.\n   *\n   *     expect(0).to.equal(0); // Recommended\n   *     expect(0).to.not.be.ok; // Not recommended\n   *\n   *     expect(false).to.be.false; // Recommended\n   *     expect(false).to.not.be.ok; // Not recommended\n   *\n   *     expect(null).to.be.null; // Recommended\n   *     expect(null).to.not.be.ok; // Not recommended\n   *\n   *     expect(undefined).to.be.undefined; // Recommended\n   *     expect(undefined).to.not.be.ok; // Not recommended\n   *\n   * A custom error message can be given as the second argument to `expect`.\n   *\n   *     expect(false, 'nooo why fail??').to.be.ok;\n   *\n   * @name ok\n   * @namespace BDD\n   * @api public\n   */\n\n  Assertion.addProperty('ok', function () {\n    this.assert(\n        flag(this, 'object')\n      , 'expected #{this} to be truthy'\n      , 'expected #{this} to be falsy');\n  });\n\n  /**\n   * ### .true\n   *\n   * Asserts that the target is strictly (`===`) equal to `true`.\n   *\n   *     expect(true).to.be.true;\n   *\n   * Add `.not` earlier in the chain to negate `.true`. However, it's often best\n   * to assert that the target is equal to its expected value, rather than not\n   * equal to `true`.\n   *\n   *     expect(false).to.be.false; // Recommended\n   *     expect(false).to.not.be.true; // Not recommended\n   *\n   *     expect(1).to.equal(1); // Recommended\n   *     expect(1).to.not.be.true; // Not recommended\n   *\n   * A custom error message can be given as the second argument to `expect`.\n   *\n   *     expect(false, 'nooo why fail??').to.be.true;\n   *\n   * @name true\n   * @namespace BDD\n   * @api public\n   */\n\n  Assertion.addProperty('true', function () {\n    this.assert(\n        true === flag(this, 'object')\n      , 'expected #{this} to be true'\n      , 'expected #{this} to be false'\n      , flag(this, 'negate') ? false : true\n    );\n  });\n\n  /**\n   * ### .false\n   *\n   * Asserts that the target is strictly (`===`) equal to `false`.\n   *\n   *     expect(false).to.be.false;\n   *\n   * Add `.not` earlier in the chain to negate `.false`. However, it's often\n   * best to assert that the target is equal to its expected value, rather than\n   * not equal to `false`.\n   *\n   *     expect(true).to.be.true; // Recommended\n   *     expect(true).to.not.be.false; // Not recommended\n   *\n   *     expect(1).to.equal(1); // Recommended\n   *     expect(1).to.not.be.false; // Not recommended\n   *\n   * A custom error message can be given as the second argument to `expect`.\n   *\n   *     expect(true, 'nooo why fail??').to.be.false;\n   *\n   * @name false\n   * @namespace BDD\n   * @api public\n   */\n\n  Assertion.addProperty('false', function () {\n    this.assert(\n        false === flag(this, 'object')\n      , 'expected #{this} to be false'\n      , 'expected #{this} to be true'\n      , flag(this, 'negate') ? true : false\n    );\n  });\n\n  /**\n   * ### .null\n   *\n   * Asserts that the target is strictly (`===`) equal to `null`.\n   *\n   *     expect(null).to.be.null;\n   *\n   * Add `.not` earlier in the chain to negate `.null`. However, it's often best\n   * to assert that the target is equal to its expected value, rather than not\n   * equal to `null`.\n   *\n   *     expect(1).to.equal(1); // Recommended\n   *     expect(1).to.not.be.null; // Not recommended\n   *\n   * A custom error message can be given as the second argument to `expect`.\n   *\n   *     expect(42, 'nooo why fail??').to.be.null;\n   *\n   * @name null\n   * @namespace BDD\n   * @api public\n   */\n\n  Assertion.addProperty('null', function () {\n    this.assert(\n        null === flag(this, 'object')\n      , 'expected #{this} to be null'\n      , 'expected #{this} not to be null'\n    );\n  });\n\n  /**\n   * ### .undefined\n   *\n   * Asserts that the target is strictly (`===`) equal to `undefined`.\n   *\n   *     expect(undefined).to.be.undefined;\n   *\n   * Add `.not` earlier in the chain to negate `.undefined`. However, it's often\n   * best to assert that the target is equal to its expected value, rather than\n   * not equal to `undefined`.\n   *\n   *     expect(1).to.equal(1); // Recommended\n   *     expect(1).to.not.be.undefined; // Not recommended\n   *\n   * A custom error message can be given as the second argument to `expect`.\n   *\n   *     expect(42, 'nooo why fail??').to.be.undefined;\n   *\n   * @name undefined\n   * @namespace BDD\n   * @api public\n   */\n\n  Assertion.addProperty('undefined', function () {\n    this.assert(\n        undefined === flag(this, 'object')\n      , 'expected #{this} to be undefined'\n      , 'expected #{this} not to be undefined'\n    );\n  });\n\n  /**\n   * ### .NaN\n   *\n   * Asserts that the target is exactly `NaN`.\n   *\n   *     expect(NaN).to.be.NaN;\n   *\n   * Add `.not` earlier in the chain to negate `.NaN`. However, it's often best\n   * to assert that the target is equal to its expected value, rather than not\n   * equal to `NaN`.\n   *\n   *     expect('foo').to.equal('foo'); // Recommended\n   *     expect('foo').to.not.be.NaN; // Not recommended\n   *\n   * A custom error message can be given as the second argument to `expect`.\n   *\n   *     expect(42, 'nooo why fail??').to.be.NaN;\n   *\n   * @name NaN\n   * @namespace BDD\n   * @api public\n   */\n\n  Assertion.addProperty('NaN', function () {\n    this.assert(\n        _.isNaN(flag(this, 'object'))\n        , 'expected #{this} to be NaN'\n        , 'expected #{this} not to be NaN'\n    );\n  });\n\n  /**\n   * ### .exist\n   *\n   * Asserts that the target is not strictly (`===`) equal to either `null` or\n   * `undefined`. However, it's often best to assert that the target is equal to\n   * its expected value.\n   *\n   *     expect(1).to.equal(1); // Recommended\n   *     expect(1).to.exist; // Not recommended\n   *\n   *     expect(0).to.equal(0); // Recommended\n   *     expect(0).to.exist; // Not recommended\n   *\n   * Add `.not` earlier in the chain to negate `.exist`.\n   *\n   *     expect(null).to.be.null; // Recommended\n   *     expect(null).to.not.exist; // Not recommended\n   *\n   *     expect(undefined).to.be.undefined; // Recommended\n   *     expect(undefined).to.not.exist; // Not recommended\n   *\n   * A custom error message can be given as the second argument to `expect`.\n   *\n   *     expect(null, 'nooo why fail??').to.exist;\n   *\n   * @name exist\n   * @namespace BDD\n   * @api public\n   */\n\n  Assertion.addProperty('exist', function () {\n    var val = flag(this, 'object');\n    this.assert(\n        val !== null && val !== undefined\n      , 'expected #{this} to exist'\n      , 'expected #{this} to not exist'\n    );\n  });\n\n  /**\n   * ### .empty\n   *\n   * When the target is a string or array, `.empty` asserts that the target's\n   * `length` property is strictly (`===`) equal to `0`.\n   *\n   *     expect([]).to.be.empty;\n   *     expect('').to.be.empty;\n   *\n   * When the target is a map or set, `.empty` asserts that the target's `size`\n   * property is strictly equal to `0`.\n   *\n   *     expect(new Set()).to.be.empty;\n   *     expect(new Map()).to.be.empty;\n   *\n   * When the target is a non-function object, `.empty` asserts that the target\n   * doesn't have any own enumerable properties. Properties with Symbol-based\n   * keys are excluded from the count.\n   *\n   *     expect({}).to.be.empty;\n   *\n   * Because `.empty` does different things based on the target's type, it's\n   * important to check the target's type before using `.empty`. See the `.a`\n   * doc for info on testing a target's type.\n   *\n   *     expect([]).to.be.an('array').that.is.empty;\n   *\n   * Add `.not` earlier in the chain to negate `.empty`. However, it's often\n   * best to assert that the target contains its expected number of values,\n   * rather than asserting that it's not empty.\n   *\n   *     expect([1, 2, 3]).to.have.lengthOf(3); // Recommended\n   *     expect([1, 2, 3]).to.not.be.empty; // Not recommended\n   *\n   *     expect(new Set([1, 2, 3])).to.have.property('size', 3); // Recommended\n   *     expect(new Set([1, 2, 3])).to.not.be.empty; // Not recommended\n   *\n   *     expect(Object.keys({a: 1})).to.have.lengthOf(1); // Recommended\n   *     expect({a: 1}).to.not.be.empty; // Not recommended\n   *\n   * A custom error message can be given as the second argument to `expect`.\n   *\n   *     expect([1, 2, 3], 'nooo why fail??').to.be.empty;\n   *\n   * @name empty\n   * @namespace BDD\n   * @api public\n   */\n\n  Assertion.addProperty('empty', function () {\n    var val = flag(this, 'object')\n      , ssfi = flag(this, 'ssfi')\n      , flagMsg = flag(this, 'message')\n      , itemsCount;\n\n    flagMsg = flagMsg ? flagMsg + ': ' : '';\n\n    switch (_.type(val).toLowerCase()) {\n      case 'array':\n      case 'string':\n        itemsCount = val.length;\n        break;\n      case 'map':\n      case 'set':\n        itemsCount = val.size;\n        break;\n      case 'weakmap':\n      case 'weakset':\n        throw new AssertionError(\n          flagMsg + '.empty was passed a weak collection',\n          undefined,\n          ssfi\n        );\n      case 'function':\n        var msg = flagMsg + '.empty was passed a function ' + _.getName(val);\n        throw new AssertionError(msg.trim(), undefined, ssfi);\n      default:\n        if (val !== Object(val)) {\n          throw new AssertionError(\n            flagMsg + '.empty was passed non-string primitive ' + _.inspect(val),\n            undefined,\n            ssfi\n          );\n        }\n        itemsCount = Object.keys(val).length;\n    }\n\n    this.assert(\n        0 === itemsCount\n      , 'expected #{this} to be empty'\n      , 'expected #{this} not to be empty'\n    );\n  });\n\n  /**\n   * ### .arguments\n   *\n   * Asserts that the target is an `arguments` object.\n   *\n   *     function test () {\n   *       expect(arguments).to.be.arguments;\n   *     }\n   *\n   *     test();\n   *\n   * Add `.not` earlier in the chain to negate `.arguments`. However, it's often\n   * best to assert which type the target is expected to be, rather than\n   * asserting that its not an `arguments` object.\n   *\n   *     expect('foo').to.be.a('string'); // Recommended\n   *     expect('foo').to.not.be.arguments; // Not recommended\n   *\n   * A custom error message can be given as the second argument to `expect`.\n   *\n   *     expect({}, 'nooo why fail??').to.be.arguments;\n   *\n   * The alias `.Arguments` can be used interchangeably with `.arguments`.\n   *\n   * @name arguments\n   * @alias Arguments\n   * @namespace BDD\n   * @api public\n   */\n\n  function checkArguments () {\n    var obj = flag(this, 'object')\n      , type = _.type(obj);\n    this.assert(\n        'Arguments' === type\n      , 'expected #{this} to be arguments but got ' + type\n      , 'expected #{this} to not be arguments'\n    );\n  }\n\n  Assertion.addProperty('arguments', checkArguments);\n  Assertion.addProperty('Arguments', checkArguments);\n\n  /**\n   * ### .equal(val[, msg])\n   *\n   * Asserts that the target is strictly (`===`) equal to the given `val`.\n   *\n   *     expect(1).to.equal(1);\n   *     expect('foo').to.equal('foo');\n   *\n   * Add `.deep` earlier in the chain to use deep equality instead. See the\n   * `deep-eql` project page for info on the deep equality algorithm:\n   * https://github.com/chaijs/deep-eql.\n   *\n   *     // Target object deeply (but not strictly) equals `{a: 1}`\n   *     expect({a: 1}).to.deep.equal({a: 1});\n   *     expect({a: 1}).to.not.equal({a: 1});\n   *\n   *     // Target array deeply (but not strictly) equals `[1, 2]`\n   *     expect([1, 2]).to.deep.equal([1, 2]);\n   *     expect([1, 2]).to.not.equal([1, 2]);\n   *\n   * Add `.not` earlier in the chain to negate `.equal`. However, it's often\n   * best to assert that the target is equal to its expected value, rather than\n   * not equal to one of countless unexpected values.\n   *\n   *     expect(1).to.equal(1); // Recommended\n   *     expect(1).to.not.equal(2); // Not recommended\n   *\n   * `.equal` accepts an optional `msg` argument which is a custom error message\n   * to show when the assertion fails. The message can also be given as the\n   * second argument to `expect`.\n   *\n   *     expect(1).to.equal(2, 'nooo why fail??');\n   *     expect(1, 'nooo why fail??').to.equal(2);\n   *\n   * The aliases `.equals` and `eq` can be used interchangeably with `.equal`.\n   *\n   * @name equal\n   * @alias equals\n   * @alias eq\n   * @param {Mixed} val\n   * @param {String} msg _optional_\n   * @namespace BDD\n   * @api public\n   */\n\n  function assertEqual (val, msg) {\n    if (msg) flag(this, 'message', msg);\n    var obj = flag(this, 'object');\n    if (flag(this, 'deep')) {\n      var prevLockSsfi = flag(this, 'lockSsfi');\n      flag(this, 'lockSsfi', true);\n      this.eql(val);\n      flag(this, 'lockSsfi', prevLockSsfi);\n    } else {\n      this.assert(\n          val === obj\n        , 'expected #{this} to equal #{exp}'\n        , 'expected #{this} to not equal #{exp}'\n        , val\n        , this._obj\n        , true\n      );\n    }\n  }\n\n  Assertion.addMethod('equal', assertEqual);\n  Assertion.addMethod('equals', assertEqual);\n  Assertion.addMethod('eq', assertEqual);\n\n  /**\n   * ### .eql(obj[, msg])\n   *\n   * Asserts that the target is deeply equal to the given `obj`. See the\n   * `deep-eql` project page for info on the deep equality algorithm:\n   * https://github.com/chaijs/deep-eql.\n   *\n   *     // Target object is deeply (but not strictly) equal to {a: 1}\n   *     expect({a: 1}).to.eql({a: 1}).but.not.equal({a: 1});\n   *\n   *     // Target array is deeply (but not strictly) equal to [1, 2]\n   *     expect([1, 2]).to.eql([1, 2]).but.not.equal([1, 2]);\n   *\n   * Add `.not` earlier in the chain to negate `.eql`. However, it's often best\n   * to assert that the target is deeply equal to its expected value, rather\n   * than not deeply equal to one of countless unexpected values.\n   *\n   *     expect({a: 1}).to.eql({a: 1}); // Recommended\n   *     expect({a: 1}).to.not.eql({b: 2}); // Not recommended\n   *\n   * `.eql` accepts an optional `msg` argument which is a custom error message\n   * to show when the assertion fails. The message can also be given as the\n   * second argument to `expect`.\n   *\n   *     expect({a: 1}).to.eql({b: 2}, 'nooo why fail??');\n   *     expect({a: 1}, 'nooo why fail??').to.eql({b: 2});\n   *\n   * The alias `.eqls` can be used interchangeably with `.eql`.\n   *\n   * The `.deep.equal` assertion is almost identical to `.eql` but with one\n   * difference: `.deep.equal` causes deep equality comparisons to also be used\n   * for any other assertions that follow in the chain.\n   *\n   * @name eql\n   * @alias eqls\n   * @param {Mixed} obj\n   * @param {String} msg _optional_\n   * @namespace BDD\n   * @api public\n   */\n\n  function assertEql(obj, msg) {\n    if (msg) flag(this, 'message', msg);\n    this.assert(\n        _.eql(obj, flag(this, 'object'))\n      , 'expected #{this} to deeply equal #{exp}'\n      , 'expected #{this} to not deeply equal #{exp}'\n      , obj\n      , this._obj\n      , true\n    );\n  }\n\n  Assertion.addMethod('eql', assertEql);\n  Assertion.addMethod('eqls', assertEql);\n\n  /**\n   * ### .above(n[, msg])\n   *\n   * Asserts that the target is a number or a date greater than the given number or date `n` respectively.\n   * However, it's often best to assert that the target is equal to its expected\n   * value.\n   *\n   *     expect(2).to.equal(2); // Recommended\n   *     expect(2).to.be.above(1); // Not recommended\n   *\n   * Add `.lengthOf` earlier in the chain to assert that the target's `length`\n   * or `size` is greater than the given number `n`.\n   *\n   *     expect('foo').to.have.lengthOf(3); // Recommended\n   *     expect('foo').to.have.lengthOf.above(2); // Not recommended\n   *\n   *     expect([1, 2, 3]).to.have.lengthOf(3); // Recommended\n   *     expect([1, 2, 3]).to.have.lengthOf.above(2); // Not recommended\n   *\n   * Add `.not` earlier in the chain to negate `.above`.\n   *\n   *     expect(2).to.equal(2); // Recommended\n   *     expect(1).to.not.be.above(2); // Not recommended\n   *\n   * `.above` accepts an optional `msg` argument which is a custom error message\n   * to show when the assertion fails. The message can also be given as the\n   * second argument to `expect`.\n   *\n   *     expect(1).to.be.above(2, 'nooo why fail??');\n   *     expect(1, 'nooo why fail??').to.be.above(2);\n   *\n   * The aliases `.gt` and `.greaterThan` can be used interchangeably with\n   * `.above`.\n   *\n   * @name above\n   * @alias gt\n   * @alias greaterThan\n   * @param {Number} n\n   * @param {String} msg _optional_\n   * @namespace BDD\n   * @api public\n   */\n\n  function assertAbove (n, msg) {\n    if (msg) flag(this, 'message', msg);\n    var obj = flag(this, 'object')\n      , doLength = flag(this, 'doLength')\n      , flagMsg = flag(this, 'message')\n      , msgPrefix = ((flagMsg) ? flagMsg + ': ' : '')\n      , ssfi = flag(this, 'ssfi')\n      , objType = _.type(obj).toLowerCase()\n      , nType = _.type(n).toLowerCase()\n      , errorMessage\n      , shouldThrow = true;\n\n    if (doLength && objType !== 'map' && objType !== 'set') {\n      new Assertion(obj, flagMsg, ssfi, true).to.have.property('length');\n    }\n\n    if (!doLength && (objType === 'date' && nType !== 'date')) {\n      errorMessage = msgPrefix + 'the argument to above must be a date';\n    } else if (nType !== 'number' && (doLength || objType === 'number')) {\n      errorMessage = msgPrefix + 'the argument to above must be a number';\n    } else if (!doLength && (objType !== 'date' && objType !== 'number')) {\n      var printObj = (objType === 'string') ? \"'\" + obj + \"'\" : obj;\n      errorMessage = msgPrefix + 'expected ' + printObj + ' to be a number or a date';\n    } else {\n      shouldThrow = false;\n    }\n\n    if (shouldThrow) {\n      throw new AssertionError(errorMessage, undefined, ssfi);\n    }\n\n    if (doLength) {\n      var descriptor = 'length'\n        , itemsCount;\n      if (objType === 'map' || objType === 'set') {\n        descriptor = 'size';\n        itemsCount = obj.size;\n      } else {\n        itemsCount = obj.length;\n      }\n      this.assert(\n          itemsCount > n\n        , 'expected #{this} to have a ' + descriptor + ' above #{exp} but got #{act}'\n        , 'expected #{this} to not have a ' + descriptor + ' above #{exp}'\n        , n\n        , itemsCount\n      );\n    } else {\n      this.assert(\n          obj > n\n        , 'expected #{this} to be above #{exp}'\n        , 'expected #{this} to be at most #{exp}'\n        , n\n      );\n    }\n  }\n\n  Assertion.addMethod('above', assertAbove);\n  Assertion.addMethod('gt', assertAbove);\n  Assertion.addMethod('greaterThan', assertAbove);\n\n  /**\n   * ### .least(n[, msg])\n   *\n   * Asserts that the target is a number or a date greater than or equal to the given\n   * number or date `n` respectively. However, it's often best to assert that the target is equal to\n   * its expected value.\n   *\n   *     expect(2).to.equal(2); // Recommended\n   *     expect(2).to.be.at.least(1); // Not recommended\n   *     expect(2).to.be.at.least(2); // Not recommended\n   *\n   * Add `.lengthOf` earlier in the chain to assert that the target's `length`\n   * or `size` is greater than or equal to the given number `n`.\n   *\n   *     expect('foo').to.have.lengthOf(3); // Recommended\n   *     expect('foo').to.have.lengthOf.at.least(2); // Not recommended\n   *\n   *     expect([1, 2, 3]).to.have.lengthOf(3); // Recommended\n   *     expect([1, 2, 3]).to.have.lengthOf.at.least(2); // Not recommended\n   *\n   * Add `.not` earlier in the chain to negate `.least`.\n   *\n   *     expect(1).to.equal(1); // Recommended\n   *     expect(1).to.not.be.at.least(2); // Not recommended\n   *\n   * `.least` accepts an optional `msg` argument which is a custom error message\n   * to show when the assertion fails. The message can also be given as the\n   * second argument to `expect`.\n   *\n   *     expect(1).to.be.at.least(2, 'nooo why fail??');\n   *     expect(1, 'nooo why fail??').to.be.at.least(2);\n   *\n   * The alias `.gte` can be used interchangeably with `.least`.\n   *\n   * @name least\n   * @alias gte\n   * @param {Number} n\n   * @param {String} msg _optional_\n   * @namespace BDD\n   * @api public\n   */\n\n  function assertLeast (n, msg) {\n    if (msg) flag(this, 'message', msg);\n    var obj = flag(this, 'object')\n      , doLength = flag(this, 'doLength')\n      , flagMsg = flag(this, 'message')\n      , msgPrefix = ((flagMsg) ? flagMsg + ': ' : '')\n      , ssfi = flag(this, 'ssfi')\n      , objType = _.type(obj).toLowerCase()\n      , nType = _.type(n).toLowerCase()\n      , errorMessage\n      , shouldThrow = true;\n\n    if (doLength && objType !== 'map' && objType !== 'set') {\n      new Assertion(obj, flagMsg, ssfi, true).to.have.property('length');\n    }\n\n    if (!doLength && (objType === 'date' && nType !== 'date')) {\n      errorMessage = msgPrefix + 'the argument to least must be a date';\n    } else if (nType !== 'number' && (doLength || objType === 'number')) {\n      errorMessage = msgPrefix + 'the argument to least must be a number';\n    } else if (!doLength && (objType !== 'date' && objType !== 'number')) {\n      var printObj = (objType === 'string') ? \"'\" + obj + \"'\" : obj;\n      errorMessage = msgPrefix + 'expected ' + printObj + ' to be a number or a date';\n    } else {\n      shouldThrow = false;\n    }\n\n    if (shouldThrow) {\n      throw new AssertionError(errorMessage, undefined, ssfi);\n    }\n\n    if (doLength) {\n      var descriptor = 'length'\n        , itemsCount;\n      if (objType === 'map' || objType === 'set') {\n        descriptor = 'size';\n        itemsCount = obj.size;\n      } else {\n        itemsCount = obj.length;\n      }\n      this.assert(\n          itemsCount >= n\n        , 'expected #{this} to have a ' + descriptor + ' at least #{exp} but got #{act}'\n        , 'expected #{this} to have a ' + descriptor + ' below #{exp}'\n        , n\n        , itemsCount\n      );\n    } else {\n      this.assert(\n          obj >= n\n        , 'expected #{this} to be at least #{exp}'\n        , 'expected #{this} to be below #{exp}'\n        , n\n      );\n    }\n  }\n\n  Assertion.addMethod('least', assertLeast);\n  Assertion.addMethod('gte', assertLeast);\n\n  /**\n   * ### .below(n[, msg])\n   *\n   * Asserts that the target is a number or a date less than the given number or date `n` respectively.\n   * However, it's often best to assert that the target is equal to its expected\n   * value.\n   *\n   *     expect(1).to.equal(1); // Recommended\n   *     expect(1).to.be.below(2); // Not recommended\n   *\n   * Add `.lengthOf` earlier in the chain to assert that the target's `length`\n   * or `size` is less than the given number `n`.\n   *\n   *     expect('foo').to.have.lengthOf(3); // Recommended\n   *     expect('foo').to.have.lengthOf.below(4); // Not recommended\n   *\n   *     expect([1, 2, 3]).to.have.length(3); // Recommended\n   *     expect([1, 2, 3]).to.have.lengthOf.below(4); // Not recommended\n   *\n   * Add `.not` earlier in the chain to negate `.below`.\n   *\n   *     expect(2).to.equal(2); // Recommended\n   *     expect(2).to.not.be.below(1); // Not recommended\n   *\n   * `.below` accepts an optional `msg` argument which is a custom error message\n   * to show when the assertion fails. The message can also be given as the\n   * second argument to `expect`.\n   *\n   *     expect(2).to.be.below(1, 'nooo why fail??');\n   *     expect(2, 'nooo why fail??').to.be.below(1);\n   *\n   * The aliases `.lt` and `.lessThan` can be used interchangeably with\n   * `.below`.\n   *\n   * @name below\n   * @alias lt\n   * @alias lessThan\n   * @param {Number} n\n   * @param {String} msg _optional_\n   * @namespace BDD\n   * @api public\n   */\n\n  function assertBelow (n, msg) {\n    if (msg) flag(this, 'message', msg);\n    var obj = flag(this, 'object')\n      , doLength = flag(this, 'doLength')\n      , flagMsg = flag(this, 'message')\n      , msgPrefix = ((flagMsg) ? flagMsg + ': ' : '')\n      , ssfi = flag(this, 'ssfi')\n      , objType = _.type(obj).toLowerCase()\n      , nType = _.type(n).toLowerCase()\n      , errorMessage\n      , shouldThrow = true;\n\n    if (doLength && objType !== 'map' && objType !== 'set') {\n      new Assertion(obj, flagMsg, ssfi, true).to.have.property('length');\n    }\n\n    if (!doLength && (objType === 'date' && nType !== 'date')) {\n      errorMessage = msgPrefix + 'the argument to below must be a date';\n    } else if (nType !== 'number' && (doLength || objType === 'number')) {\n      errorMessage = msgPrefix + 'the argument to below must be a number';\n    } else if (!doLength && (objType !== 'date' && objType !== 'number')) {\n      var printObj = (objType === 'string') ? \"'\" + obj + \"'\" : obj;\n      errorMessage = msgPrefix + 'expected ' + printObj + ' to be a number or a date';\n    } else {\n      shouldThrow = false;\n    }\n\n    if (shouldThrow) {\n      throw new AssertionError(errorMessage, undefined, ssfi);\n    }\n\n    if (doLength) {\n      var descriptor = 'length'\n        , itemsCount;\n      if (objType === 'map' || objType === 'set') {\n        descriptor = 'size';\n        itemsCount = obj.size;\n      } else {\n        itemsCount = obj.length;\n      }\n      this.assert(\n          itemsCount < n\n        , 'expected #{this} to have a ' + descriptor + ' below #{exp} but got #{act}'\n        , 'expected #{this} to not have a ' + descriptor + ' below #{exp}'\n        , n\n        , itemsCount\n      );\n    } else {\n      this.assert(\n          obj < n\n        , 'expected #{this} to be below #{exp}'\n        , 'expected #{this} to be at least #{exp}'\n        , n\n      );\n    }\n  }\n\n  Assertion.addMethod('below', assertBelow);\n  Assertion.addMethod('lt', assertBelow);\n  Assertion.addMethod('lessThan', assertBelow);\n\n  /**\n   * ### .most(n[, msg])\n   *\n   * Asserts that the target is a number or a date less than or equal to the given number\n   * or date `n` respectively. However, it's often best to assert that the target is equal to its\n   * expected value.\n   *\n   *     expect(1).to.equal(1); // Recommended\n   *     expect(1).to.be.at.most(2); // Not recommended\n   *     expect(1).to.be.at.most(1); // Not recommended\n   *\n   * Add `.lengthOf` earlier in the chain to assert that the target's `length`\n   * or `size` is less than or equal to the given number `n`.\n   *\n   *     expect('foo').to.have.lengthOf(3); // Recommended\n   *     expect('foo').to.have.lengthOf.at.most(4); // Not recommended\n   *\n   *     expect([1, 2, 3]).to.have.lengthOf(3); // Recommended\n   *     expect([1, 2, 3]).to.have.lengthOf.at.most(4); // Not recommended\n   *\n   * Add `.not` earlier in the chain to negate `.most`.\n   *\n   *     expect(2).to.equal(2); // Recommended\n   *     expect(2).to.not.be.at.most(1); // Not recommended\n   *\n   * `.most` accepts an optional `msg` argument which is a custom error message\n   * to show when the assertion fails. The message can also be given as the\n   * second argument to `expect`.\n   *\n   *     expect(2).to.be.at.most(1, 'nooo why fail??');\n   *     expect(2, 'nooo why fail??').to.be.at.most(1);\n   *\n   * The alias `.lte` can be used interchangeably with `.most`.\n   *\n   * @name most\n   * @alias lte\n   * @param {Number} n\n   * @param {String} msg _optional_\n   * @namespace BDD\n   * @api public\n   */\n\n  function assertMost (n, msg) {\n    if (msg) flag(this, 'message', msg);\n    var obj = flag(this, 'object')\n      , doLength = flag(this, 'doLength')\n      , flagMsg = flag(this, 'message')\n      , msgPrefix = ((flagMsg) ? flagMsg + ': ' : '')\n      , ssfi = flag(this, 'ssfi')\n      , objType = _.type(obj).toLowerCase()\n      , nType = _.type(n).toLowerCase()\n      , errorMessage\n      , shouldThrow = true;\n\n    if (doLength && objType !== 'map' && objType !== 'set') {\n      new Assertion(obj, flagMsg, ssfi, true).to.have.property('length');\n    }\n\n    if (!doLength && (objType === 'date' && nType !== 'date')) {\n      errorMessage = msgPrefix + 'the argument to most must be a date';\n    } else if (nType !== 'number' && (doLength || objType === 'number')) {\n      errorMessage = msgPrefix + 'the argument to most must be a number';\n    } else if (!doLength && (objType !== 'date' && objType !== 'number')) {\n      var printObj = (objType === 'string') ? \"'\" + obj + \"'\" : obj;\n      errorMessage = msgPrefix + 'expected ' + printObj + ' to be a number or a date';\n    } else {\n      shouldThrow = false;\n    }\n\n    if (shouldThrow) {\n      throw new AssertionError(errorMessage, undefined, ssfi);\n    }\n\n    if (doLength) {\n      var descriptor = 'length'\n        , itemsCount;\n      if (objType === 'map' || objType === 'set') {\n        descriptor = 'size';\n        itemsCount = obj.size;\n      } else {\n        itemsCount = obj.length;\n      }\n      this.assert(\n          itemsCount <= n\n        , 'expected #{this} to have a ' + descriptor + ' at most #{exp} but got #{act}'\n        , 'expected #{this} to have a ' + descriptor + ' above #{exp}'\n        , n\n        , itemsCount\n      );\n    } else {\n      this.assert(\n          obj <= n\n        , 'expected #{this} to be at most #{exp}'\n        , 'expected #{this} to be above #{exp}'\n        , n\n      );\n    }\n  }\n\n  Assertion.addMethod('most', assertMost);\n  Assertion.addMethod('lte', assertMost);\n\n  /**\n   * ### .within(start, finish[, msg])\n   *\n   * Asserts that the target is a number or a date greater than or equal to the given\n   * number or date `start`, and less than or equal to the given number or date `finish` respectively.\n   * However, it's often best to assert that the target is equal to its expected\n   * value.\n   *\n   *     expect(2).to.equal(2); // Recommended\n   *     expect(2).to.be.within(1, 3); // Not recommended\n   *     expect(2).to.be.within(2, 3); // Not recommended\n   *     expect(2).to.be.within(1, 2); // Not recommended\n   *\n   * Add `.lengthOf` earlier in the chain to assert that the target's `length`\n   * or `size` is greater than or equal to the given number `start`, and less\n   * than or equal to the given number `finish`.\n   *\n   *     expect('foo').to.have.lengthOf(3); // Recommended\n   *     expect('foo').to.have.lengthOf.within(2, 4); // Not recommended\n   *\n   *     expect([1, 2, 3]).to.have.lengthOf(3); // Recommended\n   *     expect([1, 2, 3]).to.have.lengthOf.within(2, 4); // Not recommended\n   *\n   * Add `.not` earlier in the chain to negate `.within`.\n   *\n   *     expect(1).to.equal(1); // Recommended\n   *     expect(1).to.not.be.within(2, 4); // Not recommended\n   *\n   * `.within` accepts an optional `msg` argument which is a custom error\n   * message to show when the assertion fails. The message can also be given as\n   * the second argument to `expect`.\n   *\n   *     expect(4).to.be.within(1, 3, 'nooo why fail??');\n   *     expect(4, 'nooo why fail??').to.be.within(1, 3);\n   *\n   * @name within\n   * @param {Number} start lower bound inclusive\n   * @param {Number} finish upper bound inclusive\n   * @param {String} msg _optional_\n   * @namespace BDD\n   * @api public\n   */\n\n  Assertion.addMethod('within', function (start, finish, msg) {\n    if (msg) flag(this, 'message', msg);\n    var obj = flag(this, 'object')\n      , doLength = flag(this, 'doLength')\n      , flagMsg = flag(this, 'message')\n      , msgPrefix = ((flagMsg) ? flagMsg + ': ' : '')\n      , ssfi = flag(this, 'ssfi')\n      , objType = _.type(obj).toLowerCase()\n      , startType = _.type(start).toLowerCase()\n      , finishType = _.type(finish).toLowerCase()\n      , errorMessage\n      , shouldThrow = true\n      , range = (startType === 'date' && finishType === 'date')\n          ? start.toUTCString() + '..' + finish.toUTCString()\n          : start + '..' + finish;\n\n    if (doLength && objType !== 'map' && objType !== 'set') {\n      new Assertion(obj, flagMsg, ssfi, true).to.have.property('length');\n    }\n\n    if (!doLength && (objType === 'date' && (startType !== 'date' || finishType !== 'date'))) {\n      errorMessage = msgPrefix + 'the arguments to within must be dates';\n    } else if ((startType !== 'number' || finishType !== 'number') && (doLength || objType === 'number')) {\n      errorMessage = msgPrefix + 'the arguments to within must be numbers';\n    } else if (!doLength && (objType !== 'date' && objType !== 'number')) {\n      var printObj = (objType === 'string') ? \"'\" + obj + \"'\" : obj;\n      errorMessage = msgPrefix + 'expected ' + printObj + ' to be a number or a date';\n    } else {\n      shouldThrow = false;\n    }\n\n    if (shouldThrow) {\n      throw new AssertionError(errorMessage, undefined, ssfi);\n    }\n\n    if (doLength) {\n      var descriptor = 'length'\n        , itemsCount;\n      if (objType === 'map' || objType === 'set') {\n        descriptor = 'size';\n        itemsCount = obj.size;\n      } else {\n        itemsCount = obj.length;\n      }\n      this.assert(\n          itemsCount >= start && itemsCount <= finish\n        , 'expected #{this} to have a ' + descriptor + ' within ' + range\n        , 'expected #{this} to not have a ' + descriptor + ' within ' + range\n      );\n    } else {\n      this.assert(\n          obj >= start && obj <= finish\n        , 'expected #{this} to be within ' + range\n        , 'expected #{this} to not be within ' + range\n      );\n    }\n  });\n\n  /**\n   * ### .instanceof(constructor[, msg])\n   *\n   * Asserts that the target is an instance of the given `constructor`.\n   *\n   *     function Cat () { }\n   *\n   *     expect(new Cat()).to.be.an.instanceof(Cat);\n   *     expect([1, 2]).to.be.an.instanceof(Array);\n   *\n   * Add `.not` earlier in the chain to negate `.instanceof`.\n   *\n   *     expect({a: 1}).to.not.be.an.instanceof(Array);\n   *\n   * `.instanceof` accepts an optional `msg` argument which is a custom error\n   * message to show when the assertion fails. The message can also be given as\n   * the second argument to `expect`.\n   *\n   *     expect(1).to.be.an.instanceof(Array, 'nooo why fail??');\n   *     expect(1, 'nooo why fail??').to.be.an.instanceof(Array);\n   *\n   * Due to limitations in ES5, `.instanceof` may not always work as expected\n   * when using a transpiler such as Babel or TypeScript. In particular, it may\n   * produce unexpected results when subclassing built-in object such as\n   * `Array`, `Error`, and `Map`. See your transpiler's docs for details:\n   *\n   * - ([Babel](https://babeljs.io/docs/usage/caveats/#classes))\n   * - ([TypeScript](https://github.com/Microsoft/TypeScript/wiki/Breaking-Changes#extending-built-ins-like-error-array-and-map-may-no-longer-work))\n   *\n   * The alias `.instanceOf` can be used interchangeably with `.instanceof`.\n   *\n   * @name instanceof\n   * @param {Constructor} constructor\n   * @param {String} msg _optional_\n   * @alias instanceOf\n   * @namespace BDD\n   * @api public\n   */\n\n  function assertInstanceOf (constructor, msg) {\n    if (msg) flag(this, 'message', msg);\n\n    var target = flag(this, 'object')\n    var ssfi = flag(this, 'ssfi');\n    var flagMsg = flag(this, 'message');\n\n    try {\n      var isInstanceOf = target instanceof constructor;\n    } catch (err) {\n      if (err instanceof TypeError) {\n        flagMsg = flagMsg ? flagMsg + ': ' : '';\n        throw new AssertionError(\n          flagMsg + 'The instanceof assertion needs a constructor but '\n            + _.type(constructor) + ' was given.',\n          undefined,\n          ssfi\n        );\n      }\n      throw err;\n    }\n\n    var name = _.getName(constructor);\n    if (name === null) {\n      name = 'an unnamed constructor';\n    }\n\n    this.assert(\n        isInstanceOf\n      , 'expected #{this} to be an instance of ' + name\n      , 'expected #{this} to not be an instance of ' + name\n    );\n  };\n\n  Assertion.addMethod('instanceof', assertInstanceOf);\n  Assertion.addMethod('instanceOf', assertInstanceOf);\n\n  /**\n   * ### .property(name[, val[, msg]])\n   *\n   * Asserts that the target has a property with the given key `name`.\n   *\n   *     expect({a: 1}).to.have.property('a');\n   *\n   * When `val` is provided, `.property` also asserts that the property's value\n   * is equal to the given `val`.\n   *\n   *     expect({a: 1}).to.have.property('a', 1);\n   *\n   * By default, strict (`===`) equality is used. Add `.deep` earlier in the\n   * chain to use deep equality instead. See the `deep-eql` project page for\n   * info on the deep equality algorithm: https://github.com/chaijs/deep-eql.\n   *\n   *     // Target object deeply (but not strictly) has property `x: {a: 1}`\n   *     expect({x: {a: 1}}).to.have.deep.property('x', {a: 1});\n   *     expect({x: {a: 1}}).to.not.have.property('x', {a: 1});\n   *\n   * The target's enumerable and non-enumerable properties are always included\n   * in the search. By default, both own and inherited properties are included.\n   * Add `.own` earlier in the chain to exclude inherited properties from the\n   * search.\n   *\n   *     Object.prototype.b = 2;\n   *\n   *     expect({a: 1}).to.have.own.property('a');\n   *     expect({a: 1}).to.have.own.property('a', 1);\n   *     expect({a: 1}).to.have.property('b');\n   *     expect({a: 1}).to.not.have.own.property('b');\n   *\n   * `.deep` and `.own` can be combined.\n   *\n   *     expect({x: {a: 1}}).to.have.deep.own.property('x', {a: 1});\n   *\n   * Add `.nested` earlier in the chain to enable dot- and bracket-notation when\n   * referencing nested properties.\n   *\n   *     expect({a: {b: ['x', 'y']}}).to.have.nested.property('a.b[1]');\n   *     expect({a: {b: ['x', 'y']}}).to.have.nested.property('a.b[1]', 'y');\n   *\n   * If `.` or `[]` are part of an actual property name, they can be escaped by\n   * adding two backslashes before them.\n   *\n   *     expect({'.a': {'[b]': 'x'}}).to.have.nested.property('\\\\.a.\\\\[b\\\\]');\n   *\n   * `.deep` and `.nested` can be combined.\n   *\n   *     expect({a: {b: [{c: 3}]}})\n   *       .to.have.deep.nested.property('a.b[0]', {c: 3});\n   *\n   * `.own` and `.nested` cannot be combined.\n   *\n   * Add `.not` earlier in the chain to negate `.property`.\n   *\n   *     expect({a: 1}).to.not.have.property('b');\n   *\n   * However, it's dangerous to negate `.property` when providing `val`. The\n   * problem is that it creates uncertain expectations by asserting that the\n   * target either doesn't have a property with the given key `name`, or that it\n   * does have a property with the given key `name` but its value isn't equal to\n   * the given `val`. It's often best to identify the exact output that's\n   * expected, and then write an assertion that only accepts that exact output.\n   *\n   * When the target isn't expected to have a property with the given key\n   * `name`, it's often best to assert exactly that.\n   *\n   *     expect({b: 2}).to.not.have.property('a'); // Recommended\n   *     expect({b: 2}).to.not.have.property('a', 1); // Not recommended\n   *\n   * When the target is expected to have a property with the given key `name`,\n   * it's often best to assert that the property has its expected value, rather\n   * than asserting that it doesn't have one of many unexpected values.\n   *\n   *     expect({a: 3}).to.have.property('a', 3); // Recommended\n   *     expect({a: 3}).to.not.have.property('a', 1); // Not recommended\n   *\n   * `.property` changes the target of any assertions that follow in the chain\n   * to be the value of the property from the original target object.\n   *\n   *     expect({a: 1}).to.have.property('a').that.is.a('number');\n   *\n   * `.property` accepts an optional `msg` argument which is a custom error\n   * message to show when the assertion fails. The message can also be given as\n   * the second argument to `expect`. When not providing `val`, only use the\n   * second form.\n   *\n   *     // Recommended\n   *     expect({a: 1}).to.have.property('a', 2, 'nooo why fail??');\n   *     expect({a: 1}, 'nooo why fail??').to.have.property('a', 2);\n   *     expect({a: 1}, 'nooo why fail??').to.have.property('b');\n   *\n   *     // Not recommended\n   *     expect({a: 1}).to.have.property('b', undefined, 'nooo why fail??');\n   *\n   * The above assertion isn't the same thing as not providing `val`. Instead,\n   * it's asserting that the target object has a `b` property that's equal to\n   * `undefined`.\n   *\n   * The assertions `.ownProperty` and `.haveOwnProperty` can be used\n   * interchangeably with `.own.property`.\n   *\n   * @name property\n   * @param {String} name\n   * @param {Mixed} val (optional)\n   * @param {String} msg _optional_\n   * @returns value of property for chaining\n   * @namespace BDD\n   * @api public\n   */\n\n  function assertProperty (name, val, msg) {\n    if (msg) flag(this, 'message', msg);\n\n    var isNested = flag(this, 'nested')\n      , isOwn = flag(this, 'own')\n      , flagMsg = flag(this, 'message')\n      , obj = flag(this, 'object')\n      , ssfi = flag(this, 'ssfi')\n      , nameType = typeof name;\n\n    flagMsg = flagMsg ? flagMsg + ': ' : '';\n\n    if (isNested) {\n      if (nameType !== 'string') {\n        throw new AssertionError(\n          flagMsg + 'the argument to property must be a string when using nested syntax',\n          undefined,\n          ssfi\n        );\n      }\n    } else {\n      if (nameType !== 'string' && nameType !== 'number' && nameType !== 'symbol') {\n        throw new AssertionError(\n          flagMsg + 'the argument to property must be a string, number, or symbol',\n          undefined,\n          ssfi\n        );\n      }\n    }\n\n    if (isNested && isOwn) {\n      throw new AssertionError(\n        flagMsg + 'The \"nested\" and \"own\" flags cannot be combined.',\n        undefined,\n        ssfi\n      );\n    }\n\n    if (obj === null || obj === undefined) {\n      throw new AssertionError(\n        flagMsg + 'Target cannot be null or undefined.',\n        undefined,\n        ssfi\n      );\n    }\n\n    var isDeep = flag(this, 'deep')\n      , negate = flag(this, 'negate')\n      , pathInfo = isNested ? _.getPathInfo(obj, name) : null\n      , value = isNested ? pathInfo.value : obj[name];\n\n    var descriptor = '';\n    if (isDeep) descriptor += 'deep ';\n    if (isOwn) descriptor += 'own ';\n    if (isNested) descriptor += 'nested ';\n    descriptor += 'property ';\n\n    var hasProperty;\n    if (isOwn) hasProperty = Object.prototype.hasOwnProperty.call(obj, name);\n    else if (isNested) hasProperty = pathInfo.exists;\n    else hasProperty = _.hasProperty(obj, name);\n\n    // When performing a negated assertion for both name and val, merely having\n    // a property with the given name isn't enough to cause the assertion to\n    // fail. It must both have a property with the given name, and the value of\n    // that property must equal the given val. Therefore, skip this assertion in\n    // favor of the next.\n    if (!negate || arguments.length === 1) {\n      this.assert(\n          hasProperty\n        , 'expected #{this} to have ' + descriptor + _.inspect(name)\n        , 'expected #{this} to not have ' + descriptor + _.inspect(name));\n    }\n\n    if (arguments.length > 1) {\n      this.assert(\n          hasProperty && (isDeep ? _.eql(val, value) : val === value)\n        , 'expected #{this} to have ' + descriptor + _.inspect(name) + ' of #{exp}, but got #{act}'\n        , 'expected #{this} to not have ' + descriptor + _.inspect(name) + ' of #{act}'\n        , val\n        , value\n      );\n    }\n\n    flag(this, 'object', value);\n  }\n\n  Assertion.addMethod('property', assertProperty);\n\n  function assertOwnProperty (name, value, msg) {\n    flag(this, 'own', true);\n    assertProperty.apply(this, arguments);\n  }\n\n  Assertion.addMethod('ownProperty', assertOwnProperty);\n  Assertion.addMethod('haveOwnProperty', assertOwnProperty);\n\n  /**\n   * ### .ownPropertyDescriptor(name[, descriptor[, msg]])\n   *\n   * Asserts that the target has its own property descriptor with the given key\n   * `name`. Enumerable and non-enumerable properties are included in the\n   * search.\n   *\n   *     expect({a: 1}).to.have.ownPropertyDescriptor('a');\n   *\n   * When `descriptor` is provided, `.ownPropertyDescriptor` also asserts that\n   * the property's descriptor is deeply equal to the given `descriptor`. See\n   * the `deep-eql` project page for info on the deep equality algorithm:\n   * https://github.com/chaijs/deep-eql.\n   *\n   *     expect({a: 1}).to.have.ownPropertyDescriptor('a', {\n   *       configurable: true,\n   *       enumerable: true,\n   *       writable: true,\n   *       value: 1,\n   *     });\n   *\n   * Add `.not` earlier in the chain to negate `.ownPropertyDescriptor`.\n   *\n   *     expect({a: 1}).to.not.have.ownPropertyDescriptor('b');\n   *\n   * However, it's dangerous to negate `.ownPropertyDescriptor` when providing\n   * a `descriptor`. The problem is that it creates uncertain expectations by\n   * asserting that the target either doesn't have a property descriptor with\n   * the given key `name`, or that it does have a property descriptor with the\n   * given key `name` but its not deeply equal to the given `descriptor`. It's\n   * often best to identify the exact output that's expected, and then write an\n   * assertion that only accepts that exact output.\n   *\n   * When the target isn't expected to have a property descriptor with the given\n   * key `name`, it's often best to assert exactly that.\n   *\n   *     // Recommended\n   *     expect({b: 2}).to.not.have.ownPropertyDescriptor('a');\n   *\n   *     // Not recommended\n   *     expect({b: 2}).to.not.have.ownPropertyDescriptor('a', {\n   *       configurable: true,\n   *       enumerable: true,\n   *       writable: true,\n   *       value: 1,\n   *     });\n   *\n   * When the target is expected to have a property descriptor with the given\n   * key `name`, it's often best to assert that the property has its expected\n   * descriptor, rather than asserting that it doesn't have one of many\n   * unexpected descriptors.\n   *\n   *     // Recommended\n   *     expect({a: 3}).to.have.ownPropertyDescriptor('a', {\n   *       configurable: true,\n   *       enumerable: true,\n   *       writable: true,\n   *       value: 3,\n   *     });\n   *\n   *     // Not recommended\n   *     expect({a: 3}).to.not.have.ownPropertyDescriptor('a', {\n   *       configurable: true,\n   *       enumerable: true,\n   *       writable: true,\n   *       value: 1,\n   *     });\n   *\n   * `.ownPropertyDescriptor` changes the target of any assertions that follow\n   * in the chain to be the value of the property descriptor from the original\n   * target object.\n   *\n   *     expect({a: 1}).to.have.ownPropertyDescriptor('a')\n   *       .that.has.property('enumerable', true);\n   *\n   * `.ownPropertyDescriptor` accepts an optional `msg` argument which is a\n   * custom error message to show when the assertion fails. The message can also\n   * be given as the second argument to `expect`. When not providing\n   * `descriptor`, only use the second form.\n   *\n   *     // Recommended\n   *     expect({a: 1}).to.have.ownPropertyDescriptor('a', {\n   *       configurable: true,\n   *       enumerable: true,\n   *       writable: true,\n   *       value: 2,\n   *     }, 'nooo why fail??');\n   *\n   *     // Recommended\n   *     expect({a: 1}, 'nooo why fail??').to.have.ownPropertyDescriptor('a', {\n   *       configurable: true,\n   *       enumerable: true,\n   *       writable: true,\n   *       value: 2,\n   *     });\n   *\n   *     // Recommended\n   *     expect({a: 1}, 'nooo why fail??').to.have.ownPropertyDescriptor('b');\n   *\n   *     // Not recommended\n   *     expect({a: 1})\n   *       .to.have.ownPropertyDescriptor('b', undefined, 'nooo why fail??');\n   *\n   * The above assertion isn't the same thing as not providing `descriptor`.\n   * Instead, it's asserting that the target object has a `b` property\n   * descriptor that's deeply equal to `undefined`.\n   *\n   * The alias `.haveOwnPropertyDescriptor` can be used interchangeably with\n   * `.ownPropertyDescriptor`.\n   *\n   * @name ownPropertyDescriptor\n   * @alias haveOwnPropertyDescriptor\n   * @param {String} name\n   * @param {Object} descriptor _optional_\n   * @param {String} msg _optional_\n   * @namespace BDD\n   * @api public\n   */\n\n  function assertOwnPropertyDescriptor (name, descriptor, msg) {\n    if (typeof descriptor === 'string') {\n      msg = descriptor;\n      descriptor = null;\n    }\n    if (msg) flag(this, 'message', msg);\n    var obj = flag(this, 'object');\n    var actualDescriptor = Object.getOwnPropertyDescriptor(Object(obj), name);\n    if (actualDescriptor && descriptor) {\n      this.assert(\n          _.eql(descriptor, actualDescriptor)\n        , 'expected the own property descriptor for ' + _.inspect(name) + ' on #{this} to match ' + _.inspect(descriptor) + ', got ' + _.inspect(actualDescriptor)\n        , 'expected the own property descriptor for ' + _.inspect(name) + ' on #{this} to not match ' + _.inspect(descriptor)\n        , descriptor\n        , actualDescriptor\n        , true\n      );\n    } else {\n      this.assert(\n          actualDescriptor\n        , 'expected #{this} to have an own property descriptor for ' + _.inspect(name)\n        , 'expected #{this} to not have an own property descriptor for ' + _.inspect(name)\n      );\n    }\n    flag(this, 'object', actualDescriptor);\n  }\n\n  Assertion.addMethod('ownPropertyDescriptor', assertOwnPropertyDescriptor);\n  Assertion.addMethod('haveOwnPropertyDescriptor', assertOwnPropertyDescriptor);\n\n  /**\n   * ### .lengthOf(n[, msg])\n   *\n   * Asserts that the target's `length` or `size` is equal to the given number\n   * `n`.\n   *\n   *     expect([1, 2, 3]).to.have.lengthOf(3);\n   *     expect('foo').to.have.lengthOf(3);\n   *     expect(new Set([1, 2, 3])).to.have.lengthOf(3);\n   *     expect(new Map([['a', 1], ['b', 2], ['c', 3]])).to.have.lengthOf(3);\n   *\n   * Add `.not` earlier in the chain to negate `.lengthOf`. However, it's often\n   * best to assert that the target's `length` property is equal to its expected\n   * value, rather than not equal to one of many unexpected values.\n   *\n   *     expect('foo').to.have.lengthOf(3); // Recommended\n   *     expect('foo').to.not.have.lengthOf(4); // Not recommended\n   *\n   * `.lengthOf` accepts an optional `msg` argument which is a custom error\n   * message to show when the assertion fails. The message can also be given as\n   * the second argument to `expect`.\n   *\n   *     expect([1, 2, 3]).to.have.lengthOf(2, 'nooo why fail??');\n   *     expect([1, 2, 3], 'nooo why fail??').to.have.lengthOf(2);\n   *\n   * `.lengthOf` can also be used as a language chain, causing all `.above`,\n   * `.below`, `.least`, `.most`, and `.within` assertions that follow in the\n   * chain to use the target's `length` property as the target. However, it's\n   * often best to assert that the target's `length` property is equal to its\n   * expected length, rather than asserting that its `length` property falls\n   * within some range of values.\n   *\n   *     // Recommended\n   *     expect([1, 2, 3]).to.have.lengthOf(3);\n   *\n   *     // Not recommended\n   *     expect([1, 2, 3]).to.have.lengthOf.above(2);\n   *     expect([1, 2, 3]).to.have.lengthOf.below(4);\n   *     expect([1, 2, 3]).to.have.lengthOf.at.least(3);\n   *     expect([1, 2, 3]).to.have.lengthOf.at.most(3);\n   *     expect([1, 2, 3]).to.have.lengthOf.within(2,4);\n   *\n   * Due to a compatibility issue, the alias `.length` can't be chained directly\n   * off of an uninvoked method such as `.a`. Therefore, `.length` can't be used\n   * interchangeably with `.lengthOf` in every situation. It's recommended to\n   * always use `.lengthOf` instead of `.length`.\n   *\n   *     expect([1, 2, 3]).to.have.a.length(3); // incompatible; throws error\n   *     expect([1, 2, 3]).to.have.a.lengthOf(3);  // passes as expected\n   *\n   * @name lengthOf\n   * @alias length\n   * @param {Number} n\n   * @param {String} msg _optional_\n   * @namespace BDD\n   * @api public\n   */\n\n  function assertLengthChain () {\n    flag(this, 'doLength', true);\n  }\n\n  function assertLength (n, msg) {\n    if (msg) flag(this, 'message', msg);\n    var obj = flag(this, 'object')\n      , objType = _.type(obj).toLowerCase()\n      , flagMsg = flag(this, 'message')\n      , ssfi = flag(this, 'ssfi')\n      , descriptor = 'length'\n      , itemsCount;\n\n    switch (objType) {\n      case 'map':\n      case 'set':\n        descriptor = 'size';\n        itemsCount = obj.size;\n        break;\n      default:\n        new Assertion(obj, flagMsg, ssfi, true).to.have.property('length');\n        itemsCount = obj.length;\n    }\n\n    this.assert(\n        itemsCount == n\n      , 'expected #{this} to have a ' + descriptor + ' of #{exp} but got #{act}'\n      , 'expected #{this} to not have a ' + descriptor + ' of #{act}'\n      , n\n      , itemsCount\n    );\n  }\n\n  Assertion.addChainableMethod('length', assertLength, assertLengthChain);\n  Assertion.addChainableMethod('lengthOf', assertLength, assertLengthChain);\n\n  /**\n   * ### .match(re[, msg])\n   *\n   * Asserts that the target matches the given regular expression `re`.\n   *\n   *     expect('foobar').to.match(/^foo/);\n   *\n   * Add `.not` earlier in the chain to negate `.match`.\n   *\n   *     expect('foobar').to.not.match(/taco/);\n   *\n   * `.match` accepts an optional `msg` argument which is a custom error message\n   * to show when the assertion fails. The message can also be given as the\n   * second argument to `expect`.\n   *\n   *     expect('foobar').to.match(/taco/, 'nooo why fail??');\n   *     expect('foobar', 'nooo why fail??').to.match(/taco/);\n   *\n   * The alias `.matches` can be used interchangeably with `.match`.\n   *\n   * @name match\n   * @alias matches\n   * @param {RegExp} re\n   * @param {String} msg _optional_\n   * @namespace BDD\n   * @api public\n   */\n  function assertMatch(re, msg) {\n    if (msg) flag(this, 'message', msg);\n    var obj = flag(this, 'object');\n    this.assert(\n        re.exec(obj)\n      , 'expected #{this} to match ' + re\n      , 'expected #{this} not to match ' + re\n    );\n  }\n\n  Assertion.addMethod('match', assertMatch);\n  Assertion.addMethod('matches', assertMatch);\n\n  /**\n   * ### .string(str[, msg])\n   *\n   * Asserts that the target string contains the given substring `str`.\n   *\n   *     expect('foobar').to.have.string('bar');\n   *\n   * Add `.not` earlier in the chain to negate `.string`.\n   *\n   *     expect('foobar').to.not.have.string('taco');\n   *\n   * `.string` accepts an optional `msg` argument which is a custom error\n   * message to show when the assertion fails. The message can also be given as\n   * the second argument to `expect`.\n   *\n   *     expect('foobar').to.have.string('taco', 'nooo why fail??');\n   *     expect('foobar', 'nooo why fail??').to.have.string('taco');\n   *\n   * @name string\n   * @param {String} str\n   * @param {String} msg _optional_\n   * @namespace BDD\n   * @api public\n   */\n\n  Assertion.addMethod('string', function (str, msg) {\n    if (msg) flag(this, 'message', msg);\n    var obj = flag(this, 'object')\n      , flagMsg = flag(this, 'message')\n      , ssfi = flag(this, 'ssfi');\n    new Assertion(obj, flagMsg, ssfi, true).is.a('string');\n\n    this.assert(\n        ~obj.indexOf(str)\n      , 'expected #{this} to contain ' + _.inspect(str)\n      , 'expected #{this} to not contain ' + _.inspect(str)\n    );\n  });\n\n  /**\n   * ### .keys(key1[, key2[, ...]])\n   *\n   * Asserts that the target object, array, map, or set has the given keys. Only\n   * the target's own inherited properties are included in the search.\n   *\n   * When the target is an object or array, keys can be provided as one or more\n   * string arguments, a single array argument, or a single object argument. In\n   * the latter case, only the keys in the given object matter; the values are\n   * ignored.\n   *\n   *     expect({a: 1, b: 2}).to.have.all.keys('a', 'b');\n   *     expect(['x', 'y']).to.have.all.keys(0, 1);\n   *\n   *     expect({a: 1, b: 2}).to.have.all.keys(['a', 'b']);\n   *     expect(['x', 'y']).to.have.all.keys([0, 1]);\n   *\n   *     expect({a: 1, b: 2}).to.have.all.keys({a: 4, b: 5}); // ignore 4 and 5\n   *     expect(['x', 'y']).to.have.all.keys({0: 4, 1: 5}); // ignore 4 and 5\n   *\n   * When the target is a map or set, each key must be provided as a separate\n   * argument.\n   *\n   *     expect(new Map([['a', 1], ['b', 2]])).to.have.all.keys('a', 'b');\n   *     expect(new Set(['a', 'b'])).to.have.all.keys('a', 'b');\n   *\n   * Because `.keys` does different things based on the target's type, it's\n   * important to check the target's type before using `.keys`. See the `.a` doc\n   * for info on testing a target's type.\n   *\n   *     expect({a: 1, b: 2}).to.be.an('object').that.has.all.keys('a', 'b');\n   *\n   * By default, strict (`===`) equality is used to compare keys of maps and\n   * sets. Add `.deep` earlier in the chain to use deep equality instead. See\n   * the `deep-eql` project page for info on the deep equality algorithm:\n   * https://github.com/chaijs/deep-eql.\n   *\n   *     // Target set deeply (but not strictly) has key `{a: 1}`\n   *     expect(new Set([{a: 1}])).to.have.all.deep.keys([{a: 1}]);\n   *     expect(new Set([{a: 1}])).to.not.have.all.keys([{a: 1}]);\n   *\n   * By default, the target must have all of the given keys and no more. Add\n   * `.any` earlier in the chain to only require that the target have at least\n   * one of the given keys. Also, add `.not` earlier in the chain to negate\n   * `.keys`. It's often best to add `.any` when negating `.keys`, and to use\n   * `.all` when asserting `.keys` without negation.\n   *\n   * When negating `.keys`, `.any` is preferred because `.not.any.keys` asserts\n   * exactly what's expected of the output, whereas `.not.all.keys` creates\n   * uncertain expectations.\n   *\n   *     // Recommended; asserts that target doesn't have any of the given keys\n   *     expect({a: 1, b: 2}).to.not.have.any.keys('c', 'd');\n   *\n   *     // Not recommended; asserts that target doesn't have all of the given\n   *     // keys but may or may not have some of them\n   *     expect({a: 1, b: 2}).to.not.have.all.keys('c', 'd');\n   *\n   * When asserting `.keys` without negation, `.all` is preferred because\n   * `.all.keys` asserts exactly what's expected of the output, whereas\n   * `.any.keys` creates uncertain expectations.\n   *\n   *     // Recommended; asserts that target has all the given keys\n   *     expect({a: 1, b: 2}).to.have.all.keys('a', 'b');\n   *\n   *     // Not recommended; asserts that target has at least one of the given\n   *     // keys but may or may not have more of them\n   *     expect({a: 1, b: 2}).to.have.any.keys('a', 'b');\n   *\n   * Note that `.all` is used by default when neither `.all` nor `.any` appear\n   * earlier in the chain. However, it's often best to add `.all` anyway because\n   * it improves readability.\n   *\n   *     // Both assertions are identical\n   *     expect({a: 1, b: 2}).to.have.all.keys('a', 'b'); // Recommended\n   *     expect({a: 1, b: 2}).to.have.keys('a', 'b'); // Not recommended\n   *\n   * Add `.include` earlier in the chain to require that the target's keys be a\n   * superset of the expected keys, rather than identical sets.\n   *\n   *     // Target object's keys are a superset of ['a', 'b'] but not identical\n   *     expect({a: 1, b: 2, c: 3}).to.include.all.keys('a', 'b');\n   *     expect({a: 1, b: 2, c: 3}).to.not.have.all.keys('a', 'b');\n   *\n   * However, if `.any` and `.include` are combined, only the `.any` takes\n   * effect. The `.include` is ignored in this case.\n   *\n   *     // Both assertions are identical\n   *     expect({a: 1}).to.have.any.keys('a', 'b');\n   *     expect({a: 1}).to.include.any.keys('a', 'b');\n   *\n   * A custom error message can be given as the second argument to `expect`.\n   *\n   *     expect({a: 1}, 'nooo why fail??').to.have.key('b');\n   *\n   * The alias `.key` can be used interchangeably with `.keys`.\n   *\n   * @name keys\n   * @alias key\n   * @param {...String|Array|Object} keys\n   * @namespace BDD\n   * @api public\n   */\n\n  function assertKeys (keys) {\n    var obj = flag(this, 'object')\n      , objType = _.type(obj)\n      , keysType = _.type(keys)\n      , ssfi = flag(this, 'ssfi')\n      , isDeep = flag(this, 'deep')\n      , str\n      , deepStr = ''\n      , actual\n      , ok = true\n      , flagMsg = flag(this, 'message');\n\n    flagMsg = flagMsg ? flagMsg + ': ' : '';\n    var mixedArgsMsg = flagMsg + 'when testing keys against an object or an array you must give a single Array|Object|String argument or multiple String arguments';\n\n    if (objType === 'Map' || objType === 'Set') {\n      deepStr = isDeep ? 'deeply ' : '';\n      actual = [];\n\n      // Map and Set '.keys' aren't supported in IE 11. Therefore, use .forEach.\n      obj.forEach(function (val, key) { actual.push(key) });\n\n      if (keysType !== 'Array') {\n        keys = Array.prototype.slice.call(arguments);\n      }\n    } else {\n      actual = _.getOwnEnumerableProperties(obj);\n\n      switch (keysType) {\n        case 'Array':\n          if (arguments.length > 1) {\n            throw new AssertionError(mixedArgsMsg, undefined, ssfi);\n          }\n          break;\n        case 'Object':\n          if (arguments.length > 1) {\n            throw new AssertionError(mixedArgsMsg, undefined, ssfi);\n          }\n          keys = Object.keys(keys);\n          break;\n        default:\n          keys = Array.prototype.slice.call(arguments);\n      }\n\n      // Only stringify non-Symbols because Symbols would become \"Symbol()\"\n      keys = keys.map(function (val) {\n        return typeof val === 'symbol' ? val : String(val);\n      });\n    }\n\n    if (!keys.length) {\n      throw new AssertionError(flagMsg + 'keys required', undefined, ssfi);\n    }\n\n    var len = keys.length\n      , any = flag(this, 'any')\n      , all = flag(this, 'all')\n      , expected = keys;\n\n    if (!any && !all) {\n      all = true;\n    }\n\n    // Has any\n    if (any) {\n      ok = expected.some(function(expectedKey) {\n        return actual.some(function(actualKey) {\n          if (isDeep) {\n            return _.eql(expectedKey, actualKey);\n          } else {\n            return expectedKey === actualKey;\n          }\n        });\n      });\n    }\n\n    // Has all\n    if (all) {\n      ok = expected.every(function(expectedKey) {\n        return actual.some(function(actualKey) {\n          if (isDeep) {\n            return _.eql(expectedKey, actualKey);\n          } else {\n            return expectedKey === actualKey;\n          }\n        });\n      });\n\n      if (!flag(this, 'contains')) {\n        ok = ok && keys.length == actual.length;\n      }\n    }\n\n    // Key string\n    if (len > 1) {\n      keys = keys.map(function(key) {\n        return _.inspect(key);\n      });\n      var last = keys.pop();\n      if (all) {\n        str = keys.join(', ') + ', and ' + last;\n      }\n      if (any) {\n        str = keys.join(', ') + ', or ' + last;\n      }\n    } else {\n      str = _.inspect(keys[0]);\n    }\n\n    // Form\n    str = (len > 1 ? 'keys ' : 'key ') + str;\n\n    // Have / include\n    str = (flag(this, 'contains') ? 'contain ' : 'have ') + str;\n\n    // Assertion\n    this.assert(\n        ok\n      , 'expected #{this} to ' + deepStr + str\n      , 'expected #{this} to not ' + deepStr + str\n      , expected.slice(0).sort(_.compareByInspect)\n      , actual.sort(_.compareByInspect)\n      , true\n    );\n  }\n\n  Assertion.addMethod('keys', assertKeys);\n  Assertion.addMethod('key', assertKeys);\n\n  /**\n   * ### .throw([errorLike], [errMsgMatcher], [msg])\n   *\n   * When no arguments are provided, `.throw` invokes the target function and\n   * asserts that an error is thrown.\n   *\n   *     var badFn = function () { throw new TypeError('Illegal salmon!'); };\n   *\n   *     expect(badFn).to.throw();\n   *\n   * When one argument is provided, and it's an error constructor, `.throw`\n   * invokes the target function and asserts that an error is thrown that's an\n   * instance of that error constructor.\n   *\n   *     var badFn = function () { throw new TypeError('Illegal salmon!'); };\n   *\n   *     expect(badFn).to.throw(TypeError);\n   *\n   * When one argument is provided, and it's an error instance, `.throw` invokes\n   * the target function and asserts that an error is thrown that's strictly\n   * (`===`) equal to that error instance.\n   *\n   *     var err = new TypeError('Illegal salmon!');\n   *     var badFn = function () { throw err; };\n   *\n   *     expect(badFn).to.throw(err);\n   *\n   * When one argument is provided, and it's a string, `.throw` invokes the\n   * target function and asserts that an error is thrown with a message that\n   * contains that string.\n   *\n   *     var badFn = function () { throw new TypeError('Illegal salmon!'); };\n   *\n   *     expect(badFn).to.throw('salmon');\n   *\n   * When one argument is provided, and it's a regular expression, `.throw`\n   * invokes the target function and asserts that an error is thrown with a\n   * message that matches that regular expression.\n   *\n   *     var badFn = function () { throw new TypeError('Illegal salmon!'); };\n   *\n   *     expect(badFn).to.throw(/salmon/);\n   *\n   * When two arguments are provided, and the first is an error instance or\n   * constructor, and the second is a string or regular expression, `.throw`\n   * invokes the function and asserts that an error is thrown that fulfills both\n   * conditions as described above.\n   *\n   *     var err = new TypeError('Illegal salmon!');\n   *     var badFn = function () { throw err; };\n   *\n   *     expect(badFn).to.throw(TypeError, 'salmon');\n   *     expect(badFn).to.throw(TypeError, /salmon/);\n   *     expect(badFn).to.throw(err, 'salmon');\n   *     expect(badFn).to.throw(err, /salmon/);\n   *\n   * Add `.not` earlier in the chain to negate `.throw`.\n   *\n   *     var goodFn = function () {};\n   *\n   *     expect(goodFn).to.not.throw();\n   *\n   * However, it's dangerous to negate `.throw` when providing any arguments.\n   * The problem is that it creates uncertain expectations by asserting that the\n   * target either doesn't throw an error, or that it throws an error but of a\n   * different type than the given type, or that it throws an error of the given\n   * type but with a message that doesn't include the given string. It's often\n   * best to identify the exact output that's expected, and then write an\n   * assertion that only accepts that exact output.\n   *\n   * When the target isn't expected to throw an error, it's often best to assert\n   * exactly that.\n   *\n   *     var goodFn = function () {};\n   *\n   *     expect(goodFn).to.not.throw(); // Recommended\n   *     expect(goodFn).to.not.throw(ReferenceError, 'x'); // Not recommended\n   *\n   * When the target is expected to throw an error, it's often best to assert\n   * that the error is of its expected type, and has a message that includes an\n   * expected string, rather than asserting that it doesn't have one of many\n   * unexpected types, and doesn't have a message that includes some string.\n   *\n   *     var badFn = function () { throw new TypeError('Illegal salmon!'); };\n   *\n   *     expect(badFn).to.throw(TypeError, 'salmon'); // Recommended\n   *     expect(badFn).to.not.throw(ReferenceError, 'x'); // Not recommended\n   *\n   * `.throw` changes the target of any assertions that follow in the chain to\n   * be the error object that's thrown.\n   *\n   *     var err = new TypeError('Illegal salmon!');\n   *     err.code = 42;\n   *     var badFn = function () { throw err; };\n   *\n   *     expect(badFn).to.throw(TypeError).with.property('code', 42);\n   *\n   * `.throw` accepts an optional `msg` argument which is a custom error message\n   * to show when the assertion fails. The message can also be given as the\n   * second argument to `expect`. When not providing two arguments, always use\n   * the second form.\n   *\n   *     var goodFn = function () {};\n   *\n   *     expect(goodFn).to.throw(TypeError, 'x', 'nooo why fail??');\n   *     expect(goodFn, 'nooo why fail??').to.throw();\n   *\n   * Due to limitations in ES5, `.throw` may not always work as expected when\n   * using a transpiler such as Babel or TypeScript. In particular, it may\n   * produce unexpected results when subclassing the built-in `Error` object and\n   * then passing the subclassed constructor to `.throw`. See your transpiler's\n   * docs for details:\n   *\n   * - ([Babel](https://babeljs.io/docs/usage/caveats/#classes))\n   * - ([TypeScript](https://github.com/Microsoft/TypeScript/wiki/Breaking-Changes#extending-built-ins-like-error-array-and-map-may-no-longer-work))\n   *\n   * Beware of some common mistakes when using the `throw` assertion. One common\n   * mistake is to accidentally invoke the function yourself instead of letting\n   * the `throw` assertion invoke the function for you. For example, when\n   * testing if a function named `fn` throws, provide `fn` instead of `fn()` as\n   * the target for the assertion.\n   *\n   *     expect(fn).to.throw();     // Good! Tests `fn` as desired\n   *     expect(fn()).to.throw();   // Bad! Tests result of `fn()`, not `fn`\n   *\n   * If you need to assert that your function `fn` throws when passed certain\n   * arguments, then wrap a call to `fn` inside of another function.\n   *\n   *     expect(function () { fn(42); }).to.throw();  // Function expression\n   *     expect(() => fn(42)).to.throw();             // ES6 arrow function\n   *\n   * Another common mistake is to provide an object method (or any stand-alone\n   * function that relies on `this`) as the target of the assertion. Doing so is\n   * problematic because the `this` context will be lost when the function is\n   * invoked by `.throw`; there's no way for it to know what `this` is supposed\n   * to be. There are two ways around this problem. One solution is to wrap the\n   * method or function call inside of another function. Another solution is to\n   * use `bind`.\n   *\n   *     expect(function () { cat.meow(); }).to.throw();  // Function expression\n   *     expect(() => cat.meow()).to.throw();             // ES6 arrow function\n   *     expect(cat.meow.bind(cat)).to.throw();           // Bind\n   *\n   * Finally, it's worth mentioning that it's a best practice in JavaScript to\n   * only throw `Error` and derivatives of `Error` such as `ReferenceError`,\n   * `TypeError`, and user-defined objects that extend `Error`. No other type of\n   * value will generate a stack trace when initialized. With that said, the\n   * `throw` assertion does technically support any type of value being thrown,\n   * not just `Error` and its derivatives.\n   *\n   * The aliases `.throws` and `.Throw` can be used interchangeably with\n   * `.throw`.\n   *\n   * @name throw\n   * @alias throws\n   * @alias Throw\n   * @param {Error|ErrorConstructor} errorLike\n   * @param {String|RegExp} errMsgMatcher error message\n   * @param {String} msg _optional_\n   * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types\n   * @returns error for chaining (null if no error)\n   * @namespace BDD\n   * @api public\n   */\n\n  function assertThrows (errorLike, errMsgMatcher, msg) {\n    if (msg) flag(this, 'message', msg);\n    var obj = flag(this, 'object')\n      , ssfi = flag(this, 'ssfi')\n      , flagMsg = flag(this, 'message')\n      , negate = flag(this, 'negate') || false;\n    new Assertion(obj, flagMsg, ssfi, true).is.a('function');\n\n    if (errorLike instanceof RegExp || typeof errorLike === 'string') {\n      errMsgMatcher = errorLike;\n      errorLike = null;\n    }\n\n    var caughtErr;\n    try {\n      obj();\n    } catch (err) {\n      caughtErr = err;\n    }\n\n    // If we have the negate flag enabled and at least one valid argument it means we do expect an error\n    // but we want it to match a given set of criteria\n    var everyArgIsUndefined = errorLike === undefined && errMsgMatcher === undefined;\n\n    // If we've got the negate flag enabled and both args, we should only fail if both aren't compatible\n    // See Issue #551 and PR #683@GitHub\n    var everyArgIsDefined = Boolean(errorLike && errMsgMatcher);\n    var errorLikeFail = false;\n    var errMsgMatcherFail = false;\n\n    // Checking if error was thrown\n    if (everyArgIsUndefined || !everyArgIsUndefined && !negate) {\n      // We need this to display results correctly according to their types\n      var errorLikeString = 'an error';\n      if (errorLike instanceof Error) {\n        errorLikeString = '#{exp}';\n      } else if (errorLike) {\n        errorLikeString = _.checkError.getConstructorName(errorLike);\n      }\n\n      this.assert(\n          caughtErr\n        , 'expected #{this} to throw ' + errorLikeString\n        , 'expected #{this} to not throw an error but #{act} was thrown'\n        , errorLike && errorLike.toString()\n        , (caughtErr instanceof Error ?\n            caughtErr.toString() : (typeof caughtErr === 'string' ? caughtErr : caughtErr &&\n                                    _.checkError.getConstructorName(caughtErr)))\n      );\n    }\n\n    if (errorLike && caughtErr) {\n      // We should compare instances only if `errorLike` is an instance of `Error`\n      if (errorLike instanceof Error) {\n        var isCompatibleInstance = _.checkError.compatibleInstance(caughtErr, errorLike);\n\n        if (isCompatibleInstance === negate) {\n          // These checks were created to ensure we won't fail too soon when we've got both args and a negate\n          // See Issue #551 and PR #683@GitHub\n          if (everyArgIsDefined && negate) {\n            errorLikeFail = true;\n          } else {\n            this.assert(\n                negate\n              , 'expected #{this} to throw #{exp} but #{act} was thrown'\n              , 'expected #{this} to not throw #{exp}' + (caughtErr && !negate ? ' but #{act} was thrown' : '')\n              , errorLike.toString()\n              , caughtErr.toString()\n            );\n          }\n        }\n      }\n\n      var isCompatibleConstructor = _.checkError.compatibleConstructor(caughtErr, errorLike);\n      if (isCompatibleConstructor === negate) {\n        if (everyArgIsDefined && negate) {\n            errorLikeFail = true;\n        } else {\n          this.assert(\n              negate\n            , 'expected #{this} to throw #{exp} but #{act} was thrown'\n            , 'expected #{this} to not throw #{exp}' + (caughtErr ? ' but #{act} was thrown' : '')\n            , (errorLike instanceof Error ? errorLike.toString() : errorLike && _.checkError.getConstructorName(errorLike))\n            , (caughtErr instanceof Error ? caughtErr.toString() : caughtErr && _.checkError.getConstructorName(caughtErr))\n          );\n        }\n      }\n    }\n\n    if (caughtErr && errMsgMatcher !== undefined && errMsgMatcher !== null) {\n      // Here we check compatible messages\n      var placeholder = 'including';\n      if (errMsgMatcher instanceof RegExp) {\n        placeholder = 'matching'\n      }\n\n      var isCompatibleMessage = _.checkError.compatibleMessage(caughtErr, errMsgMatcher);\n      if (isCompatibleMessage === negate) {\n        if (everyArgIsDefined && negate) {\n            errMsgMatcherFail = true;\n        } else {\n          this.assert(\n            negate\n            , 'expected #{this} to throw error ' + placeholder + ' #{exp} but got #{act}'\n            , 'expected #{this} to throw error not ' + placeholder + ' #{exp}'\n            ,  errMsgMatcher\n            ,  _.checkError.getMessage(caughtErr)\n          );\n        }\n      }\n    }\n\n    // If both assertions failed and both should've matched we throw an error\n    if (errorLikeFail && errMsgMatcherFail) {\n      this.assert(\n        negate\n        , 'expected #{this} to throw #{exp} but #{act} was thrown'\n        , 'expected #{this} to not throw #{exp}' + (caughtErr ? ' but #{act} was thrown' : '')\n        , (errorLike instanceof Error ? errorLike.toString() : errorLike && _.checkError.getConstructorName(errorLike))\n        , (caughtErr instanceof Error ? caughtErr.toString() : caughtErr && _.checkError.getConstructorName(caughtErr))\n      );\n    }\n\n    flag(this, 'object', caughtErr);\n  };\n\n  Assertion.addMethod('throw', assertThrows);\n  Assertion.addMethod('throws', assertThrows);\n  Assertion.addMethod('Throw', assertThrows);\n\n  /**\n   * ### .respondTo(method[, msg])\n   *\n   * When the target is a non-function object, `.respondTo` asserts that the\n   * target has a method with the given name `method`. The method can be own or\n   * inherited, and it can be enumerable or non-enumerable.\n   *\n   *     function Cat () {}\n   *     Cat.prototype.meow = function () {};\n   *\n   *     expect(new Cat()).to.respondTo('meow');\n   *\n   * When the target is a function, `.respondTo` asserts that the target's\n   * `prototype` property has a method with the given name `method`. Again, the\n   * method can be own or inherited, and it can be enumerable or non-enumerable.\n   *\n   *     function Cat () {}\n   *     Cat.prototype.meow = function () {};\n   *\n   *     expect(Cat).to.respondTo('meow');\n   *\n   * Add `.itself` earlier in the chain to force `.respondTo` to treat the\n   * target as a non-function object, even if it's a function. Thus, it asserts\n   * that the target has a method with the given name `method`, rather than\n   * asserting that the target's `prototype` property has a method with the\n   * given name `method`.\n   *\n   *     function Cat () {}\n   *     Cat.prototype.meow = function () {};\n   *     Cat.hiss = function () {};\n   *\n   *     expect(Cat).itself.to.respondTo('hiss').but.not.respondTo('meow');\n   *\n   * When not adding `.itself`, it's important to check the target's type before\n   * using `.respondTo`. See the `.a` doc for info on checking a target's type.\n   *\n   *     function Cat () {}\n   *     Cat.prototype.meow = function () {};\n   *\n   *     expect(new Cat()).to.be.an('object').that.respondsTo('meow');\n   *\n   * Add `.not` earlier in the chain to negate `.respondTo`.\n   *\n   *     function Dog () {}\n   *     Dog.prototype.bark = function () {};\n   *\n   *     expect(new Dog()).to.not.respondTo('meow');\n   *\n   * `.respondTo` accepts an optional `msg` argument which is a custom error\n   * message to show when the assertion fails. The message can also be given as\n   * the second argument to `expect`.\n   *\n   *     expect({}).to.respondTo('meow', 'nooo why fail??');\n   *     expect({}, 'nooo why fail??').to.respondTo('meow');\n   *\n   * The alias `.respondsTo` can be used interchangeably with `.respondTo`.\n   *\n   * @name respondTo\n   * @alias respondsTo\n   * @param {String} method\n   * @param {String} msg _optional_\n   * @namespace BDD\n   * @api public\n   */\n\n  function respondTo (method, msg) {\n    if (msg) flag(this, 'message', msg);\n    var obj = flag(this, 'object')\n      , itself = flag(this, 'itself')\n      , context = ('function' === typeof obj && !itself)\n        ? obj.prototype[method]\n        : obj[method];\n\n    this.assert(\n        'function' === typeof context\n      , 'expected #{this} to respond to ' + _.inspect(method)\n      , 'expected #{this} to not respond to ' + _.inspect(method)\n    );\n  }\n\n  Assertion.addMethod('respondTo', respondTo);\n  Assertion.addMethod('respondsTo', respondTo);\n\n  /**\n   * ### .itself\n   *\n   * Forces all `.respondTo` assertions that follow in the chain to behave as if\n   * the target is a non-function object, even if it's a function. Thus, it\n   * causes `.respondTo` to assert that the target has a method with the given\n   * name, rather than asserting that the target's `prototype` property has a\n   * method with the given name.\n   *\n   *     function Cat () {}\n   *     Cat.prototype.meow = function () {};\n   *     Cat.hiss = function () {};\n   *\n   *     expect(Cat).itself.to.respondTo('hiss').but.not.respondTo('meow');\n   *\n   * @name itself\n   * @namespace BDD\n   * @api public\n   */\n\n  Assertion.addProperty('itself', function () {\n    flag(this, 'itself', true);\n  });\n\n  /**\n   * ### .satisfy(matcher[, msg])\n   *\n   * Invokes the given `matcher` function with the target being passed as the\n   * first argument, and asserts that the value returned is truthy.\n   *\n   *     expect(1).to.satisfy(function(num) {\n   *       return num > 0;\n   *     });\n   *\n   * Add `.not` earlier in the chain to negate `.satisfy`.\n   *\n   *     expect(1).to.not.satisfy(function(num) {\n   *       return num > 2;\n   *     });\n   *\n   * `.satisfy` accepts an optional `msg` argument which is a custom error\n   * message to show when the assertion fails. The message can also be given as\n   * the second argument to `expect`.\n   *\n   *     expect(1).to.satisfy(function(num) {\n   *       return num > 2;\n   *     }, 'nooo why fail??');\n   *\n   *     expect(1, 'nooo why fail??').to.satisfy(function(num) {\n   *       return num > 2;\n   *     });\n   *\n   * The alias `.satisfies` can be used interchangeably with `.satisfy`.\n   *\n   * @name satisfy\n   * @alias satisfies\n   * @param {Function} matcher\n   * @param {String} msg _optional_\n   * @namespace BDD\n   * @api public\n   */\n\n  function satisfy (matcher, msg) {\n    if (msg) flag(this, 'message', msg);\n    var obj = flag(this, 'object');\n    var result = matcher(obj);\n    this.assert(\n        result\n      , 'expected #{this} to satisfy ' + _.objDisplay(matcher)\n      , 'expected #{this} to not satisfy' + _.objDisplay(matcher)\n      , flag(this, 'negate') ? false : true\n      , result\n    );\n  }\n\n  Assertion.addMethod('satisfy', satisfy);\n  Assertion.addMethod('satisfies', satisfy);\n\n  /**\n   * ### .closeTo(expected, delta[, msg])\n   *\n   * Asserts that the target is a number that's within a given +/- `delta` range\n   * of the given number `expected`. However, it's often best to assert that the\n   * target is equal to its expected value.\n   *\n   *     // Recommended\n   *     expect(1.5).to.equal(1.5);\n   *\n   *     // Not recommended\n   *     expect(1.5).to.be.closeTo(1, 0.5);\n   *     expect(1.5).to.be.closeTo(2, 0.5);\n   *     expect(1.5).to.be.closeTo(1, 1);\n   *\n   * Add `.not` earlier in the chain to negate `.closeTo`.\n   *\n   *     expect(1.5).to.equal(1.5); // Recommended\n   *     expect(1.5).to.not.be.closeTo(3, 1); // Not recommended\n   *\n   * `.closeTo` accepts an optional `msg` argument which is a custom error\n   * message to show when the assertion fails. The message can also be given as\n   * the second argument to `expect`.\n   *\n   *     expect(1.5).to.be.closeTo(3, 1, 'nooo why fail??');\n   *     expect(1.5, 'nooo why fail??').to.be.closeTo(3, 1);\n   *\n   * The alias `.approximately` can be used interchangeably with `.closeTo`.\n   *\n   * @name closeTo\n   * @alias approximately\n   * @param {Number} expected\n   * @param {Number} delta\n   * @param {String} msg _optional_\n   * @namespace BDD\n   * @api public\n   */\n\n  function closeTo(expected, delta, msg) {\n    if (msg) flag(this, 'message', msg);\n    var obj = flag(this, 'object')\n      , flagMsg = flag(this, 'message')\n      , ssfi = flag(this, 'ssfi');\n\n    new Assertion(obj, flagMsg, ssfi, true).is.a('number');\n    if (typeof expected !== 'number' || typeof delta !== 'number') {\n      flagMsg = flagMsg ? flagMsg + ': ' : '';\n      throw new AssertionError(\n          flagMsg + 'the arguments to closeTo or approximately must be numbers',\n          undefined,\n          ssfi\n      );\n    }\n\n    this.assert(\n        Math.abs(obj - expected) <= delta\n      , 'expected #{this} to be close to ' + expected + ' +/- ' + delta\n      , 'expected #{this} not to be close to ' + expected + ' +/- ' + delta\n    );\n  }\n\n  Assertion.addMethod('closeTo', closeTo);\n  Assertion.addMethod('approximately', closeTo);\n\n  // Note: Duplicates are ignored if testing for inclusion instead of sameness.\n  function isSubsetOf(subset, superset, cmp, contains, ordered) {\n    if (!contains) {\n      if (subset.length !== superset.length) return false;\n      superset = superset.slice();\n    }\n\n    return subset.every(function(elem, idx) {\n      if (ordered) return cmp ? cmp(elem, superset[idx]) : elem === superset[idx];\n\n      if (!cmp) {\n        var matchIdx = superset.indexOf(elem);\n        if (matchIdx === -1) return false;\n\n        // Remove match from superset so not counted twice if duplicate in subset.\n        if (!contains) superset.splice(matchIdx, 1);\n        return true;\n      }\n\n      return superset.some(function(elem2, matchIdx) {\n        if (!cmp(elem, elem2)) return false;\n\n        // Remove match from superset so not counted twice if duplicate in subset.\n        if (!contains) superset.splice(matchIdx, 1);\n        return true;\n      });\n    });\n  }\n\n  /**\n   * ### .members(set[, msg])\n   *\n   * Asserts that the target array has the same members as the given array\n   * `set`.\n   *\n   *     expect([1, 2, 3]).to.have.members([2, 1, 3]);\n   *     expect([1, 2, 2]).to.have.members([2, 1, 2]);\n   *\n   * By default, members are compared using strict (`===`) equality. Add `.deep`\n   * earlier in the chain to use deep equality instead. See the `deep-eql`\n   * project page for info on the deep equality algorithm:\n   * https://github.com/chaijs/deep-eql.\n   *\n   *     // Target array deeply (but not strictly) has member `{a: 1}`\n   *     expect([{a: 1}]).to.have.deep.members([{a: 1}]);\n   *     expect([{a: 1}]).to.not.have.members([{a: 1}]);\n   *\n   * By default, order doesn't matter. Add `.ordered` earlier in the chain to\n   * require that members appear in the same order.\n   *\n   *     expect([1, 2, 3]).to.have.ordered.members([1, 2, 3]);\n   *     expect([1, 2, 3]).to.have.members([2, 1, 3])\n   *       .but.not.ordered.members([2, 1, 3]);\n   *\n   * By default, both arrays must be the same size. Add `.include` earlier in\n   * the chain to require that the target's members be a superset of the\n   * expected members. Note that duplicates are ignored in the subset when\n   * `.include` is added.\n   *\n   *     // Target array is a superset of [1, 2] but not identical\n   *     expect([1, 2, 3]).to.include.members([1, 2]);\n   *     expect([1, 2, 3]).to.not.have.members([1, 2]);\n   *\n   *     // Duplicates in the subset are ignored\n   *     expect([1, 2, 3]).to.include.members([1, 2, 2, 2]);\n   *\n   * `.deep`, `.ordered`, and `.include` can all be combined. However, if\n   * `.include` and `.ordered` are combined, the ordering begins at the start of\n   * both arrays.\n   *\n   *     expect([{a: 1}, {b: 2}, {c: 3}])\n   *       .to.include.deep.ordered.members([{a: 1}, {b: 2}])\n   *       .but.not.include.deep.ordered.members([{b: 2}, {c: 3}]);\n   *\n   * Add `.not` earlier in the chain to negate `.members`. However, it's\n   * dangerous to do so. The problem is that it creates uncertain expectations\n   * by asserting that the target array doesn't have all of the same members as\n   * the given array `set` but may or may not have some of them. It's often best\n   * to identify the exact output that's expected, and then write an assertion\n   * that only accepts that exact output.\n   *\n   *     expect([1, 2]).to.not.include(3).and.not.include(4); // Recommended\n   *     expect([1, 2]).to.not.have.members([3, 4]); // Not recommended\n   *\n   * `.members` accepts an optional `msg` argument which is a custom error\n   * message to show when the assertion fails. The message can also be given as\n   * the second argument to `expect`.\n   *\n   *     expect([1, 2]).to.have.members([1, 2, 3], 'nooo why fail??');\n   *     expect([1, 2], 'nooo why fail??').to.have.members([1, 2, 3]);\n   *\n   * @name members\n   * @param {Array} set\n   * @param {String} msg _optional_\n   * @namespace BDD\n   * @api public\n   */\n\n  Assertion.addMethod('members', function (subset, msg) {\n    if (msg) flag(this, 'message', msg);\n    var obj = flag(this, 'object')\n      , flagMsg = flag(this, 'message')\n      , ssfi = flag(this, 'ssfi');\n\n    new Assertion(obj, flagMsg, ssfi, true).to.be.an('array');\n    new Assertion(subset, flagMsg, ssfi, true).to.be.an('array');\n\n    var contains = flag(this, 'contains');\n    var ordered = flag(this, 'ordered');\n\n    var subject, failMsg, failNegateMsg;\n\n    if (contains) {\n      subject = ordered ? 'an ordered superset' : 'a superset';\n      failMsg = 'expected #{this} to be ' + subject + ' of #{exp}';\n      failNegateMsg = 'expected #{this} to not be ' + subject + ' of #{exp}';\n    } else {\n      subject = ordered ? 'ordered members' : 'members';\n      failMsg = 'expected #{this} to have the same ' + subject + ' as #{exp}';\n      failNegateMsg = 'expected #{this} to not have the same ' + subject + ' as #{exp}';\n    }\n\n    var cmp = flag(this, 'deep') ? _.eql : undefined;\n\n    this.assert(\n        isSubsetOf(subset, obj, cmp, contains, ordered)\n      , failMsg\n      , failNegateMsg\n      , subset\n      , obj\n      , true\n    );\n  });\n\n  /**\n   * ### .oneOf(list[, msg])\n   *\n   * Asserts that the target is a member of the given array `list`. However,\n   * it's often best to assert that the target is equal to its expected value.\n   *\n   *     expect(1).to.equal(1); // Recommended\n   *     expect(1).to.be.oneOf([1, 2, 3]); // Not recommended\n   *\n   * Comparisons are performed using strict (`===`) equality.\n   *\n   * Add `.not` earlier in the chain to negate `.oneOf`.\n   *\n   *     expect(1).to.equal(1); // Recommended\n   *     expect(1).to.not.be.oneOf([2, 3, 4]); // Not recommended\n   *\n   * `.oneOf` accepts an optional `msg` argument which is a custom error message\n   * to show when the assertion fails. The message can also be given as the\n   * second argument to `expect`.\n   *\n   *     expect(1).to.be.oneOf([2, 3, 4], 'nooo why fail??');\n   *     expect(1, 'nooo why fail??').to.be.oneOf([2, 3, 4]);\n   *\n   * @name oneOf\n   * @param {Array<*>} list\n   * @param {String} msg _optional_\n   * @namespace BDD\n   * @api public\n   */\n\n  function oneOf (list, msg) {\n    if (msg) flag(this, 'message', msg);\n    var expected = flag(this, 'object')\n      , flagMsg = flag(this, 'message')\n      , ssfi = flag(this, 'ssfi');\n    new Assertion(list, flagMsg, ssfi, true).to.be.an('array');\n\n    this.assert(\n        list.indexOf(expected) > -1\n      , 'expected #{this} to be one of #{exp}'\n      , 'expected #{this} to not be one of #{exp}'\n      , list\n      , expected\n    );\n  }\n\n  Assertion.addMethod('oneOf', oneOf);\n\n  /**\n   * ### .change(subject[, prop[, msg]])\n   *\n   * When one argument is provided, `.change` asserts that the given function\n   * `subject` returns a different value when it's invoked before the target\n   * function compared to when it's invoked afterward. However, it's often best\n   * to assert that `subject` is equal to its expected value.\n   *\n   *     var dots = ''\n   *       , addDot = function () { dots += '.'; }\n   *       , getDots = function () { return dots; };\n   *\n   *     // Recommended\n   *     expect(getDots()).to.equal('');\n   *     addDot();\n   *     expect(getDots()).to.equal('.');\n   *\n   *     // Not recommended\n   *     expect(addDot).to.change(getDots);\n   *\n   * When two arguments are provided, `.change` asserts that the value of the\n   * given object `subject`'s `prop` property is different before invoking the\n   * target function compared to afterward.\n   *\n   *     var myObj = {dots: ''}\n   *       , addDot = function () { myObj.dots += '.'; };\n   *\n   *     // Recommended\n   *     expect(myObj).to.have.property('dots', '');\n   *     addDot();\n   *     expect(myObj).to.have.property('dots', '.');\n   *\n   *     // Not recommended\n   *     expect(addDot).to.change(myObj, 'dots');\n   *\n   * Strict (`===`) equality is used to compare before and after values.\n   *\n   * Add `.not` earlier in the chain to negate `.change`.\n   *\n   *     var dots = ''\n   *       , noop = function () {}\n   *       , getDots = function () { return dots; };\n   *\n   *     expect(noop).to.not.change(getDots);\n   *\n   *     var myObj = {dots: ''}\n   *       , noop = function () {};\n   *\n   *     expect(noop).to.not.change(myObj, 'dots');\n   *\n   * `.change` accepts an optional `msg` argument which is a custom error\n   * message to show when the assertion fails. The message can also be given as\n   * the second argument to `expect`. When not providing two arguments, always\n   * use the second form.\n   *\n   *     var myObj = {dots: ''}\n   *       , addDot = function () { myObj.dots += '.'; };\n   *\n   *     expect(addDot).to.not.change(myObj, 'dots', 'nooo why fail??');\n   *\n   *     var dots = ''\n   *       , addDot = function () { dots += '.'; }\n   *       , getDots = function () { return dots; };\n   *\n   *     expect(addDot, 'nooo why fail??').to.not.change(getDots);\n   *\n   * `.change` also causes all `.by` assertions that follow in the chain to\n   * assert how much a numeric subject was increased or decreased by. However,\n   * it's dangerous to use `.change.by`. The problem is that it creates\n   * uncertain expectations by asserting that the subject either increases by\n   * the given delta, or that it decreases by the given delta. It's often best\n   * to identify the exact output that's expected, and then write an assertion\n   * that only accepts that exact output.\n   *\n   *     var myObj = {val: 1}\n   *       , addTwo = function () { myObj.val += 2; }\n   *       , subtractTwo = function () { myObj.val -= 2; };\n   *\n   *     expect(addTwo).to.increase(myObj, 'val').by(2); // Recommended\n   *     expect(addTwo).to.change(myObj, 'val').by(2); // Not recommended\n   *\n   *     expect(subtractTwo).to.decrease(myObj, 'val').by(2); // Recommended\n   *     expect(subtractTwo).to.change(myObj, 'val').by(2); // Not recommended\n   *\n   * The alias `.changes` can be used interchangeably with `.change`.\n   *\n   * @name change\n   * @alias changes\n   * @param {String} subject\n   * @param {String} prop name _optional_\n   * @param {String} msg _optional_\n   * @namespace BDD\n   * @api public\n   */\n\n  function assertChanges (subject, prop, msg) {\n    if (msg) flag(this, 'message', msg);\n    var fn = flag(this, 'object')\n      , flagMsg = flag(this, 'message')\n      , ssfi = flag(this, 'ssfi');\n    new Assertion(fn, flagMsg, ssfi, true).is.a('function');\n\n    var initial;\n    if (!prop) {\n      new Assertion(subject, flagMsg, ssfi, true).is.a('function');\n      initial = subject();\n    } else {\n      new Assertion(subject, flagMsg, ssfi, true).to.have.property(prop);\n      initial = subject[prop];\n    }\n\n    fn();\n\n    var final = prop === undefined || prop === null ? subject() : subject[prop];\n    var msgObj = prop === undefined || prop === null ? initial : '.' + prop;\n\n    // This gets flagged because of the .by(delta) assertion\n    flag(this, 'deltaMsgObj', msgObj);\n    flag(this, 'initialDeltaValue', initial);\n    flag(this, 'finalDeltaValue', final);\n    flag(this, 'deltaBehavior', 'change');\n    flag(this, 'realDelta', final !== initial);\n\n    this.assert(\n      initial !== final\n      , 'expected ' + msgObj + ' to change'\n      , 'expected ' + msgObj + ' to not change'\n    );\n  }\n\n  Assertion.addMethod('change', assertChanges);\n  Assertion.addMethod('changes', assertChanges);\n\n  /**\n   * ### .increase(subject[, prop[, msg]])\n   *\n   * When one argument is provided, `.increase` asserts that the given function\n   * `subject` returns a greater number when it's invoked after invoking the\n   * target function compared to when it's invoked beforehand. `.increase` also\n   * causes all `.by` assertions that follow in the chain to assert how much\n   * greater of a number is returned. It's often best to assert that the return\n   * value increased by the expected amount, rather than asserting it increased\n   * by any amount.\n   *\n   *     var val = 1\n   *       , addTwo = function () { val += 2; }\n   *       , getVal = function () { return val; };\n   *\n   *     expect(addTwo).to.increase(getVal).by(2); // Recommended\n   *     expect(addTwo).to.increase(getVal); // Not recommended\n   *\n   * When two arguments are provided, `.increase` asserts that the value of the\n   * given object `subject`'s `prop` property is greater after invoking the\n   * target function compared to beforehand.\n   *\n   *     var myObj = {val: 1}\n   *       , addTwo = function () { myObj.val += 2; };\n   *\n   *     expect(addTwo).to.increase(myObj, 'val').by(2); // Recommended\n   *     expect(addTwo).to.increase(myObj, 'val'); // Not recommended\n   *\n   * Add `.not` earlier in the chain to negate `.increase`. However, it's\n   * dangerous to do so. The problem is that it creates uncertain expectations\n   * by asserting that the subject either decreases, or that it stays the same.\n   * It's often best to identify the exact output that's expected, and then\n   * write an assertion that only accepts that exact output.\n   *\n   * When the subject is expected to decrease, it's often best to assert that it\n   * decreased by the expected amount.\n   *\n   *     var myObj = {val: 1}\n   *       , subtractTwo = function () { myObj.val -= 2; };\n   *\n   *     expect(subtractTwo).to.decrease(myObj, 'val').by(2); // Recommended\n   *     expect(subtractTwo).to.not.increase(myObj, 'val'); // Not recommended\n   *\n   * When the subject is expected to stay the same, it's often best to assert\n   * exactly that.\n   *\n   *     var myObj = {val: 1}\n   *       , noop = function () {};\n   *\n   *     expect(noop).to.not.change(myObj, 'val'); // Recommended\n   *     expect(noop).to.not.increase(myObj, 'val'); // Not recommended\n   *\n   * `.increase` accepts an optional `msg` argument which is a custom error\n   * message to show when the assertion fails. The message can also be given as\n   * the second argument to `expect`. When not providing two arguments, always\n   * use the second form.\n   *\n   *     var myObj = {val: 1}\n   *       , noop = function () {};\n   *\n   *     expect(noop).to.increase(myObj, 'val', 'nooo why fail??');\n   *\n   *     var val = 1\n   *       , noop = function () {}\n   *       , getVal = function () { return val; };\n   *\n   *     expect(noop, 'nooo why fail??').to.increase(getVal);\n   *\n   * The alias `.increases` can be used interchangeably with `.increase`.\n   *\n   * @name increase\n   * @alias increases\n   * @param {String|Function} subject\n   * @param {String} prop name _optional_\n   * @param {String} msg _optional_\n   * @namespace BDD\n   * @api public\n   */\n\n  function assertIncreases (subject, prop, msg) {\n    if (msg) flag(this, 'message', msg);\n    var fn = flag(this, 'object')\n      , flagMsg = flag(this, 'message')\n      , ssfi = flag(this, 'ssfi');\n    new Assertion(fn, flagMsg, ssfi, true).is.a('function');\n\n    var initial;\n    if (!prop) {\n      new Assertion(subject, flagMsg, ssfi, true).is.a('function');\n      initial = subject();\n    } else {\n      new Assertion(subject, flagMsg, ssfi, true).to.have.property(prop);\n      initial = subject[prop];\n    }\n\n    // Make sure that the target is a number\n    new Assertion(initial, flagMsg, ssfi, true).is.a('number');\n\n    fn();\n\n    var final = prop === undefined || prop === null ? subject() : subject[prop];\n    var msgObj = prop === undefined || prop === null ? initial : '.' + prop;\n\n    flag(this, 'deltaMsgObj', msgObj);\n    flag(this, 'initialDeltaValue', initial);\n    flag(this, 'finalDeltaValue', final);\n    flag(this, 'deltaBehavior', 'increase');\n    flag(this, 'realDelta', final - initial);\n\n    this.assert(\n      final - initial > 0\n      , 'expected ' + msgObj + ' to increase'\n      , 'expected ' + msgObj + ' to not increase'\n    );\n  }\n\n  Assertion.addMethod('increase', assertIncreases);\n  Assertion.addMethod('increases', assertIncreases);\n\n  /**\n   * ### .decrease(subject[, prop[, msg]])\n   *\n   * When one argument is provided, `.decrease` asserts that the given function\n   * `subject` returns a lesser number when it's invoked after invoking the\n   * target function compared to when it's invoked beforehand. `.decrease` also\n   * causes all `.by` assertions that follow in the chain to assert how much\n   * lesser of a number is returned. It's often best to assert that the return\n   * value decreased by the expected amount, rather than asserting it decreased\n   * by any amount.\n   *\n   *     var val = 1\n   *       , subtractTwo = function () { val -= 2; }\n   *       , getVal = function () { return val; };\n   *\n   *     expect(subtractTwo).to.decrease(getVal).by(2); // Recommended\n   *     expect(subtractTwo).to.decrease(getVal); // Not recommended\n   *\n   * When two arguments are provided, `.decrease` asserts that the value of the\n   * given object `subject`'s `prop` property is lesser after invoking the\n   * target function compared to beforehand.\n   *\n   *     var myObj = {val: 1}\n   *       , subtractTwo = function () { myObj.val -= 2; };\n   *\n   *     expect(subtractTwo).to.decrease(myObj, 'val').by(2); // Recommended\n   *     expect(subtractTwo).to.decrease(myObj, 'val'); // Not recommended\n   *\n   * Add `.not` earlier in the chain to negate `.decrease`. However, it's\n   * dangerous to do so. The problem is that it creates uncertain expectations\n   * by asserting that the subject either increases, or that it stays the same.\n   * It's often best to identify the exact output that's expected, and then\n   * write an assertion that only accepts that exact output.\n   *\n   * When the subject is expected to increase, it's often best to assert that it\n   * increased by the expected amount.\n   *\n   *     var myObj = {val: 1}\n   *       , addTwo = function () { myObj.val += 2; };\n   *\n   *     expect(addTwo).to.increase(myObj, 'val').by(2); // Recommended\n   *     expect(addTwo).to.not.decrease(myObj, 'val'); // Not recommended\n   *\n   * When the subject is expected to stay the same, it's often best to assert\n   * exactly that.\n   *\n   *     var myObj = {val: 1}\n   *       , noop = function () {};\n   *\n   *     expect(noop).to.not.change(myObj, 'val'); // Recommended\n   *     expect(noop).to.not.decrease(myObj, 'val'); // Not recommended\n   *\n   * `.decrease` accepts an optional `msg` argument which is a custom error\n   * message to show when the assertion fails. The message can also be given as\n   * the second argument to `expect`. When not providing two arguments, always\n   * use the second form.\n   *\n   *     var myObj = {val: 1}\n   *       , noop = function () {};\n   *\n   *     expect(noop).to.decrease(myObj, 'val', 'nooo why fail??');\n   *\n   *     var val = 1\n   *       , noop = function () {}\n   *       , getVal = function () { return val; };\n   *\n   *     expect(noop, 'nooo why fail??').to.decrease(getVal);\n   *\n   * The alias `.decreases` can be used interchangeably with `.decrease`.\n   *\n   * @name decrease\n   * @alias decreases\n   * @param {String|Function} subject\n   * @param {String} prop name _optional_\n   * @param {String} msg _optional_\n   * @namespace BDD\n   * @api public\n   */\n\n  function assertDecreases (subject, prop, msg) {\n    if (msg) flag(this, 'message', msg);\n    var fn = flag(this, 'object')\n      , flagMsg = flag(this, 'message')\n      , ssfi = flag(this, 'ssfi');\n    new Assertion(fn, flagMsg, ssfi, true).is.a('function');\n\n    var initial;\n    if (!prop) {\n      new Assertion(subject, flagMsg, ssfi, true).is.a('function');\n      initial = subject();\n    } else {\n      new Assertion(subject, flagMsg, ssfi, true).to.have.property(prop);\n      initial = subject[prop];\n    }\n\n    // Make sure that the target is a number\n    new Assertion(initial, flagMsg, ssfi, true).is.a('number');\n\n    fn();\n\n    var final = prop === undefined || prop === null ? subject() : subject[prop];\n    var msgObj = prop === undefined || prop === null ? initial : '.' + prop;\n\n    flag(this, 'deltaMsgObj', msgObj);\n    flag(this, 'initialDeltaValue', initial);\n    flag(this, 'finalDeltaValue', final);\n    flag(this, 'deltaBehavior', 'decrease');\n    flag(this, 'realDelta', initial - final);\n\n    this.assert(\n      final - initial < 0\n      , 'expected ' + msgObj + ' to decrease'\n      , 'expected ' + msgObj + ' to not decrease'\n    );\n  }\n\n  Assertion.addMethod('decrease', assertDecreases);\n  Assertion.addMethod('decreases', assertDecreases);\n\n  /**\n   * ### .by(delta[, msg])\n   *\n   * When following an `.increase` assertion in the chain, `.by` asserts that\n   * the subject of the `.increase` assertion increased by the given `delta`.\n   *\n   *     var myObj = {val: 1}\n   *       , addTwo = function () { myObj.val += 2; };\n   *\n   *     expect(addTwo).to.increase(myObj, 'val').by(2);\n   *\n   * When following a `.decrease` assertion in the chain, `.by` asserts that the\n   * subject of the `.decrease` assertion decreased by the given `delta`.\n   *\n   *     var myObj = {val: 1}\n   *       , subtractTwo = function () { myObj.val -= 2; };\n   *\n   *     expect(subtractTwo).to.decrease(myObj, 'val').by(2);\n   *\n   * When following a `.change` assertion in the chain, `.by` asserts that the\n   * subject of the `.change` assertion either increased or decreased by the\n   * given `delta`. However, it's dangerous to use `.change.by`. The problem is\n   * that it creates uncertain expectations. It's often best to identify the\n   * exact output that's expected, and then write an assertion that only accepts\n   * that exact output.\n   *\n   *     var myObj = {val: 1}\n   *       , addTwo = function () { myObj.val += 2; }\n   *       , subtractTwo = function () { myObj.val -= 2; };\n   *\n   *     expect(addTwo).to.increase(myObj, 'val').by(2); // Recommended\n   *     expect(addTwo).to.change(myObj, 'val').by(2); // Not recommended\n   *\n   *     expect(subtractTwo).to.decrease(myObj, 'val').by(2); // Recommended\n   *     expect(subtractTwo).to.change(myObj, 'val').by(2); // Not recommended\n   *\n   * Add `.not` earlier in the chain to negate `.by`. However, it's often best\n   * to assert that the subject changed by its expected delta, rather than\n   * asserting that it didn't change by one of countless unexpected deltas.\n   *\n   *     var myObj = {val: 1}\n   *       , addTwo = function () { myObj.val += 2; };\n   *\n   *     // Recommended\n   *     expect(addTwo).to.increase(myObj, 'val').by(2);\n   *\n   *     // Not recommended\n   *     expect(addTwo).to.increase(myObj, 'val').but.not.by(3);\n   *\n   * `.by` accepts an optional `msg` argument which is a custom error message to\n   * show when the assertion fails. The message can also be given as the second\n   * argument to `expect`.\n   *\n   *     var myObj = {val: 1}\n   *       , addTwo = function () { myObj.val += 2; };\n   *\n   *     expect(addTwo).to.increase(myObj, 'val').by(3, 'nooo why fail??');\n   *     expect(addTwo, 'nooo why fail??').to.increase(myObj, 'val').by(3);\n   *\n   * @name by\n   * @param {Number} delta\n   * @param {String} msg _optional_\n   * @namespace BDD\n   * @api public\n   */\n\n  function assertDelta(delta, msg) {\n    if (msg) flag(this, 'message', msg);\n\n    var msgObj = flag(this, 'deltaMsgObj');\n    var initial = flag(this, 'initialDeltaValue');\n    var final = flag(this, 'finalDeltaValue');\n    var behavior = flag(this, 'deltaBehavior');\n    var realDelta = flag(this, 'realDelta');\n\n    var expression;\n    if (behavior === 'change') {\n      expression = Math.abs(final - initial) === Math.abs(delta);\n    } else {\n      expression = realDelta === Math.abs(delta);\n    }\n\n    this.assert(\n      expression\n      , 'expected ' + msgObj + ' to ' + behavior + ' by ' + delta\n      , 'expected ' + msgObj + ' to not ' + behavior + ' by ' + delta\n    );\n  }\n\n  Assertion.addMethod('by', assertDelta);\n\n  /**\n   * ### .extensible\n   *\n   * Asserts that the target is extensible, which means that new properties can\n   * be added to it. Primitives are never extensible.\n   *\n   *     expect({a: 1}).to.be.extensible;\n   *\n   * Add `.not` earlier in the chain to negate `.extensible`.\n   *\n   *     var nonExtensibleObject = Object.preventExtensions({})\n   *       , sealedObject = Object.seal({})\n   *       , frozenObject = Object.freeze({});\n   *\n   *     expect(nonExtensibleObject).to.not.be.extensible;\n   *     expect(sealedObject).to.not.be.extensible;\n   *     expect(frozenObject).to.not.be.extensible;\n   *     expect(1).to.not.be.extensible;\n   *\n   * A custom error message can be given as the second argument to `expect`.\n   *\n   *     expect(1, 'nooo why fail??').to.be.extensible;\n   *\n   * @name extensible\n   * @namespace BDD\n   * @api public\n   */\n\n  Assertion.addProperty('extensible', function() {\n    var obj = flag(this, 'object');\n\n    // In ES5, if the argument to this method is a primitive, then it will cause a TypeError.\n    // In ES6, a non-object argument will be treated as if it was a non-extensible ordinary object, simply return false.\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/isExtensible\n    // The following provides ES6 behavior for ES5 environments.\n\n    var isExtensible = obj === Object(obj) && Object.isExtensible(obj);\n\n    this.assert(\n      isExtensible\n      , 'expected #{this} to be extensible'\n      , 'expected #{this} to not be extensible'\n    );\n  });\n\n  /**\n   * ### .sealed\n   *\n   * Asserts that the target is sealed, which means that new properties can't be\n   * added to it, and its existing properties can't be reconfigured or deleted.\n   * However, it's possible that its existing properties can still be reassigned\n   * to different values. Primitives are always sealed.\n   *\n   *     var sealedObject = Object.seal({});\n   *     var frozenObject = Object.freeze({});\n   *\n   *     expect(sealedObject).to.be.sealed;\n   *     expect(frozenObject).to.be.sealed;\n   *     expect(1).to.be.sealed;\n   *\n   * Add `.not` earlier in the chain to negate `.sealed`.\n   *\n   *     expect({a: 1}).to.not.be.sealed;\n   *\n   * A custom error message can be given as the second argument to `expect`.\n   *\n   *     expect({a: 1}, 'nooo why fail??').to.be.sealed;\n   *\n   * @name sealed\n   * @namespace BDD\n   * @api public\n   */\n\n  Assertion.addProperty('sealed', function() {\n    var obj = flag(this, 'object');\n\n    // In ES5, if the argument to this method is a primitive, then it will cause a TypeError.\n    // In ES6, a non-object argument will be treated as if it was a sealed ordinary object, simply return true.\n    // See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/isSealed\n    // The following provides ES6 behavior for ES5 environments.\n\n    var isSealed = obj === Object(obj) ? Object.isSealed(obj) : true;\n\n    this.assert(\n      isSealed\n      , 'expected #{this} to be sealed'\n      , 'expected #{this} to not be sealed'\n    );\n  });\n\n  /**\n   * ### .frozen\n   *\n   * Asserts that the target is frozen, which means that new properties can't be\n   * added to it, and its existing properties can't be reassigned to different\n   * values, reconfigured, or deleted. Primitives are always frozen.\n   *\n   *     var frozenObject = Object.freeze({});\n   *\n   *     expect(frozenObject).to.be.frozen;\n   *     expect(1).to.be.frozen;\n   *\n   * Add `.not` earlier in the chain to negate `.frozen`.\n   *\n   *     expect({a: 1}).to.not.be.frozen;\n   *\n   * A custom error message can be given as the second argument to `expect`.\n   *\n   *     expect({a: 1}, 'nooo why fail??').to.be.frozen;\n   *\n   * @name frozen\n   * @namespace BDD\n   * @api public\n   */\n\n  Assertion.addProperty('frozen', function() {\n    var obj = flag(this, 'object');\n\n    // In ES5, if the argument to this method is a primitive, then it will cause a TypeError.\n    // In ES6, a non-object argument will be treated as if it was a frozen ordinary object, simply return true.\n    // See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/isFrozen\n    // The following provides ES6 behavior for ES5 environments.\n\n    var isFrozen = obj === Object(obj) ? Object.isFrozen(obj) : true;\n\n    this.assert(\n      isFrozen\n      , 'expected #{this} to be frozen'\n      , 'expected #{this} to not be frozen'\n    );\n  });\n\n  /**\n   * ### .finite\n   *\n   * Asserts that the target is a number, and isn't `NaN` or positive/negative\n   * `Infinity`.\n   *\n   *     expect(1).to.be.finite;\n   *\n   * Add `.not` earlier in the chain to negate `.finite`. However, it's\n   * dangerous to do so. The problem is that it creates uncertain expectations\n   * by asserting that the subject either isn't a number, or that it's `NaN`, or\n   * that it's positive `Infinity`, or that it's negative `Infinity`. It's often\n   * best to identify the exact output that's expected, and then write an\n   * assertion that only accepts that exact output.\n   *\n   * When the target isn't expected to be a number, it's often best to assert\n   * that it's the expected type, rather than asserting that it isn't one of\n   * many unexpected types.\n   *\n   *     expect('foo').to.be.a('string'); // Recommended\n   *     expect('foo').to.not.be.finite; // Not recommended\n   *\n   * When the target is expected to be `NaN`, it's often best to assert exactly\n   * that.\n   *\n   *     expect(NaN).to.be.NaN; // Recommended\n   *     expect(NaN).to.not.be.finite; // Not recommended\n   *\n   * When the target is expected to be positive infinity, it's often best to\n   * assert exactly that.\n   *\n   *     expect(Infinity).to.equal(Infinity); // Recommended\n   *     expect(Infinity).to.not.be.finite; // Not recommended\n   *\n   * When the target is expected to be negative infinity, it's often best to\n   * assert exactly that.\n   *\n   *     expect(-Infinity).to.equal(-Infinity); // Recommended\n   *     expect(-Infinity).to.not.be.finite; // Not recommended\n   *\n   * A custom error message can be given as the second argument to `expect`.\n   *\n   *     expect('foo', 'nooo why fail??').to.be.finite;\n   *\n   * @name finite\n   * @namespace BDD\n   * @api public\n   */\n\n  Assertion.addProperty('finite', function(msg) {\n    var obj = flag(this, 'object');\n\n    this.assert(\n        typeof obj === 'number' && isFinite(obj)\n      , 'expected #{this} to be a finite number'\n      , 'expected #{this} to not be a finite number'\n    );\n  });\n};\n\n\n//# sourceURL=webpack:////home/marcello/mdb/Code/olojs/node_modules/chai/lib/chai/core/assertions.js?");

/***/ }),

/***/ "../../node_modules/chai/lib/chai/interface/assert.js":
/*!************************************************************************************!*\
  !*** /home/marcello/mdb/Code/olojs/node_modules/chai/lib/chai/interface/assert.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/*!\n * chai\n * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\nmodule.exports = function (chai, util) {\n  /*!\n   * Chai dependencies.\n   */\n\n  var Assertion = chai.Assertion\n    , flag = util.flag;\n\n  /*!\n   * Module export.\n   */\n\n  /**\n   * ### assert(expression, message)\n   *\n   * Write your own test expressions.\n   *\n   *     assert('foo' !== 'bar', 'foo is not bar');\n   *     assert(Array.isArray([]), 'empty arrays are arrays');\n   *\n   * @param {Mixed} expression to test for truthiness\n   * @param {String} message to display on error\n   * @name assert\n   * @namespace Assert\n   * @api public\n   */\n\n  var assert = chai.assert = function (express, errmsg) {\n    var test = new Assertion(null, null, chai.assert, true);\n    test.assert(\n        express\n      , errmsg\n      , '[ negation message unavailable ]'\n    );\n  };\n\n  /**\n   * ### .fail([message])\n   * ### .fail(actual, expected, [message], [operator])\n   *\n   * Throw a failure. Node.js `assert` module-compatible.\n   *\n   *     assert.fail();\n   *     assert.fail(\"custom error message\");\n   *     assert.fail(1, 2);\n   *     assert.fail(1, 2, \"custom error message\");\n   *     assert.fail(1, 2, \"custom error message\", \">\");\n   *     assert.fail(1, 2, undefined, \">\");\n   *\n   * @name fail\n   * @param {Mixed} actual\n   * @param {Mixed} expected\n   * @param {String} message\n   * @param {String} operator\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.fail = function (actual, expected, message, operator) {\n    if (arguments.length < 2) {\n        // Comply with Node's fail([message]) interface\n\n        message = actual;\n        actual = undefined;\n    }\n\n    message = message || 'assert.fail()';\n    throw new chai.AssertionError(message, {\n        actual: actual\n      , expected: expected\n      , operator: operator\n    }, assert.fail);\n  };\n\n  /**\n   * ### .isOk(object, [message])\n   *\n   * Asserts that `object` is truthy.\n   *\n   *     assert.isOk('everything', 'everything is ok');\n   *     assert.isOk(false, 'this will fail');\n   *\n   * @name isOk\n   * @alias ok\n   * @param {Mixed} object to test\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.isOk = function (val, msg) {\n    new Assertion(val, msg, assert.isOk, true).is.ok;\n  };\n\n  /**\n   * ### .isNotOk(object, [message])\n   *\n   * Asserts that `object` is falsy.\n   *\n   *     assert.isNotOk('everything', 'this will fail');\n   *     assert.isNotOk(false, 'this will pass');\n   *\n   * @name isNotOk\n   * @alias notOk\n   * @param {Mixed} object to test\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.isNotOk = function (val, msg) {\n    new Assertion(val, msg, assert.isNotOk, true).is.not.ok;\n  };\n\n  /**\n   * ### .equal(actual, expected, [message])\n   *\n   * Asserts non-strict equality (`==`) of `actual` and `expected`.\n   *\n   *     assert.equal(3, '3', '== coerces values to strings');\n   *\n   * @name equal\n   * @param {Mixed} actual\n   * @param {Mixed} expected\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.equal = function (act, exp, msg) {\n    var test = new Assertion(act, msg, assert.equal, true);\n\n    test.assert(\n        exp == flag(test, 'object')\n      , 'expected #{this} to equal #{exp}'\n      , 'expected #{this} to not equal #{act}'\n      , exp\n      , act\n      , true\n    );\n  };\n\n  /**\n   * ### .notEqual(actual, expected, [message])\n   *\n   * Asserts non-strict inequality (`!=`) of `actual` and `expected`.\n   *\n   *     assert.notEqual(3, 4, 'these numbers are not equal');\n   *\n   * @name notEqual\n   * @param {Mixed} actual\n   * @param {Mixed} expected\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.notEqual = function (act, exp, msg) {\n    var test = new Assertion(act, msg, assert.notEqual, true);\n\n    test.assert(\n        exp != flag(test, 'object')\n      , 'expected #{this} to not equal #{exp}'\n      , 'expected #{this} to equal #{act}'\n      , exp\n      , act\n      , true\n    );\n  };\n\n  /**\n   * ### .strictEqual(actual, expected, [message])\n   *\n   * Asserts strict equality (`===`) of `actual` and `expected`.\n   *\n   *     assert.strictEqual(true, true, 'these booleans are strictly equal');\n   *\n   * @name strictEqual\n   * @param {Mixed} actual\n   * @param {Mixed} expected\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.strictEqual = function (act, exp, msg) {\n    new Assertion(act, msg, assert.strictEqual, true).to.equal(exp);\n  };\n\n  /**\n   * ### .notStrictEqual(actual, expected, [message])\n   *\n   * Asserts strict inequality (`!==`) of `actual` and `expected`.\n   *\n   *     assert.notStrictEqual(3, '3', 'no coercion for strict equality');\n   *\n   * @name notStrictEqual\n   * @param {Mixed} actual\n   * @param {Mixed} expected\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.notStrictEqual = function (act, exp, msg) {\n    new Assertion(act, msg, assert.notStrictEqual, true).to.not.equal(exp);\n  };\n\n  /**\n   * ### .deepEqual(actual, expected, [message])\n   *\n   * Asserts that `actual` is deeply equal to `expected`.\n   *\n   *     assert.deepEqual({ tea: 'green' }, { tea: 'green' });\n   *\n   * @name deepEqual\n   * @param {Mixed} actual\n   * @param {Mixed} expected\n   * @param {String} message\n   * @alias deepStrictEqual\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.deepEqual = assert.deepStrictEqual = function (act, exp, msg) {\n    new Assertion(act, msg, assert.deepEqual, true).to.eql(exp);\n  };\n\n  /**\n   * ### .notDeepEqual(actual, expected, [message])\n   *\n   * Assert that `actual` is not deeply equal to `expected`.\n   *\n   *     assert.notDeepEqual({ tea: 'green' }, { tea: 'jasmine' });\n   *\n   * @name notDeepEqual\n   * @param {Mixed} actual\n   * @param {Mixed} expected\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.notDeepEqual = function (act, exp, msg) {\n    new Assertion(act, msg, assert.notDeepEqual, true).to.not.eql(exp);\n  };\n\n   /**\n   * ### .isAbove(valueToCheck, valueToBeAbove, [message])\n   *\n   * Asserts `valueToCheck` is strictly greater than (>) `valueToBeAbove`.\n   *\n   *     assert.isAbove(5, 2, '5 is strictly greater than 2');\n   *\n   * @name isAbove\n   * @param {Mixed} valueToCheck\n   * @param {Mixed} valueToBeAbove\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.isAbove = function (val, abv, msg) {\n    new Assertion(val, msg, assert.isAbove, true).to.be.above(abv);\n  };\n\n   /**\n   * ### .isAtLeast(valueToCheck, valueToBeAtLeast, [message])\n   *\n   * Asserts `valueToCheck` is greater than or equal to (>=) `valueToBeAtLeast`.\n   *\n   *     assert.isAtLeast(5, 2, '5 is greater or equal to 2');\n   *     assert.isAtLeast(3, 3, '3 is greater or equal to 3');\n   *\n   * @name isAtLeast\n   * @param {Mixed} valueToCheck\n   * @param {Mixed} valueToBeAtLeast\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.isAtLeast = function (val, atlst, msg) {\n    new Assertion(val, msg, assert.isAtLeast, true).to.be.least(atlst);\n  };\n\n   /**\n   * ### .isBelow(valueToCheck, valueToBeBelow, [message])\n   *\n   * Asserts `valueToCheck` is strictly less than (<) `valueToBeBelow`.\n   *\n   *     assert.isBelow(3, 6, '3 is strictly less than 6');\n   *\n   * @name isBelow\n   * @param {Mixed} valueToCheck\n   * @param {Mixed} valueToBeBelow\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.isBelow = function (val, blw, msg) {\n    new Assertion(val, msg, assert.isBelow, true).to.be.below(blw);\n  };\n\n   /**\n   * ### .isAtMost(valueToCheck, valueToBeAtMost, [message])\n   *\n   * Asserts `valueToCheck` is less than or equal to (<=) `valueToBeAtMost`.\n   *\n   *     assert.isAtMost(3, 6, '3 is less than or equal to 6');\n   *     assert.isAtMost(4, 4, '4 is less than or equal to 4');\n   *\n   * @name isAtMost\n   * @param {Mixed} valueToCheck\n   * @param {Mixed} valueToBeAtMost\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.isAtMost = function (val, atmst, msg) {\n    new Assertion(val, msg, assert.isAtMost, true).to.be.most(atmst);\n  };\n\n  /**\n   * ### .isTrue(value, [message])\n   *\n   * Asserts that `value` is true.\n   *\n   *     var teaServed = true;\n   *     assert.isTrue(teaServed, 'the tea has been served');\n   *\n   * @name isTrue\n   * @param {Mixed} value\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.isTrue = function (val, msg) {\n    new Assertion(val, msg, assert.isTrue, true).is['true'];\n  };\n\n  /**\n   * ### .isNotTrue(value, [message])\n   *\n   * Asserts that `value` is not true.\n   *\n   *     var tea = 'tasty chai';\n   *     assert.isNotTrue(tea, 'great, time for tea!');\n   *\n   * @name isNotTrue\n   * @param {Mixed} value\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.isNotTrue = function (val, msg) {\n    new Assertion(val, msg, assert.isNotTrue, true).to.not.equal(true);\n  };\n\n  /**\n   * ### .isFalse(value, [message])\n   *\n   * Asserts that `value` is false.\n   *\n   *     var teaServed = false;\n   *     assert.isFalse(teaServed, 'no tea yet? hmm...');\n   *\n   * @name isFalse\n   * @param {Mixed} value\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.isFalse = function (val, msg) {\n    new Assertion(val, msg, assert.isFalse, true).is['false'];\n  };\n\n  /**\n   * ### .isNotFalse(value, [message])\n   *\n   * Asserts that `value` is not false.\n   *\n   *     var tea = 'tasty chai';\n   *     assert.isNotFalse(tea, 'great, time for tea!');\n   *\n   * @name isNotFalse\n   * @param {Mixed} value\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.isNotFalse = function (val, msg) {\n    new Assertion(val, msg, assert.isNotFalse, true).to.not.equal(false);\n  };\n\n  /**\n   * ### .isNull(value, [message])\n   *\n   * Asserts that `value` is null.\n   *\n   *     assert.isNull(err, 'there was no error');\n   *\n   * @name isNull\n   * @param {Mixed} value\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.isNull = function (val, msg) {\n    new Assertion(val, msg, assert.isNull, true).to.equal(null);\n  };\n\n  /**\n   * ### .isNotNull(value, [message])\n   *\n   * Asserts that `value` is not null.\n   *\n   *     var tea = 'tasty chai';\n   *     assert.isNotNull(tea, 'great, time for tea!');\n   *\n   * @name isNotNull\n   * @param {Mixed} value\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.isNotNull = function (val, msg) {\n    new Assertion(val, msg, assert.isNotNull, true).to.not.equal(null);\n  };\n\n  /**\n   * ### .isNaN\n   *\n   * Asserts that value is NaN.\n   *\n   *     assert.isNaN(NaN, 'NaN is NaN');\n   *\n   * @name isNaN\n   * @param {Mixed} value\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.isNaN = function (val, msg) {\n    new Assertion(val, msg, assert.isNaN, true).to.be.NaN;\n  };\n\n  /**\n   * ### .isNotNaN\n   *\n   * Asserts that value is not NaN.\n   *\n   *     assert.isNotNaN(4, '4 is not NaN');\n   *\n   * @name isNotNaN\n   * @param {Mixed} value\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n  assert.isNotNaN = function (val, msg) {\n    new Assertion(val, msg, assert.isNotNaN, true).not.to.be.NaN;\n  };\n\n  /**\n   * ### .exists\n   *\n   * Asserts that the target is neither `null` nor `undefined`.\n   *\n   *     var foo = 'hi';\n   *\n   *     assert.exists(foo, 'foo is neither `null` nor `undefined`');\n   *\n   * @name exists\n   * @param {Mixed} value\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.exists = function (val, msg) {\n    new Assertion(val, msg, assert.exists, true).to.exist;\n  };\n\n  /**\n   * ### .notExists\n   *\n   * Asserts that the target is either `null` or `undefined`.\n   *\n   *     var bar = null\n   *       , baz;\n   *\n   *     assert.notExists(bar);\n   *     assert.notExists(baz, 'baz is either null or undefined');\n   *\n   * @name notExists\n   * @param {Mixed} value\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.notExists = function (val, msg) {\n    new Assertion(val, msg, assert.notExists, true).to.not.exist;\n  };\n\n  /**\n   * ### .isUndefined(value, [message])\n   *\n   * Asserts that `value` is `undefined`.\n   *\n   *     var tea;\n   *     assert.isUndefined(tea, 'no tea defined');\n   *\n   * @name isUndefined\n   * @param {Mixed} value\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.isUndefined = function (val, msg) {\n    new Assertion(val, msg, assert.isUndefined, true).to.equal(undefined);\n  };\n\n  /**\n   * ### .isDefined(value, [message])\n   *\n   * Asserts that `value` is not `undefined`.\n   *\n   *     var tea = 'cup of chai';\n   *     assert.isDefined(tea, 'tea has been defined');\n   *\n   * @name isDefined\n   * @param {Mixed} value\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.isDefined = function (val, msg) {\n    new Assertion(val, msg, assert.isDefined, true).to.not.equal(undefined);\n  };\n\n  /**\n   * ### .isFunction(value, [message])\n   *\n   * Asserts that `value` is a function.\n   *\n   *     function serveTea() { return 'cup of tea'; };\n   *     assert.isFunction(serveTea, 'great, we can have tea now');\n   *\n   * @name isFunction\n   * @param {Mixed} value\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.isFunction = function (val, msg) {\n    new Assertion(val, msg, assert.isFunction, true).to.be.a('function');\n  };\n\n  /**\n   * ### .isNotFunction(value, [message])\n   *\n   * Asserts that `value` is _not_ a function.\n   *\n   *     var serveTea = [ 'heat', 'pour', 'sip' ];\n   *     assert.isNotFunction(serveTea, 'great, we have listed the steps');\n   *\n   * @name isNotFunction\n   * @param {Mixed} value\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.isNotFunction = function (val, msg) {\n    new Assertion(val, msg, assert.isNotFunction, true).to.not.be.a('function');\n  };\n\n  /**\n   * ### .isObject(value, [message])\n   *\n   * Asserts that `value` is an object of type 'Object' (as revealed by `Object.prototype.toString`).\n   * _The assertion does not match subclassed objects._\n   *\n   *     var selection = { name: 'Chai', serve: 'with spices' };\n   *     assert.isObject(selection, 'tea selection is an object');\n   *\n   * @name isObject\n   * @param {Mixed} value\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.isObject = function (val, msg) {\n    new Assertion(val, msg, assert.isObject, true).to.be.a('object');\n  };\n\n  /**\n   * ### .isNotObject(value, [message])\n   *\n   * Asserts that `value` is _not_ an object of type 'Object' (as revealed by `Object.prototype.toString`).\n   *\n   *     var selection = 'chai'\n   *     assert.isNotObject(selection, 'tea selection is not an object');\n   *     assert.isNotObject(null, 'null is not an object');\n   *\n   * @name isNotObject\n   * @param {Mixed} value\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.isNotObject = function (val, msg) {\n    new Assertion(val, msg, assert.isNotObject, true).to.not.be.a('object');\n  };\n\n  /**\n   * ### .isArray(value, [message])\n   *\n   * Asserts that `value` is an array.\n   *\n   *     var menu = [ 'green', 'chai', 'oolong' ];\n   *     assert.isArray(menu, 'what kind of tea do we want?');\n   *\n   * @name isArray\n   * @param {Mixed} value\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.isArray = function (val, msg) {\n    new Assertion(val, msg, assert.isArray, true).to.be.an('array');\n  };\n\n  /**\n   * ### .isNotArray(value, [message])\n   *\n   * Asserts that `value` is _not_ an array.\n   *\n   *     var menu = 'green|chai|oolong';\n   *     assert.isNotArray(menu, 'what kind of tea do we want?');\n   *\n   * @name isNotArray\n   * @param {Mixed} value\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.isNotArray = function (val, msg) {\n    new Assertion(val, msg, assert.isNotArray, true).to.not.be.an('array');\n  };\n\n  /**\n   * ### .isString(value, [message])\n   *\n   * Asserts that `value` is a string.\n   *\n   *     var teaOrder = 'chai';\n   *     assert.isString(teaOrder, 'order placed');\n   *\n   * @name isString\n   * @param {Mixed} value\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.isString = function (val, msg) {\n    new Assertion(val, msg, assert.isString, true).to.be.a('string');\n  };\n\n  /**\n   * ### .isNotString(value, [message])\n   *\n   * Asserts that `value` is _not_ a string.\n   *\n   *     var teaOrder = 4;\n   *     assert.isNotString(teaOrder, 'order placed');\n   *\n   * @name isNotString\n   * @param {Mixed} value\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.isNotString = function (val, msg) {\n    new Assertion(val, msg, assert.isNotString, true).to.not.be.a('string');\n  };\n\n  /**\n   * ### .isNumber(value, [message])\n   *\n   * Asserts that `value` is a number.\n   *\n   *     var cups = 2;\n   *     assert.isNumber(cups, 'how many cups');\n   *\n   * @name isNumber\n   * @param {Number} value\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.isNumber = function (val, msg) {\n    new Assertion(val, msg, assert.isNumber, true).to.be.a('number');\n  };\n\n  /**\n   * ### .isNotNumber(value, [message])\n   *\n   * Asserts that `value` is _not_ a number.\n   *\n   *     var cups = '2 cups please';\n   *     assert.isNotNumber(cups, 'how many cups');\n   *\n   * @name isNotNumber\n   * @param {Mixed} value\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.isNotNumber = function (val, msg) {\n    new Assertion(val, msg, assert.isNotNumber, true).to.not.be.a('number');\n  };\n\n   /**\n   * ### .isFinite(value, [message])\n   *\n   * Asserts that `value` is a finite number. Unlike `.isNumber`, this will fail for `NaN` and `Infinity`.\n   *\n   *     var cups = 2;\n   *     assert.isFinite(cups, 'how many cups');\n   *\n   *     assert.isFinite(NaN); // throws\n   *\n   * @name isFinite\n   * @param {Number} value\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.isFinite = function (val, msg) {\n    new Assertion(val, msg, assert.isFinite, true).to.be.finite;\n  };\n\n  /**\n   * ### .isBoolean(value, [message])\n   *\n   * Asserts that `value` is a boolean.\n   *\n   *     var teaReady = true\n   *       , teaServed = false;\n   *\n   *     assert.isBoolean(teaReady, 'is the tea ready');\n   *     assert.isBoolean(teaServed, 'has tea been served');\n   *\n   * @name isBoolean\n   * @param {Mixed} value\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.isBoolean = function (val, msg) {\n    new Assertion(val, msg, assert.isBoolean, true).to.be.a('boolean');\n  };\n\n  /**\n   * ### .isNotBoolean(value, [message])\n   *\n   * Asserts that `value` is _not_ a boolean.\n   *\n   *     var teaReady = 'yep'\n   *       , teaServed = 'nope';\n   *\n   *     assert.isNotBoolean(teaReady, 'is the tea ready');\n   *     assert.isNotBoolean(teaServed, 'has tea been served');\n   *\n   * @name isNotBoolean\n   * @param {Mixed} value\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.isNotBoolean = function (val, msg) {\n    new Assertion(val, msg, assert.isNotBoolean, true).to.not.be.a('boolean');\n  };\n\n  /**\n   * ### .typeOf(value, name, [message])\n   *\n   * Asserts that `value`'s type is `name`, as determined by\n   * `Object.prototype.toString`.\n   *\n   *     assert.typeOf({ tea: 'chai' }, 'object', 'we have an object');\n   *     assert.typeOf(['chai', 'jasmine'], 'array', 'we have an array');\n   *     assert.typeOf('tea', 'string', 'we have a string');\n   *     assert.typeOf(/tea/, 'regexp', 'we have a regular expression');\n   *     assert.typeOf(null, 'null', 'we have a null');\n   *     assert.typeOf(undefined, 'undefined', 'we have an undefined');\n   *\n   * @name typeOf\n   * @param {Mixed} value\n   * @param {String} name\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.typeOf = function (val, type, msg) {\n    new Assertion(val, msg, assert.typeOf, true).to.be.a(type);\n  };\n\n  /**\n   * ### .notTypeOf(value, name, [message])\n   *\n   * Asserts that `value`'s type is _not_ `name`, as determined by\n   * `Object.prototype.toString`.\n   *\n   *     assert.notTypeOf('tea', 'number', 'strings are not numbers');\n   *\n   * @name notTypeOf\n   * @param {Mixed} value\n   * @param {String} typeof name\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.notTypeOf = function (val, type, msg) {\n    new Assertion(val, msg, assert.notTypeOf, true).to.not.be.a(type);\n  };\n\n  /**\n   * ### .instanceOf(object, constructor, [message])\n   *\n   * Asserts that `value` is an instance of `constructor`.\n   *\n   *     var Tea = function (name) { this.name = name; }\n   *       , chai = new Tea('chai');\n   *\n   *     assert.instanceOf(chai, Tea, 'chai is an instance of tea');\n   *\n   * @name instanceOf\n   * @param {Object} object\n   * @param {Constructor} constructor\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.instanceOf = function (val, type, msg) {\n    new Assertion(val, msg, assert.instanceOf, true).to.be.instanceOf(type);\n  };\n\n  /**\n   * ### .notInstanceOf(object, constructor, [message])\n   *\n   * Asserts `value` is not an instance of `constructor`.\n   *\n   *     var Tea = function (name) { this.name = name; }\n   *       , chai = new String('chai');\n   *\n   *     assert.notInstanceOf(chai, Tea, 'chai is not an instance of tea');\n   *\n   * @name notInstanceOf\n   * @param {Object} object\n   * @param {Constructor} constructor\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.notInstanceOf = function (val, type, msg) {\n    new Assertion(val, msg, assert.notInstanceOf, true)\n      .to.not.be.instanceOf(type);\n  };\n\n  /**\n   * ### .include(haystack, needle, [message])\n   *\n   * Asserts that `haystack` includes `needle`. Can be used to assert the\n   * inclusion of a value in an array, a substring in a string, or a subset of\n   * properties in an object.\n   *\n   *     assert.include([1,2,3], 2, 'array contains value');\n   *     assert.include('foobar', 'foo', 'string contains substring');\n   *     assert.include({ foo: 'bar', hello: 'universe' }, { foo: 'bar' }, 'object contains property');\n   *\n   * Strict equality (===) is used. When asserting the inclusion of a value in\n   * an array, the array is searched for an element that's strictly equal to the\n   * given value. When asserting a subset of properties in an object, the object\n   * is searched for the given property keys, checking that each one is present\n   * and strictly equal to the given property value. For instance:\n   *\n   *     var obj1 = {a: 1}\n   *       , obj2 = {b: 2};\n   *     assert.include([obj1, obj2], obj1);\n   *     assert.include({foo: obj1, bar: obj2}, {foo: obj1});\n   *     assert.include({foo: obj1, bar: obj2}, {foo: obj1, bar: obj2});\n   *\n   * @name include\n   * @param {Array|String} haystack\n   * @param {Mixed} needle\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.include = function (exp, inc, msg) {\n    new Assertion(exp, msg, assert.include, true).include(inc);\n  };\n\n  /**\n   * ### .notInclude(haystack, needle, [message])\n   *\n   * Asserts that `haystack` does not include `needle`. Can be used to assert\n   * the absence of a value in an array, a substring in a string, or a subset of\n   * properties in an object.\n   *\n   *     assert.notInclude([1,2,3], 4, \"array doesn't contain value\");\n   *     assert.notInclude('foobar', 'baz', \"string doesn't contain substring\");\n   *     assert.notInclude({ foo: 'bar', hello: 'universe' }, { foo: 'baz' }, 'object doesn't contain property');\n   *\n   * Strict equality (===) is used. When asserting the absence of a value in an\n   * array, the array is searched to confirm the absence of an element that's\n   * strictly equal to the given value. When asserting a subset of properties in\n   * an object, the object is searched to confirm that at least one of the given\n   * property keys is either not present or not strictly equal to the given\n   * property value. For instance:\n   *\n   *     var obj1 = {a: 1}\n   *       , obj2 = {b: 2};\n   *     assert.notInclude([obj1, obj2], {a: 1});\n   *     assert.notInclude({foo: obj1, bar: obj2}, {foo: {a: 1}});\n   *     assert.notInclude({foo: obj1, bar: obj2}, {foo: obj1, bar: {b: 2}});\n   *\n   * @name notInclude\n   * @param {Array|String} haystack\n   * @param {Mixed} needle\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.notInclude = function (exp, inc, msg) {\n    new Assertion(exp, msg, assert.notInclude, true).not.include(inc);\n  };\n\n  /**\n   * ### .deepInclude(haystack, needle, [message])\n   *\n   * Asserts that `haystack` includes `needle`. Can be used to assert the\n   * inclusion of a value in an array or a subset of properties in an object.\n   * Deep equality is used.\n   *\n   *     var obj1 = {a: 1}\n   *       , obj2 = {b: 2};\n   *     assert.deepInclude([obj1, obj2], {a: 1});\n   *     assert.deepInclude({foo: obj1, bar: obj2}, {foo: {a: 1}});\n   *     assert.deepInclude({foo: obj1, bar: obj2}, {foo: {a: 1}, bar: {b: 2}});\n   *\n   * @name deepInclude\n   * @param {Array|String} haystack\n   * @param {Mixed} needle\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.deepInclude = function (exp, inc, msg) {\n    new Assertion(exp, msg, assert.deepInclude, true).deep.include(inc);\n  };\n\n  /**\n   * ### .notDeepInclude(haystack, needle, [message])\n   *\n   * Asserts that `haystack` does not include `needle`. Can be used to assert\n   * the absence of a value in an array or a subset of properties in an object.\n   * Deep equality is used.\n   *\n   *     var obj1 = {a: 1}\n   *       , obj2 = {b: 2};\n   *     assert.notDeepInclude([obj1, obj2], {a: 9});\n   *     assert.notDeepInclude({foo: obj1, bar: obj2}, {foo: {a: 9}});\n   *     assert.notDeepInclude({foo: obj1, bar: obj2}, {foo: {a: 1}, bar: {b: 9}});\n   *\n   * @name notDeepInclude\n   * @param {Array|String} haystack\n   * @param {Mixed} needle\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.notDeepInclude = function (exp, inc, msg) {\n    new Assertion(exp, msg, assert.notDeepInclude, true).not.deep.include(inc);\n  };\n\n  /**\n   * ### .nestedInclude(haystack, needle, [message])\n   *\n   * Asserts that 'haystack' includes 'needle'.\n   * Can be used to assert the inclusion of a subset of properties in an\n   * object.\n   * Enables the use of dot- and bracket-notation for referencing nested\n   * properties.\n   * '[]' and '.' in property names can be escaped using double backslashes.\n   *\n   *     assert.nestedInclude({'.a': {'b': 'x'}}, {'\\\\.a.[b]': 'x'});\n   *     assert.nestedInclude({'a': {'[b]': 'x'}}, {'a.\\\\[b\\\\]': 'x'});\n   *\n   * @name nestedInclude\n   * @param {Object} haystack\n   * @param {Object} needle\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.nestedInclude = function (exp, inc, msg) {\n    new Assertion(exp, msg, assert.nestedInclude, true).nested.include(inc);\n  };\n\n  /**\n   * ### .notNestedInclude(haystack, needle, [message])\n   *\n   * Asserts that 'haystack' does not include 'needle'.\n   * Can be used to assert the absence of a subset of properties in an\n   * object.\n   * Enables the use of dot- and bracket-notation for referencing nested\n   * properties.\n   * '[]' and '.' in property names can be escaped using double backslashes.\n   *\n   *     assert.notNestedInclude({'.a': {'b': 'x'}}, {'\\\\.a.b': 'y'});\n   *     assert.notNestedInclude({'a': {'[b]': 'x'}}, {'a.\\\\[b\\\\]': 'y'});\n   *\n   * @name notNestedInclude\n   * @param {Object} haystack\n   * @param {Object} needle\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.notNestedInclude = function (exp, inc, msg) {\n    new Assertion(exp, msg, assert.notNestedInclude, true)\n      .not.nested.include(inc);\n  };\n\n  /**\n   * ### .deepNestedInclude(haystack, needle, [message])\n   *\n   * Asserts that 'haystack' includes 'needle'.\n   * Can be used to assert the inclusion of a subset of properties in an\n   * object while checking for deep equality.\n   * Enables the use of dot- and bracket-notation for referencing nested\n   * properties.\n   * '[]' and '.' in property names can be escaped using double backslashes.\n   *\n   *     assert.deepNestedInclude({a: {b: [{x: 1}]}}, {'a.b[0]': {x: 1}});\n   *     assert.deepNestedInclude({'.a': {'[b]': {x: 1}}}, {'\\\\.a.\\\\[b\\\\]': {x: 1}});\n   *\n   * @name deepNestedInclude\n   * @param {Object} haystack\n   * @param {Object} needle\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.deepNestedInclude = function(exp, inc, msg) {\n    new Assertion(exp, msg, assert.deepNestedInclude, true)\n      .deep.nested.include(inc);\n  };\n\n  /**\n   * ### .notDeepNestedInclude(haystack, needle, [message])\n   *\n   * Asserts that 'haystack' does not include 'needle'.\n   * Can be used to assert the absence of a subset of properties in an\n   * object while checking for deep equality.\n   * Enables the use of dot- and bracket-notation for referencing nested\n   * properties.\n   * '[]' and '.' in property names can be escaped using double backslashes.\n   *\n   *     assert.notDeepNestedInclude({a: {b: [{x: 1}]}}, {'a.b[0]': {y: 1}})\n   *     assert.notDeepNestedInclude({'.a': {'[b]': {x: 1}}}, {'\\\\.a.\\\\[b\\\\]': {y: 2}});\n   *\n   * @name notDeepNestedInclude\n   * @param {Object} haystack\n   * @param {Object} needle\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.notDeepNestedInclude = function(exp, inc, msg) {\n    new Assertion(exp, msg, assert.notDeepNestedInclude, true)\n      .not.deep.nested.include(inc);\n  };\n\n  /**\n   * ### .ownInclude(haystack, needle, [message])\n   *\n   * Asserts that 'haystack' includes 'needle'.\n   * Can be used to assert the inclusion of a subset of properties in an\n   * object while ignoring inherited properties.\n   *\n   *     assert.ownInclude({ a: 1 }, { a: 1 });\n   *\n   * @name ownInclude\n   * @param {Object} haystack\n   * @param {Object} needle\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.ownInclude = function(exp, inc, msg) {\n    new Assertion(exp, msg, assert.ownInclude, true).own.include(inc);\n  };\n\n  /**\n   * ### .notOwnInclude(haystack, needle, [message])\n   *\n   * Asserts that 'haystack' includes 'needle'.\n   * Can be used to assert the absence of a subset of properties in an\n   * object while ignoring inherited properties.\n   *\n   *     Object.prototype.b = 2;\n   *\n   *     assert.notOwnInclude({ a: 1 }, { b: 2 });\n   *\n   * @name notOwnInclude\n   * @param {Object} haystack\n   * @param {Object} needle\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.notOwnInclude = function(exp, inc, msg) {\n    new Assertion(exp, msg, assert.notOwnInclude, true).not.own.include(inc);\n  };\n\n  /**\n   * ### .deepOwnInclude(haystack, needle, [message])\n   *\n   * Asserts that 'haystack' includes 'needle'.\n   * Can be used to assert the inclusion of a subset of properties in an\n   * object while ignoring inherited properties and checking for deep equality.\n   *\n   *      assert.deepOwnInclude({a: {b: 2}}, {a: {b: 2}});\n   *\n   * @name deepOwnInclude\n   * @param {Object} haystack\n   * @param {Object} needle\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.deepOwnInclude = function(exp, inc, msg) {\n    new Assertion(exp, msg, assert.deepOwnInclude, true)\n      .deep.own.include(inc);\n  };\n\n   /**\n   * ### .notDeepOwnInclude(haystack, needle, [message])\n   *\n   * Asserts that 'haystack' includes 'needle'.\n   * Can be used to assert the absence of a subset of properties in an\n   * object while ignoring inherited properties and checking for deep equality.\n   *\n   *      assert.notDeepOwnInclude({a: {b: 2}}, {a: {c: 3}});\n   *\n   * @name notDeepOwnInclude\n   * @param {Object} haystack\n   * @param {Object} needle\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.notDeepOwnInclude = function(exp, inc, msg) {\n    new Assertion(exp, msg, assert.notDeepOwnInclude, true)\n      .not.deep.own.include(inc);\n  };\n\n  /**\n   * ### .match(value, regexp, [message])\n   *\n   * Asserts that `value` matches the regular expression `regexp`.\n   *\n   *     assert.match('foobar', /^foo/, 'regexp matches');\n   *\n   * @name match\n   * @param {Mixed} value\n   * @param {RegExp} regexp\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.match = function (exp, re, msg) {\n    new Assertion(exp, msg, assert.match, true).to.match(re);\n  };\n\n  /**\n   * ### .notMatch(value, regexp, [message])\n   *\n   * Asserts that `value` does not match the regular expression `regexp`.\n   *\n   *     assert.notMatch('foobar', /^foo/, 'regexp does not match');\n   *\n   * @name notMatch\n   * @param {Mixed} value\n   * @param {RegExp} regexp\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.notMatch = function (exp, re, msg) {\n    new Assertion(exp, msg, assert.notMatch, true).to.not.match(re);\n  };\n\n  /**\n   * ### .property(object, property, [message])\n   *\n   * Asserts that `object` has a direct or inherited property named by\n   * `property`.\n   *\n   *     assert.property({ tea: { green: 'matcha' }}, 'tea');\n   *     assert.property({ tea: { green: 'matcha' }}, 'toString');\n   *\n   * @name property\n   * @param {Object} object\n   * @param {String} property\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.property = function (obj, prop, msg) {\n    new Assertion(obj, msg, assert.property, true).to.have.property(prop);\n  };\n\n  /**\n   * ### .notProperty(object, property, [message])\n   *\n   * Asserts that `object` does _not_ have a direct or inherited property named\n   * by `property`.\n   *\n   *     assert.notProperty({ tea: { green: 'matcha' }}, 'coffee');\n   *\n   * @name notProperty\n   * @param {Object} object\n   * @param {String} property\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.notProperty = function (obj, prop, msg) {\n    new Assertion(obj, msg, assert.notProperty, true)\n      .to.not.have.property(prop);\n  };\n\n  /**\n   * ### .propertyVal(object, property, value, [message])\n   *\n   * Asserts that `object` has a direct or inherited property named by\n   * `property` with a value given by `value`. Uses a strict equality check\n   * (===).\n   *\n   *     assert.propertyVal({ tea: 'is good' }, 'tea', 'is good');\n   *\n   * @name propertyVal\n   * @param {Object} object\n   * @param {String} property\n   * @param {Mixed} value\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.propertyVal = function (obj, prop, val, msg) {\n    new Assertion(obj, msg, assert.propertyVal, true)\n      .to.have.property(prop, val);\n  };\n\n  /**\n   * ### .notPropertyVal(object, property, value, [message])\n   *\n   * Asserts that `object` does _not_ have a direct or inherited property named\n   * by `property` with value given by `value`. Uses a strict equality check\n   * (===).\n   *\n   *     assert.notPropertyVal({ tea: 'is good' }, 'tea', 'is bad');\n   *     assert.notPropertyVal({ tea: 'is good' }, 'coffee', 'is good');\n   *\n   * @name notPropertyVal\n   * @param {Object} object\n   * @param {String} property\n   * @param {Mixed} value\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.notPropertyVal = function (obj, prop, val, msg) {\n    new Assertion(obj, msg, assert.notPropertyVal, true)\n      .to.not.have.property(prop, val);\n  };\n\n  /**\n   * ### .deepPropertyVal(object, property, value, [message])\n   *\n   * Asserts that `object` has a direct or inherited property named by\n   * `property` with a value given by `value`. Uses a deep equality check.\n   *\n   *     assert.deepPropertyVal({ tea: { green: 'matcha' } }, 'tea', { green: 'matcha' });\n   *\n   * @name deepPropertyVal\n   * @param {Object} object\n   * @param {String} property\n   * @param {Mixed} value\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.deepPropertyVal = function (obj, prop, val, msg) {\n    new Assertion(obj, msg, assert.deepPropertyVal, true)\n      .to.have.deep.property(prop, val);\n  };\n\n  /**\n   * ### .notDeepPropertyVal(object, property, value, [message])\n   *\n   * Asserts that `object` does _not_ have a direct or inherited property named\n   * by `property` with value given by `value`. Uses a deep equality check.\n   *\n   *     assert.notDeepPropertyVal({ tea: { green: 'matcha' } }, 'tea', { black: 'matcha' });\n   *     assert.notDeepPropertyVal({ tea: { green: 'matcha' } }, 'tea', { green: 'oolong' });\n   *     assert.notDeepPropertyVal({ tea: { green: 'matcha' } }, 'coffee', { green: 'matcha' });\n   *\n   * @name notDeepPropertyVal\n   * @param {Object} object\n   * @param {String} property\n   * @param {Mixed} value\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.notDeepPropertyVal = function (obj, prop, val, msg) {\n    new Assertion(obj, msg, assert.notDeepPropertyVal, true)\n      .to.not.have.deep.property(prop, val);\n  };\n\n  /**\n   * ### .ownProperty(object, property, [message])\n   *\n   * Asserts that `object` has a direct property named by `property`. Inherited\n   * properties aren't checked.\n   *\n   *     assert.ownProperty({ tea: { green: 'matcha' }}, 'tea');\n   *\n   * @name ownProperty\n   * @param {Object} object\n   * @param {String} property\n   * @param {String} message\n   * @api public\n   */\n\n  assert.ownProperty = function (obj, prop, msg) {\n    new Assertion(obj, msg, assert.ownProperty, true)\n      .to.have.own.property(prop);\n  };\n\n  /**\n   * ### .notOwnProperty(object, property, [message])\n   *\n   * Asserts that `object` does _not_ have a direct property named by\n   * `property`. Inherited properties aren't checked.\n   *\n   *     assert.notOwnProperty({ tea: { green: 'matcha' }}, 'coffee');\n   *     assert.notOwnProperty({}, 'toString');\n   *\n   * @name notOwnProperty\n   * @param {Object} object\n   * @param {String} property\n   * @param {String} message\n   * @api public\n   */\n\n  assert.notOwnProperty = function (obj, prop, msg) {\n    new Assertion(obj, msg, assert.notOwnProperty, true)\n      .to.not.have.own.property(prop);\n  };\n\n  /**\n   * ### .ownPropertyVal(object, property, value, [message])\n   *\n   * Asserts that `object` has a direct property named by `property` and a value\n   * equal to the provided `value`. Uses a strict equality check (===).\n   * Inherited properties aren't checked.\n   *\n   *     assert.ownPropertyVal({ coffee: 'is good'}, 'coffee', 'is good');\n   *\n   * @name ownPropertyVal\n   * @param {Object} object\n   * @param {String} property\n   * @param {Mixed} value\n   * @param {String} message\n   * @api public\n   */\n\n  assert.ownPropertyVal = function (obj, prop, value, msg) {\n    new Assertion(obj, msg, assert.ownPropertyVal, true)\n      .to.have.own.property(prop, value);\n  };\n\n  /**\n   * ### .notOwnPropertyVal(object, property, value, [message])\n   *\n   * Asserts that `object` does _not_ have a direct property named by `property`\n   * with a value equal to the provided `value`. Uses a strict equality check\n   * (===). Inherited properties aren't checked.\n   *\n   *     assert.notOwnPropertyVal({ tea: 'is better'}, 'tea', 'is worse');\n   *     assert.notOwnPropertyVal({}, 'toString', Object.prototype.toString);\n   *\n   * @name notOwnPropertyVal\n   * @param {Object} object\n   * @param {String} property\n   * @param {Mixed} value\n   * @param {String} message\n   * @api public\n   */\n\n  assert.notOwnPropertyVal = function (obj, prop, value, msg) {\n    new Assertion(obj, msg, assert.notOwnPropertyVal, true)\n      .to.not.have.own.property(prop, value);\n  };\n\n  /**\n   * ### .deepOwnPropertyVal(object, property, value, [message])\n   *\n   * Asserts that `object` has a direct property named by `property` and a value\n   * equal to the provided `value`. Uses a deep equality check. Inherited\n   * properties aren't checked.\n   *\n   *     assert.deepOwnPropertyVal({ tea: { green: 'matcha' } }, 'tea', { green: 'matcha' });\n   *\n   * @name deepOwnPropertyVal\n   * @param {Object} object\n   * @param {String} property\n   * @param {Mixed} value\n   * @param {String} message\n   * @api public\n   */\n\n  assert.deepOwnPropertyVal = function (obj, prop, value, msg) {\n    new Assertion(obj, msg, assert.deepOwnPropertyVal, true)\n      .to.have.deep.own.property(prop, value);\n  };\n\n  /**\n   * ### .notDeepOwnPropertyVal(object, property, value, [message])\n   *\n   * Asserts that `object` does _not_ have a direct property named by `property`\n   * with a value equal to the provided `value`. Uses a deep equality check.\n   * Inherited properties aren't checked.\n   *\n   *     assert.notDeepOwnPropertyVal({ tea: { green: 'matcha' } }, 'tea', { black: 'matcha' });\n   *     assert.notDeepOwnPropertyVal({ tea: { green: 'matcha' } }, 'tea', { green: 'oolong' });\n   *     assert.notDeepOwnPropertyVal({ tea: { green: 'matcha' } }, 'coffee', { green: 'matcha' });\n   *     assert.notDeepOwnPropertyVal({}, 'toString', Object.prototype.toString);\n   *\n   * @name notDeepOwnPropertyVal\n   * @param {Object} object\n   * @param {String} property\n   * @param {Mixed} value\n   * @param {String} message\n   * @api public\n   */\n\n  assert.notDeepOwnPropertyVal = function (obj, prop, value, msg) {\n    new Assertion(obj, msg, assert.notDeepOwnPropertyVal, true)\n      .to.not.have.deep.own.property(prop, value);\n  };\n\n  /**\n   * ### .nestedProperty(object, property, [message])\n   *\n   * Asserts that `object` has a direct or inherited property named by\n   * `property`, which can be a string using dot- and bracket-notation for\n   * nested reference.\n   *\n   *     assert.nestedProperty({ tea: { green: 'matcha' }}, 'tea.green');\n   *\n   * @name nestedProperty\n   * @param {Object} object\n   * @param {String} property\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.nestedProperty = function (obj, prop, msg) {\n    new Assertion(obj, msg, assert.nestedProperty, true)\n      .to.have.nested.property(prop);\n  };\n\n  /**\n   * ### .notNestedProperty(object, property, [message])\n   *\n   * Asserts that `object` does _not_ have a property named by `property`, which\n   * can be a string using dot- and bracket-notation for nested reference. The\n   * property cannot exist on the object nor anywhere in its prototype chain.\n   *\n   *     assert.notNestedProperty({ tea: { green: 'matcha' }}, 'tea.oolong');\n   *\n   * @name notNestedProperty\n   * @param {Object} object\n   * @param {String} property\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.notNestedProperty = function (obj, prop, msg) {\n    new Assertion(obj, msg, assert.notNestedProperty, true)\n      .to.not.have.nested.property(prop);\n  };\n\n  /**\n   * ### .nestedPropertyVal(object, property, value, [message])\n   *\n   * Asserts that `object` has a property named by `property` with value given\n   * by `value`. `property` can use dot- and bracket-notation for nested\n   * reference. Uses a strict equality check (===).\n   *\n   *     assert.nestedPropertyVal({ tea: { green: 'matcha' }}, 'tea.green', 'matcha');\n   *\n   * @name nestedPropertyVal\n   * @param {Object} object\n   * @param {String} property\n   * @param {Mixed} value\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.nestedPropertyVal = function (obj, prop, val, msg) {\n    new Assertion(obj, msg, assert.nestedPropertyVal, true)\n      .to.have.nested.property(prop, val);\n  };\n\n  /**\n   * ### .notNestedPropertyVal(object, property, value, [message])\n   *\n   * Asserts that `object` does _not_ have a property named by `property` with\n   * value given by `value`. `property` can use dot- and bracket-notation for\n   * nested reference. Uses a strict equality check (===).\n   *\n   *     assert.notNestedPropertyVal({ tea: { green: 'matcha' }}, 'tea.green', 'konacha');\n   *     assert.notNestedPropertyVal({ tea: { green: 'matcha' }}, 'coffee.green', 'matcha');\n   *\n   * @name notNestedPropertyVal\n   * @param {Object} object\n   * @param {String} property\n   * @param {Mixed} value\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.notNestedPropertyVal = function (obj, prop, val, msg) {\n    new Assertion(obj, msg, assert.notNestedPropertyVal, true)\n      .to.not.have.nested.property(prop, val);\n  };\n\n  /**\n   * ### .deepNestedPropertyVal(object, property, value, [message])\n   *\n   * Asserts that `object` has a property named by `property` with a value given\n   * by `value`. `property` can use dot- and bracket-notation for nested\n   * reference. Uses a deep equality check.\n   *\n   *     assert.deepNestedPropertyVal({ tea: { green: { matcha: 'yum' } } }, 'tea.green', { matcha: 'yum' });\n   *\n   * @name deepNestedPropertyVal\n   * @param {Object} object\n   * @param {String} property\n   * @param {Mixed} value\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.deepNestedPropertyVal = function (obj, prop, val, msg) {\n    new Assertion(obj, msg, assert.deepNestedPropertyVal, true)\n      .to.have.deep.nested.property(prop, val);\n  };\n\n  /**\n   * ### .notDeepNestedPropertyVal(object, property, value, [message])\n   *\n   * Asserts that `object` does _not_ have a property named by `property` with\n   * value given by `value`. `property` can use dot- and bracket-notation for\n   * nested reference. Uses a deep equality check.\n   *\n   *     assert.notDeepNestedPropertyVal({ tea: { green: { matcha: 'yum' } } }, 'tea.green', { oolong: 'yum' });\n   *     assert.notDeepNestedPropertyVal({ tea: { green: { matcha: 'yum' } } }, 'tea.green', { matcha: 'yuck' });\n   *     assert.notDeepNestedPropertyVal({ tea: { green: { matcha: 'yum' } } }, 'tea.black', { matcha: 'yum' });\n   *\n   * @name notDeepNestedPropertyVal\n   * @param {Object} object\n   * @param {String} property\n   * @param {Mixed} value\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.notDeepNestedPropertyVal = function (obj, prop, val, msg) {\n    new Assertion(obj, msg, assert.notDeepNestedPropertyVal, true)\n      .to.not.have.deep.nested.property(prop, val);\n  }\n\n  /**\n   * ### .lengthOf(object, length, [message])\n   *\n   * Asserts that `object` has a `length` or `size` with the expected value.\n   *\n   *     assert.lengthOf([1,2,3], 3, 'array has length of 3');\n   *     assert.lengthOf('foobar', 6, 'string has length of 6');\n   *     assert.lengthOf(new Set([1,2,3]), 3, 'set has size of 3');\n   *     assert.lengthOf(new Map([['a',1],['b',2],['c',3]]), 3, 'map has size of 3');\n   *\n   * @name lengthOf\n   * @param {Mixed} object\n   * @param {Number} length\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.lengthOf = function (exp, len, msg) {\n    new Assertion(exp, msg, assert.lengthOf, true).to.have.lengthOf(len);\n  };\n\n  /**\n   * ### .hasAnyKeys(object, [keys], [message])\n   *\n   * Asserts that `object` has at least one of the `keys` provided.\n   * You can also provide a single object instead of a `keys` array and its keys\n   * will be used as the expected set of keys.\n   *\n   *     assert.hasAnyKeys({foo: 1, bar: 2, baz: 3}, ['foo', 'iDontExist', 'baz']);\n   *     assert.hasAnyKeys({foo: 1, bar: 2, baz: 3}, {foo: 30, iDontExist: 99, baz: 1337});\n   *     assert.hasAnyKeys(new Map([[{foo: 1}, 'bar'], ['key', 'value']]), [{foo: 1}, 'key']);\n   *     assert.hasAnyKeys(new Set([{foo: 'bar'}, 'anotherKey']), [{foo: 'bar'}, 'anotherKey']);\n   *\n   * @name hasAnyKeys\n   * @param {Mixed} object\n   * @param {Array|Object} keys\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.hasAnyKeys = function (obj, keys, msg) {\n    new Assertion(obj, msg, assert.hasAnyKeys, true).to.have.any.keys(keys);\n  }\n\n  /**\n   * ### .hasAllKeys(object, [keys], [message])\n   *\n   * Asserts that `object` has all and only all of the `keys` provided.\n   * You can also provide a single object instead of a `keys` array and its keys\n   * will be used as the expected set of keys.\n   *\n   *     assert.hasAllKeys({foo: 1, bar: 2, baz: 3}, ['foo', 'bar', 'baz']);\n   *     assert.hasAllKeys({foo: 1, bar: 2, baz: 3}, {foo: 30, bar: 99, baz: 1337]);\n   *     assert.hasAllKeys(new Map([[{foo: 1}, 'bar'], ['key', 'value']]), [{foo: 1}, 'key']);\n   *     assert.hasAllKeys(new Set([{foo: 'bar'}, 'anotherKey'], [{foo: 'bar'}, 'anotherKey']);\n   *\n   * @name hasAllKeys\n   * @param {Mixed} object\n   * @param {String[]} keys\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.hasAllKeys = function (obj, keys, msg) {\n    new Assertion(obj, msg, assert.hasAllKeys, true).to.have.all.keys(keys);\n  }\n\n  /**\n   * ### .containsAllKeys(object, [keys], [message])\n   *\n   * Asserts that `object` has all of the `keys` provided but may have more keys not listed.\n   * You can also provide a single object instead of a `keys` array and its keys\n   * will be used as the expected set of keys.\n   *\n   *     assert.containsAllKeys({foo: 1, bar: 2, baz: 3}, ['foo', 'baz']);\n   *     assert.containsAllKeys({foo: 1, bar: 2, baz: 3}, ['foo', 'bar', 'baz']);\n   *     assert.containsAllKeys({foo: 1, bar: 2, baz: 3}, {foo: 30, baz: 1337});\n   *     assert.containsAllKeys({foo: 1, bar: 2, baz: 3}, {foo: 30, bar: 99, baz: 1337});\n   *     assert.containsAllKeys(new Map([[{foo: 1}, 'bar'], ['key', 'value']]), [{foo: 1}]);\n   *     assert.containsAllKeys(new Map([[{foo: 1}, 'bar'], ['key', 'value']]), [{foo: 1}, 'key']);\n   *     assert.containsAllKeys(new Set([{foo: 'bar'}, 'anotherKey'], [{foo: 'bar'}]);\n   *     assert.containsAllKeys(new Set([{foo: 'bar'}, 'anotherKey'], [{foo: 'bar'}, 'anotherKey']);\n   *\n   * @name containsAllKeys\n   * @param {Mixed} object\n   * @param {String[]} keys\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.containsAllKeys = function (obj, keys, msg) {\n    new Assertion(obj, msg, assert.containsAllKeys, true)\n      .to.contain.all.keys(keys);\n  }\n\n  /**\n   * ### .doesNotHaveAnyKeys(object, [keys], [message])\n   *\n   * Asserts that `object` has none of the `keys` provided.\n   * You can also provide a single object instead of a `keys` array and its keys\n   * will be used as the expected set of keys.\n   *\n   *     assert.doesNotHaveAnyKeys({foo: 1, bar: 2, baz: 3}, ['one', 'two', 'example']);\n   *     assert.doesNotHaveAnyKeys({foo: 1, bar: 2, baz: 3}, {one: 1, two: 2, example: 'foo'});\n   *     assert.doesNotHaveAnyKeys(new Map([[{foo: 1}, 'bar'], ['key', 'value']]), [{one: 'two'}, 'example']);\n   *     assert.doesNotHaveAnyKeys(new Set([{foo: 'bar'}, 'anotherKey'], [{one: 'two'}, 'example']);\n   *\n   * @name doesNotHaveAnyKeys\n   * @param {Mixed} object\n   * @param {String[]} keys\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.doesNotHaveAnyKeys = function (obj, keys, msg) {\n    new Assertion(obj, msg, assert.doesNotHaveAnyKeys, true)\n      .to.not.have.any.keys(keys);\n  }\n\n  /**\n   * ### .doesNotHaveAllKeys(object, [keys], [message])\n   *\n   * Asserts that `object` does not have at least one of the `keys` provided.\n   * You can also provide a single object instead of a `keys` array and its keys\n   * will be used as the expected set of keys.\n   *\n   *     assert.doesNotHaveAllKeys({foo: 1, bar: 2, baz: 3}, ['one', 'two', 'example']);\n   *     assert.doesNotHaveAllKeys({foo: 1, bar: 2, baz: 3}, {one: 1, two: 2, example: 'foo'});\n   *     assert.doesNotHaveAllKeys(new Map([[{foo: 1}, 'bar'], ['key', 'value']]), [{one: 'two'}, 'example']);\n   *     assert.doesNotHaveAllKeys(new Set([{foo: 'bar'}, 'anotherKey'], [{one: 'two'}, 'example']);\n   *\n   * @name doesNotHaveAllKeys\n   * @param {Mixed} object\n   * @param {String[]} keys\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.doesNotHaveAllKeys = function (obj, keys, msg) {\n    new Assertion(obj, msg, assert.doesNotHaveAllKeys, true)\n      .to.not.have.all.keys(keys);\n  }\n\n  /**\n   * ### .hasAnyDeepKeys(object, [keys], [message])\n   *\n   * Asserts that `object` has at least one of the `keys` provided.\n   * Since Sets and Maps can have objects as keys you can use this assertion to perform\n   * a deep comparison.\n   * You can also provide a single object instead of a `keys` array and its keys\n   * will be used as the expected set of keys.\n   *\n   *     assert.hasAnyDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [1, 2]]), {one: 'one'});\n   *     assert.hasAnyDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [1, 2]]), [{one: 'one'}, {two: 'two'}]);\n   *     assert.hasAnyDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [{two: 'two'}, 'valueTwo']]), [{one: 'one'}, {two: 'two'}]);\n   *     assert.hasAnyDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), {one: 'one'});\n   *     assert.hasAnyDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), [{one: 'one'}, {three: 'three'}]);\n   *     assert.hasAnyDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), [{one: 'one'}, {two: 'two'}]);\n   *\n   * @name doesNotHaveAllKeys\n   * @param {Mixed} object\n   * @param {Array|Object} keys\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.hasAnyDeepKeys = function (obj, keys, msg) {\n    new Assertion(obj, msg, assert.hasAnyDeepKeys, true)\n      .to.have.any.deep.keys(keys);\n  }\n\n /**\n   * ### .hasAllDeepKeys(object, [keys], [message])\n   *\n   * Asserts that `object` has all and only all of the `keys` provided.\n   * Since Sets and Maps can have objects as keys you can use this assertion to perform\n   * a deep comparison.\n   * You can also provide a single object instead of a `keys` array and its keys\n   * will be used as the expected set of keys.\n   *\n   *     assert.hasAllDeepKeys(new Map([[{one: 'one'}, 'valueOne']]), {one: 'one'});\n   *     assert.hasAllDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [{two: 'two'}, 'valueTwo']]), [{one: 'one'}, {two: 'two'}]);\n   *     assert.hasAllDeepKeys(new Set([{one: 'one'}]), {one: 'one'});\n   *     assert.hasAllDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), [{one: 'one'}, {two: 'two'}]);\n   *\n   * @name hasAllDeepKeys\n   * @param {Mixed} object\n   * @param {Array|Object} keys\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.hasAllDeepKeys = function (obj, keys, msg) {\n    new Assertion(obj, msg, assert.hasAllDeepKeys, true)\n      .to.have.all.deep.keys(keys);\n  }\n\n /**\n   * ### .containsAllDeepKeys(object, [keys], [message])\n   *\n   * Asserts that `object` contains all of the `keys` provided.\n   * Since Sets and Maps can have objects as keys you can use this assertion to perform\n   * a deep comparison.\n   * You can also provide a single object instead of a `keys` array and its keys\n   * will be used as the expected set of keys.\n   *\n   *     assert.containsAllDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [1, 2]]), {one: 'one'});\n   *     assert.containsAllDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [{two: 'two'}, 'valueTwo']]), [{one: 'one'}, {two: 'two'}]);\n   *     assert.containsAllDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), {one: 'one'});\n   *     assert.containsAllDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), [{one: 'one'}, {two: 'two'}]);\n   *\n   * @name containsAllDeepKeys\n   * @param {Mixed} object\n   * @param {Array|Object} keys\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.containsAllDeepKeys = function (obj, keys, msg) {\n    new Assertion(obj, msg, assert.containsAllDeepKeys, true)\n      .to.contain.all.deep.keys(keys);\n  }\n\n /**\n   * ### .doesNotHaveAnyDeepKeys(object, [keys], [message])\n   *\n   * Asserts that `object` has none of the `keys` provided.\n   * Since Sets and Maps can have objects as keys you can use this assertion to perform\n   * a deep comparison.\n   * You can also provide a single object instead of a `keys` array and its keys\n   * will be used as the expected set of keys.\n   *\n   *     assert.doesNotHaveAnyDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [1, 2]]), {thisDoesNot: 'exist'});\n   *     assert.doesNotHaveAnyDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [{two: 'two'}, 'valueTwo']]), [{twenty: 'twenty'}, {fifty: 'fifty'}]);\n   *     assert.doesNotHaveAnyDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), {twenty: 'twenty'});\n   *     assert.doesNotHaveAnyDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), [{twenty: 'twenty'}, {fifty: 'fifty'}]);\n   *\n   * @name doesNotHaveAnyDeepKeys\n   * @param {Mixed} object\n   * @param {Array|Object} keys\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.doesNotHaveAnyDeepKeys = function (obj, keys, msg) {\n    new Assertion(obj, msg, assert.doesNotHaveAnyDeepKeys, true)\n      .to.not.have.any.deep.keys(keys);\n  }\n\n /**\n   * ### .doesNotHaveAllDeepKeys(object, [keys], [message])\n   *\n   * Asserts that `object` does not have at least one of the `keys` provided.\n   * Since Sets and Maps can have objects as keys you can use this assertion to perform\n   * a deep comparison.\n   * You can also provide a single object instead of a `keys` array and its keys\n   * will be used as the expected set of keys.\n   *\n   *     assert.doesNotHaveAllDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [1, 2]]), {thisDoesNot: 'exist'});\n   *     assert.doesNotHaveAllDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [{two: 'two'}, 'valueTwo']]), [{twenty: 'twenty'}, {one: 'one'}]);\n   *     assert.doesNotHaveAllDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), {twenty: 'twenty'});\n   *     assert.doesNotHaveAllDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), [{one: 'one'}, {fifty: 'fifty'}]);\n   *\n   * @name doesNotHaveAllDeepKeys\n   * @param {Mixed} object\n   * @param {Array|Object} keys\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.doesNotHaveAllDeepKeys = function (obj, keys, msg) {\n    new Assertion(obj, msg, assert.doesNotHaveAllDeepKeys, true)\n      .to.not.have.all.deep.keys(keys);\n  }\n\n /**\n   * ### .throws(fn, [errorLike/string/regexp], [string/regexp], [message])\n   *\n   * If `errorLike` is an `Error` constructor, asserts that `fn` will throw an error that is an\n   * instance of `errorLike`.\n   * If `errorLike` is an `Error` instance, asserts that the error thrown is the same\n   * instance as `errorLike`.\n   * If `errMsgMatcher` is provided, it also asserts that the error thrown will have a\n   * message matching `errMsgMatcher`.\n   *\n   *     assert.throws(fn, 'Error thrown must have this msg');\n   *     assert.throws(fn, /Error thrown must have a msg that matches this/);\n   *     assert.throws(fn, ReferenceError);\n   *     assert.throws(fn, errorInstance);\n   *     assert.throws(fn, ReferenceError, 'Error thrown must be a ReferenceError and have this msg');\n   *     assert.throws(fn, errorInstance, 'Error thrown must be the same errorInstance and have this msg');\n   *     assert.throws(fn, ReferenceError, /Error thrown must be a ReferenceError and match this/);\n   *     assert.throws(fn, errorInstance, /Error thrown must be the same errorInstance and match this/);\n   *\n   * @name throws\n   * @alias throw\n   * @alias Throw\n   * @param {Function} fn\n   * @param {ErrorConstructor|Error} errorLike\n   * @param {RegExp|String} errMsgMatcher\n   * @param {String} message\n   * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.throws = function (fn, errorLike, errMsgMatcher, msg) {\n    if ('string' === typeof errorLike || errorLike instanceof RegExp) {\n      errMsgMatcher = errorLike;\n      errorLike = null;\n    }\n\n    var assertErr = new Assertion(fn, msg, assert.throws, true)\n      .to.throw(errorLike, errMsgMatcher);\n    return flag(assertErr, 'object');\n  };\n\n  /**\n   * ### .doesNotThrow(fn, [errorLike/string/regexp], [string/regexp], [message])\n   *\n   * If `errorLike` is an `Error` constructor, asserts that `fn` will _not_ throw an error that is an\n   * instance of `errorLike`.\n   * If `errorLike` is an `Error` instance, asserts that the error thrown is _not_ the same\n   * instance as `errorLike`.\n   * If `errMsgMatcher` is provided, it also asserts that the error thrown will _not_ have a\n   * message matching `errMsgMatcher`.\n   *\n   *     assert.doesNotThrow(fn, 'Any Error thrown must not have this message');\n   *     assert.doesNotThrow(fn, /Any Error thrown must not match this/);\n   *     assert.doesNotThrow(fn, Error);\n   *     assert.doesNotThrow(fn, errorInstance);\n   *     assert.doesNotThrow(fn, Error, 'Error must not have this message');\n   *     assert.doesNotThrow(fn, errorInstance, 'Error must not have this message');\n   *     assert.doesNotThrow(fn, Error, /Error must not match this/);\n   *     assert.doesNotThrow(fn, errorInstance, /Error must not match this/);\n   *\n   * @name doesNotThrow\n   * @param {Function} fn\n   * @param {ErrorConstructor} errorLike\n   * @param {RegExp|String} errMsgMatcher\n   * @param {String} message\n   * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.doesNotThrow = function (fn, errorLike, errMsgMatcher, msg) {\n    if ('string' === typeof errorLike || errorLike instanceof RegExp) {\n      errMsgMatcher = errorLike;\n      errorLike = null;\n    }\n\n    new Assertion(fn, msg, assert.doesNotThrow, true)\n      .to.not.throw(errorLike, errMsgMatcher);\n  };\n\n  /**\n   * ### .operator(val1, operator, val2, [message])\n   *\n   * Compares two values using `operator`.\n   *\n   *     assert.operator(1, '<', 2, 'everything is ok');\n   *     assert.operator(1, '>', 2, 'this will fail');\n   *\n   * @name operator\n   * @param {Mixed} val1\n   * @param {String} operator\n   * @param {Mixed} val2\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.operator = function (val, operator, val2, msg) {\n    var ok;\n    switch(operator) {\n      case '==':\n        ok = val == val2;\n        break;\n      case '===':\n        ok = val === val2;\n        break;\n      case '>':\n        ok = val > val2;\n        break;\n      case '>=':\n        ok = val >= val2;\n        break;\n      case '<':\n        ok = val < val2;\n        break;\n      case '<=':\n        ok = val <= val2;\n        break;\n      case '!=':\n        ok = val != val2;\n        break;\n      case '!==':\n        ok = val !== val2;\n        break;\n      default:\n        msg = msg ? msg + ': ' : msg;\n        throw new chai.AssertionError(\n          msg + 'Invalid operator \"' + operator + '\"',\n          undefined,\n          assert.operator\n        );\n    }\n    var test = new Assertion(ok, msg, assert.operator, true);\n    test.assert(\n        true === flag(test, 'object')\n      , 'expected ' + util.inspect(val) + ' to be ' + operator + ' ' + util.inspect(val2)\n      , 'expected ' + util.inspect(val) + ' to not be ' + operator + ' ' + util.inspect(val2) );\n  };\n\n  /**\n   * ### .closeTo(actual, expected, delta, [message])\n   *\n   * Asserts that the target is equal `expected`, to within a +/- `delta` range.\n   *\n   *     assert.closeTo(1.5, 1, 0.5, 'numbers are close');\n   *\n   * @name closeTo\n   * @param {Number} actual\n   * @param {Number} expected\n   * @param {Number} delta\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.closeTo = function (act, exp, delta, msg) {\n    new Assertion(act, msg, assert.closeTo, true).to.be.closeTo(exp, delta);\n  };\n\n  /**\n   * ### .approximately(actual, expected, delta, [message])\n   *\n   * Asserts that the target is equal `expected`, to within a +/- `delta` range.\n   *\n   *     assert.approximately(1.5, 1, 0.5, 'numbers are close');\n   *\n   * @name approximately\n   * @param {Number} actual\n   * @param {Number} expected\n   * @param {Number} delta\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.approximately = function (act, exp, delta, msg) {\n    new Assertion(act, msg, assert.approximately, true)\n      .to.be.approximately(exp, delta);\n  };\n\n  /**\n   * ### .sameMembers(set1, set2, [message])\n   *\n   * Asserts that `set1` and `set2` have the same members in any order. Uses a\n   * strict equality check (===).\n   *\n   *     assert.sameMembers([ 1, 2, 3 ], [ 2, 1, 3 ], 'same members');\n   *\n   * @name sameMembers\n   * @param {Array} set1\n   * @param {Array} set2\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.sameMembers = function (set1, set2, msg) {\n    new Assertion(set1, msg, assert.sameMembers, true)\n      .to.have.same.members(set2);\n  }\n\n  /**\n   * ### .notSameMembers(set1, set2, [message])\n   *\n   * Asserts that `set1` and `set2` don't have the same members in any order.\n   * Uses a strict equality check (===).\n   *\n   *     assert.notSameMembers([ 1, 2, 3 ], [ 5, 1, 3 ], 'not same members');\n   *\n   * @name notSameMembers\n   * @param {Array} set1\n   * @param {Array} set2\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.notSameMembers = function (set1, set2, msg) {\n    new Assertion(set1, msg, assert.notSameMembers, true)\n      .to.not.have.same.members(set2);\n  }\n\n  /**\n   * ### .sameDeepMembers(set1, set2, [message])\n   *\n   * Asserts that `set1` and `set2` have the same members in any order. Uses a\n   * deep equality check.\n   *\n   *     assert.sameDeepMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [{ b: 2 }, { a: 1 }, { c: 3 }], 'same deep members');\n   *\n   * @name sameDeepMembers\n   * @param {Array} set1\n   * @param {Array} set2\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.sameDeepMembers = function (set1, set2, msg) {\n    new Assertion(set1, msg, assert.sameDeepMembers, true)\n      .to.have.same.deep.members(set2);\n  }\n\n  /**\n   * ### .notSameDeepMembers(set1, set2, [message])\n   *\n   * Asserts that `set1` and `set2` don't have the same members in any order.\n   * Uses a deep equality check.\n   *\n   *     assert.notSameDeepMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [{ b: 2 }, { a: 1 }, { f: 5 }], 'not same deep members');\n   *\n   * @name notSameDeepMembers\n   * @param {Array} set1\n   * @param {Array} set2\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.notSameDeepMembers = function (set1, set2, msg) {\n    new Assertion(set1, msg, assert.notSameDeepMembers, true)\n      .to.not.have.same.deep.members(set2);\n  }\n\n  /**\n   * ### .sameOrderedMembers(set1, set2, [message])\n   *\n   * Asserts that `set1` and `set2` have the same members in the same order.\n   * Uses a strict equality check (===).\n   *\n   *     assert.sameOrderedMembers([ 1, 2, 3 ], [ 1, 2, 3 ], 'same ordered members');\n   *\n   * @name sameOrderedMembers\n   * @param {Array} set1\n   * @param {Array} set2\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.sameOrderedMembers = function (set1, set2, msg) {\n    new Assertion(set1, msg, assert.sameOrderedMembers, true)\n      .to.have.same.ordered.members(set2);\n  }\n\n  /**\n   * ### .notSameOrderedMembers(set1, set2, [message])\n   *\n   * Asserts that `set1` and `set2` don't have the same members in the same\n   * order. Uses a strict equality check (===).\n   *\n   *     assert.notSameOrderedMembers([ 1, 2, 3 ], [ 2, 1, 3 ], 'not same ordered members');\n   *\n   * @name notSameOrderedMembers\n   * @param {Array} set1\n   * @param {Array} set2\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.notSameOrderedMembers = function (set1, set2, msg) {\n    new Assertion(set1, msg, assert.notSameOrderedMembers, true)\n      .to.not.have.same.ordered.members(set2);\n  }\n\n  /**\n   * ### .sameDeepOrderedMembers(set1, set2, [message])\n   *\n   * Asserts that `set1` and `set2` have the same members in the same order.\n   * Uses a deep equality check.\n   *\n   * assert.sameDeepOrderedMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { a: 1 }, { b: 2 }, { c: 3 } ], 'same deep ordered members');\n   *\n   * @name sameDeepOrderedMembers\n   * @param {Array} set1\n   * @param {Array} set2\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.sameDeepOrderedMembers = function (set1, set2, msg) {\n    new Assertion(set1, msg, assert.sameDeepOrderedMembers, true)\n      .to.have.same.deep.ordered.members(set2);\n  }\n\n  /**\n   * ### .notSameDeepOrderedMembers(set1, set2, [message])\n   *\n   * Asserts that `set1` and `set2` don't have the same members in the same\n   * order. Uses a deep equality check.\n   *\n   * assert.notSameDeepOrderedMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { a: 1 }, { b: 2 }, { z: 5 } ], 'not same deep ordered members');\n   * assert.notSameDeepOrderedMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { b: 2 }, { a: 1 }, { c: 3 } ], 'not same deep ordered members');\n   *\n   * @name notSameDeepOrderedMembers\n   * @param {Array} set1\n   * @param {Array} set2\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.notSameDeepOrderedMembers = function (set1, set2, msg) {\n    new Assertion(set1, msg, assert.notSameDeepOrderedMembers, true)\n      .to.not.have.same.deep.ordered.members(set2);\n  }\n\n  /**\n   * ### .includeMembers(superset, subset, [message])\n   *\n   * Asserts that `subset` is included in `superset` in any order. Uses a\n   * strict equality check (===). Duplicates are ignored.\n   *\n   *     assert.includeMembers([ 1, 2, 3 ], [ 2, 1, 2 ], 'include members');\n   *\n   * @name includeMembers\n   * @param {Array} superset\n   * @param {Array} subset\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.includeMembers = function (superset, subset, msg) {\n    new Assertion(superset, msg, assert.includeMembers, true)\n      .to.include.members(subset);\n  }\n\n  /**\n   * ### .notIncludeMembers(superset, subset, [message])\n   *\n   * Asserts that `subset` isn't included in `superset` in any order. Uses a\n   * strict equality check (===). Duplicates are ignored.\n   *\n   *     assert.notIncludeMembers([ 1, 2, 3 ], [ 5, 1 ], 'not include members');\n   *\n   * @name notIncludeMembers\n   * @param {Array} superset\n   * @param {Array} subset\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.notIncludeMembers = function (superset, subset, msg) {\n    new Assertion(superset, msg, assert.notIncludeMembers, true)\n      .to.not.include.members(subset);\n  }\n\n  /**\n   * ### .includeDeepMembers(superset, subset, [message])\n   *\n   * Asserts that `subset` is included in `superset` in any order. Uses a deep\n   * equality check. Duplicates are ignored.\n   *\n   *     assert.includeDeepMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { b: 2 }, { a: 1 }, { b: 2 } ], 'include deep members');\n   *\n   * @name includeDeepMembers\n   * @param {Array} superset\n   * @param {Array} subset\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.includeDeepMembers = function (superset, subset, msg) {\n    new Assertion(superset, msg, assert.includeDeepMembers, true)\n      .to.include.deep.members(subset);\n  }\n\n  /**\n   * ### .notIncludeDeepMembers(superset, subset, [message])\n   *\n   * Asserts that `subset` isn't included in `superset` in any order. Uses a\n   * deep equality check. Duplicates are ignored.\n   *\n   *     assert.notIncludeDeepMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { b: 2 }, { f: 5 } ], 'not include deep members');\n   *\n   * @name notIncludeDeepMembers\n   * @param {Array} superset\n   * @param {Array} subset\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.notIncludeDeepMembers = function (superset, subset, msg) {\n    new Assertion(superset, msg, assert.notIncludeDeepMembers, true)\n      .to.not.include.deep.members(subset);\n  }\n\n  /**\n   * ### .includeOrderedMembers(superset, subset, [message])\n   *\n   * Asserts that `subset` is included in `superset` in the same order\n   * beginning with the first element in `superset`. Uses a strict equality\n   * check (===).\n   *\n   *     assert.includeOrderedMembers([ 1, 2, 3 ], [ 1, 2 ], 'include ordered members');\n   *\n   * @name includeOrderedMembers\n   * @param {Array} superset\n   * @param {Array} subset\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.includeOrderedMembers = function (superset, subset, msg) {\n    new Assertion(superset, msg, assert.includeOrderedMembers, true)\n      .to.include.ordered.members(subset);\n  }\n\n  /**\n   * ### .notIncludeOrderedMembers(superset, subset, [message])\n   *\n   * Asserts that `subset` isn't included in `superset` in the same order\n   * beginning with the first element in `superset`. Uses a strict equality\n   * check (===).\n   *\n   *     assert.notIncludeOrderedMembers([ 1, 2, 3 ], [ 2, 1 ], 'not include ordered members');\n   *     assert.notIncludeOrderedMembers([ 1, 2, 3 ], [ 2, 3 ], 'not include ordered members');\n   *\n   * @name notIncludeOrderedMembers\n   * @param {Array} superset\n   * @param {Array} subset\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.notIncludeOrderedMembers = function (superset, subset, msg) {\n    new Assertion(superset, msg, assert.notIncludeOrderedMembers, true)\n      .to.not.include.ordered.members(subset);\n  }\n\n  /**\n   * ### .includeDeepOrderedMembers(superset, subset, [message])\n   *\n   * Asserts that `subset` is included in `superset` in the same order\n   * beginning with the first element in `superset`. Uses a deep equality\n   * check.\n   *\n   *     assert.includeDeepOrderedMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { a: 1 }, { b: 2 } ], 'include deep ordered members');\n   *\n   * @name includeDeepOrderedMembers\n   * @param {Array} superset\n   * @param {Array} subset\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.includeDeepOrderedMembers = function (superset, subset, msg) {\n    new Assertion(superset, msg, assert.includeDeepOrderedMembers, true)\n      .to.include.deep.ordered.members(subset);\n  }\n\n  /**\n   * ### .notIncludeDeepOrderedMembers(superset, subset, [message])\n   *\n   * Asserts that `subset` isn't included in `superset` in the same order\n   * beginning with the first element in `superset`. Uses a deep equality\n   * check.\n   *\n   *     assert.notIncludeDeepOrderedMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { a: 1 }, { f: 5 } ], 'not include deep ordered members');\n   *     assert.notIncludeDeepOrderedMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { b: 2 }, { a: 1 } ], 'not include deep ordered members');\n   *     assert.notIncludeDeepOrderedMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { b: 2 }, { c: 3 } ], 'not include deep ordered members');\n   *\n   * @name notIncludeDeepOrderedMembers\n   * @param {Array} superset\n   * @param {Array} subset\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.notIncludeDeepOrderedMembers = function (superset, subset, msg) {\n    new Assertion(superset, msg, assert.notIncludeDeepOrderedMembers, true)\n      .to.not.include.deep.ordered.members(subset);\n  }\n\n  /**\n   * ### .oneOf(inList, list, [message])\n   *\n   * Asserts that non-object, non-array value `inList` appears in the flat array `list`.\n   *\n   *     assert.oneOf(1, [ 2, 1 ], 'Not found in list');\n   *\n   * @name oneOf\n   * @param {*} inList\n   * @param {Array<*>} list\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.oneOf = function (inList, list, msg) {\n    new Assertion(inList, msg, assert.oneOf, true).to.be.oneOf(list);\n  }\n\n  /**\n   * ### .changes(function, object, property, [message])\n   *\n   * Asserts that a function changes the value of a property.\n   *\n   *     var obj = { val: 10 };\n   *     var fn = function() { obj.val = 22 };\n   *     assert.changes(fn, obj, 'val');\n   *\n   * @name changes\n   * @param {Function} modifier function\n   * @param {Object} object or getter function\n   * @param {String} property name _optional_\n   * @param {String} message _optional_\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.changes = function (fn, obj, prop, msg) {\n    if (arguments.length === 3 && typeof obj === 'function') {\n      msg = prop;\n      prop = null;\n    }\n\n    new Assertion(fn, msg, assert.changes, true).to.change(obj, prop);\n  }\n\n   /**\n   * ### .changesBy(function, object, property, delta, [message])\n   *\n   * Asserts that a function changes the value of a property by an amount (delta).\n   *\n   *     var obj = { val: 10 };\n   *     var fn = function() { obj.val += 2 };\n   *     assert.changesBy(fn, obj, 'val', 2);\n   *\n   * @name changesBy\n   * @param {Function} modifier function\n   * @param {Object} object or getter function\n   * @param {String} property name _optional_\n   * @param {Number} change amount (delta)\n   * @param {String} message _optional_\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.changesBy = function (fn, obj, prop, delta, msg) {\n    if (arguments.length === 4 && typeof obj === 'function') {\n      var tmpMsg = delta;\n      delta = prop;\n      msg = tmpMsg;\n    } else if (arguments.length === 3) {\n      delta = prop;\n      prop = null;\n    }\n\n    new Assertion(fn, msg, assert.changesBy, true)\n      .to.change(obj, prop).by(delta);\n  }\n\n   /**\n   * ### .doesNotChange(function, object, property, [message])\n   *\n   * Asserts that a function does not change the value of a property.\n   *\n   *     var obj = { val: 10 };\n   *     var fn = function() { console.log('foo'); };\n   *     assert.doesNotChange(fn, obj, 'val');\n   *\n   * @name doesNotChange\n   * @param {Function} modifier function\n   * @param {Object} object or getter function\n   * @param {String} property name _optional_\n   * @param {String} message _optional_\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.doesNotChange = function (fn, obj, prop, msg) {\n    if (arguments.length === 3 && typeof obj === 'function') {\n      msg = prop;\n      prop = null;\n    }\n\n    return new Assertion(fn, msg, assert.doesNotChange, true)\n      .to.not.change(obj, prop);\n  }\n\n  /**\n   * ### .changesButNotBy(function, object, property, delta, [message])\n   *\n   * Asserts that a function does not change the value of a property or of a function's return value by an amount (delta)\n   *\n   *     var obj = { val: 10 };\n   *     var fn = function() { obj.val += 10 };\n   *     assert.changesButNotBy(fn, obj, 'val', 5);\n   *\n   * @name changesButNotBy\n   * @param {Function} modifier function\n   * @param {Object} object or getter function\n   * @param {String} property name _optional_\n   * @param {Number} change amount (delta)\n   * @param {String} message _optional_\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.changesButNotBy = function (fn, obj, prop, delta, msg) {\n    if (arguments.length === 4 && typeof obj === 'function') {\n      var tmpMsg = delta;\n      delta = prop;\n      msg = tmpMsg;\n    } else if (arguments.length === 3) {\n      delta = prop;\n      prop = null;\n    }\n\n    new Assertion(fn, msg, assert.changesButNotBy, true)\n      .to.change(obj, prop).but.not.by(delta);\n  }\n\n  /**\n   * ### .increases(function, object, property, [message])\n   *\n   * Asserts that a function increases a numeric object property.\n   *\n   *     var obj = { val: 10 };\n   *     var fn = function() { obj.val = 13 };\n   *     assert.increases(fn, obj, 'val');\n   *\n   * @name increases\n   * @param {Function} modifier function\n   * @param {Object} object or getter function\n   * @param {String} property name _optional_\n   * @param {String} message _optional_\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.increases = function (fn, obj, prop, msg) {\n    if (arguments.length === 3 && typeof obj === 'function') {\n      msg = prop;\n      prop = null;\n    }\n\n    return new Assertion(fn, msg, assert.increases, true)\n      .to.increase(obj, prop);\n  }\n\n  /**\n   * ### .increasesBy(function, object, property, delta, [message])\n   *\n   * Asserts that a function increases a numeric object property or a function's return value by an amount (delta).\n   *\n   *     var obj = { val: 10 };\n   *     var fn = function() { obj.val += 10 };\n   *     assert.increasesBy(fn, obj, 'val', 10);\n   *\n   * @name increasesBy\n   * @param {Function} modifier function\n   * @param {Object} object or getter function\n   * @param {String} property name _optional_\n   * @param {Number} change amount (delta)\n   * @param {String} message _optional_\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.increasesBy = function (fn, obj, prop, delta, msg) {\n    if (arguments.length === 4 && typeof obj === 'function') {\n      var tmpMsg = delta;\n      delta = prop;\n      msg = tmpMsg;\n    } else if (arguments.length === 3) {\n      delta = prop;\n      prop = null;\n    }\n\n    new Assertion(fn, msg, assert.increasesBy, true)\n      .to.increase(obj, prop).by(delta);\n  }\n\n  /**\n   * ### .doesNotIncrease(function, object, property, [message])\n   *\n   * Asserts that a function does not increase a numeric object property.\n   *\n   *     var obj = { val: 10 };\n   *     var fn = function() { obj.val = 8 };\n   *     assert.doesNotIncrease(fn, obj, 'val');\n   *\n   * @name doesNotIncrease\n   * @param {Function} modifier function\n   * @param {Object} object or getter function\n   * @param {String} property name _optional_\n   * @param {String} message _optional_\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.doesNotIncrease = function (fn, obj, prop, msg) {\n    if (arguments.length === 3 && typeof obj === 'function') {\n      msg = prop;\n      prop = null;\n    }\n\n    return new Assertion(fn, msg, assert.doesNotIncrease, true)\n      .to.not.increase(obj, prop);\n  }\n\n  /**\n   * ### .increasesButNotBy(function, object, property, [message])\n   *\n   * Asserts that a function does not increase a numeric object property or function's return value by an amount (delta).\n   *\n   *     var obj = { val: 10 };\n   *     var fn = function() { obj.val = 15 };\n   *     assert.increasesButNotBy(fn, obj, 'val', 10);\n   *\n   * @name increasesButNotBy\n   * @param {Function} modifier function\n   * @param {Object} object or getter function\n   * @param {String} property name _optional_\n   * @param {Number} change amount (delta)\n   * @param {String} message _optional_\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.increasesButNotBy = function (fn, obj, prop, delta, msg) {\n    if (arguments.length === 4 && typeof obj === 'function') {\n      var tmpMsg = delta;\n      delta = prop;\n      msg = tmpMsg;\n    } else if (arguments.length === 3) {\n      delta = prop;\n      prop = null;\n    }\n\n    new Assertion(fn, msg, assert.increasesButNotBy, true)\n      .to.increase(obj, prop).but.not.by(delta);\n  }\n\n  /**\n   * ### .decreases(function, object, property, [message])\n   *\n   * Asserts that a function decreases a numeric object property.\n   *\n   *     var obj = { val: 10 };\n   *     var fn = function() { obj.val = 5 };\n   *     assert.decreases(fn, obj, 'val');\n   *\n   * @name decreases\n   * @param {Function} modifier function\n   * @param {Object} object or getter function\n   * @param {String} property name _optional_\n   * @param {String} message _optional_\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.decreases = function (fn, obj, prop, msg) {\n    if (arguments.length === 3 && typeof obj === 'function') {\n      msg = prop;\n      prop = null;\n    }\n\n    return new Assertion(fn, msg, assert.decreases, true)\n      .to.decrease(obj, prop);\n  }\n\n  /**\n   * ### .decreasesBy(function, object, property, delta, [message])\n   *\n   * Asserts that a function decreases a numeric object property or a function's return value by an amount (delta)\n   *\n   *     var obj = { val: 10 };\n   *     var fn = function() { obj.val -= 5 };\n   *     assert.decreasesBy(fn, obj, 'val', 5);\n   *\n   * @name decreasesBy\n   * @param {Function} modifier function\n   * @param {Object} object or getter function\n   * @param {String} property name _optional_\n   * @param {Number} change amount (delta)\n   * @param {String} message _optional_\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.decreasesBy = function (fn, obj, prop, delta, msg) {\n    if (arguments.length === 4 && typeof obj === 'function') {\n      var tmpMsg = delta;\n      delta = prop;\n      msg = tmpMsg;\n    } else if (arguments.length === 3) {\n      delta = prop;\n      prop = null;\n    }\n\n    new Assertion(fn, msg, assert.decreasesBy, true)\n      .to.decrease(obj, prop).by(delta);\n  }\n\n  /**\n   * ### .doesNotDecrease(function, object, property, [message])\n   *\n   * Asserts that a function does not decreases a numeric object property.\n   *\n   *     var obj = { val: 10 };\n   *     var fn = function() { obj.val = 15 };\n   *     assert.doesNotDecrease(fn, obj, 'val');\n   *\n   * @name doesNotDecrease\n   * @param {Function} modifier function\n   * @param {Object} object or getter function\n   * @param {String} property name _optional_\n   * @param {String} message _optional_\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.doesNotDecrease = function (fn, obj, prop, msg) {\n    if (arguments.length === 3 && typeof obj === 'function') {\n      msg = prop;\n      prop = null;\n    }\n\n    return new Assertion(fn, msg, assert.doesNotDecrease, true)\n      .to.not.decrease(obj, prop);\n  }\n\n  /**\n   * ### .doesNotDecreaseBy(function, object, property, delta, [message])\n   *\n   * Asserts that a function does not decreases a numeric object property or a function's return value by an amount (delta)\n   *\n   *     var obj = { val: 10 };\n   *     var fn = function() { obj.val = 5 };\n   *     assert.doesNotDecreaseBy(fn, obj, 'val', 1);\n   *\n   * @name doesNotDecrease\n   * @param {Function} modifier function\n   * @param {Object} object or getter function\n   * @param {String} property name _optional_\n   * @param {Number} change amount (delta)\n   * @param {String} message _optional_\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.doesNotDecreaseBy = function (fn, obj, prop, delta, msg) {\n    if (arguments.length === 4 && typeof obj === 'function') {\n      var tmpMsg = delta;\n      delta = prop;\n      msg = tmpMsg;\n    } else if (arguments.length === 3) {\n      delta = prop;\n      prop = null;\n    }\n\n    return new Assertion(fn, msg, assert.doesNotDecreaseBy, true)\n      .to.not.decrease(obj, prop).by(delta);\n  }\n\n  /**\n   * ### .decreasesButNotBy(function, object, property, delta, [message])\n   *\n   * Asserts that a function does not decreases a numeric object property or a function's return value by an amount (delta)\n   *\n   *     var obj = { val: 10 };\n   *     var fn = function() { obj.val = 5 };\n   *     assert.decreasesButNotBy(fn, obj, 'val', 1);\n   *\n   * @name decreasesButNotBy\n   * @param {Function} modifier function\n   * @param {Object} object or getter function\n   * @param {String} property name _optional_\n   * @param {Number} change amount (delta)\n   * @param {String} message _optional_\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.decreasesButNotBy = function (fn, obj, prop, delta, msg) {\n    if (arguments.length === 4 && typeof obj === 'function') {\n      var tmpMsg = delta;\n      delta = prop;\n      msg = tmpMsg;\n    } else if (arguments.length === 3) {\n      delta = prop;\n      prop = null;\n    }\n\n    new Assertion(fn, msg, assert.decreasesButNotBy, true)\n      .to.decrease(obj, prop).but.not.by(delta);\n  }\n\n  /*!\n   * ### .ifError(object)\n   *\n   * Asserts if value is not a false value, and throws if it is a true value.\n   * This is added to allow for chai to be a drop-in replacement for Node's\n   * assert class.\n   *\n   *     var err = new Error('I am a custom error');\n   *     assert.ifError(err); // Rethrows err!\n   *\n   * @name ifError\n   * @param {Object} object\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.ifError = function (val) {\n    if (val) {\n      throw(val);\n    }\n  };\n\n  /**\n   * ### .isExtensible(object)\n   *\n   * Asserts that `object` is extensible (can have new properties added to it).\n   *\n   *     assert.isExtensible({});\n   *\n   * @name isExtensible\n   * @alias extensible\n   * @param {Object} object\n   * @param {String} message _optional_\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.isExtensible = function (obj, msg) {\n    new Assertion(obj, msg, assert.isExtensible, true).to.be.extensible;\n  };\n\n  /**\n   * ### .isNotExtensible(object)\n   *\n   * Asserts that `object` is _not_ extensible.\n   *\n   *     var nonExtensibleObject = Object.preventExtensions({});\n   *     var sealedObject = Object.seal({});\n   *     var frozenObject = Object.freeze({});\n   *\n   *     assert.isNotExtensible(nonExtensibleObject);\n   *     assert.isNotExtensible(sealedObject);\n   *     assert.isNotExtensible(frozenObject);\n   *\n   * @name isNotExtensible\n   * @alias notExtensible\n   * @param {Object} object\n   * @param {String} message _optional_\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.isNotExtensible = function (obj, msg) {\n    new Assertion(obj, msg, assert.isNotExtensible, true).to.not.be.extensible;\n  };\n\n  /**\n   * ### .isSealed(object)\n   *\n   * Asserts that `object` is sealed (cannot have new properties added to it\n   * and its existing properties cannot be removed).\n   *\n   *     var sealedObject = Object.seal({});\n   *     var frozenObject = Object.seal({});\n   *\n   *     assert.isSealed(sealedObject);\n   *     assert.isSealed(frozenObject);\n   *\n   * @name isSealed\n   * @alias sealed\n   * @param {Object} object\n   * @param {String} message _optional_\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.isSealed = function (obj, msg) {\n    new Assertion(obj, msg, assert.isSealed, true).to.be.sealed;\n  };\n\n  /**\n   * ### .isNotSealed(object)\n   *\n   * Asserts that `object` is _not_ sealed.\n   *\n   *     assert.isNotSealed({});\n   *\n   * @name isNotSealed\n   * @alias notSealed\n   * @param {Object} object\n   * @param {String} message _optional_\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.isNotSealed = function (obj, msg) {\n    new Assertion(obj, msg, assert.isNotSealed, true).to.not.be.sealed;\n  };\n\n  /**\n   * ### .isFrozen(object)\n   *\n   * Asserts that `object` is frozen (cannot have new properties added to it\n   * and its existing properties cannot be modified).\n   *\n   *     var frozenObject = Object.freeze({});\n   *     assert.frozen(frozenObject);\n   *\n   * @name isFrozen\n   * @alias frozen\n   * @param {Object} object\n   * @param {String} message _optional_\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.isFrozen = function (obj, msg) {\n    new Assertion(obj, msg, assert.isFrozen, true).to.be.frozen;\n  };\n\n  /**\n   * ### .isNotFrozen(object)\n   *\n   * Asserts that `object` is _not_ frozen.\n   *\n   *     assert.isNotFrozen({});\n   *\n   * @name isNotFrozen\n   * @alias notFrozen\n   * @param {Object} object\n   * @param {String} message _optional_\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.isNotFrozen = function (obj, msg) {\n    new Assertion(obj, msg, assert.isNotFrozen, true).to.not.be.frozen;\n  };\n\n  /**\n   * ### .isEmpty(target)\n   *\n   * Asserts that the target does not contain any values.\n   * For arrays and strings, it checks the `length` property.\n   * For `Map` and `Set` instances, it checks the `size` property.\n   * For non-function objects, it gets the count of own\n   * enumerable string keys.\n   *\n   *     assert.isEmpty([]);\n   *     assert.isEmpty('');\n   *     assert.isEmpty(new Map);\n   *     assert.isEmpty({});\n   *\n   * @name isEmpty\n   * @alias empty\n   * @param {Object|Array|String|Map|Set} target\n   * @param {String} message _optional_\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.isEmpty = function(val, msg) {\n    new Assertion(val, msg, assert.isEmpty, true).to.be.empty;\n  };\n\n  /**\n   * ### .isNotEmpty(target)\n   *\n   * Asserts that the target contains values.\n   * For arrays and strings, it checks the `length` property.\n   * For `Map` and `Set` instances, it checks the `size` property.\n   * For non-function objects, it gets the count of own\n   * enumerable string keys.\n   *\n   *     assert.isNotEmpty([1, 2]);\n   *     assert.isNotEmpty('34');\n   *     assert.isNotEmpty(new Set([5, 6]));\n   *     assert.isNotEmpty({ key: 7 });\n   *\n   * @name isNotEmpty\n   * @alias notEmpty\n   * @param {Object|Array|String|Map|Set} target\n   * @param {String} message _optional_\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.isNotEmpty = function(val, msg) {\n    new Assertion(val, msg, assert.isNotEmpty, true).to.not.be.empty;\n  };\n\n  /*!\n   * Aliases.\n   */\n\n  (function alias(name, as){\n    assert[as] = assert[name];\n    return alias;\n  })\n  ('isOk', 'ok')\n  ('isNotOk', 'notOk')\n  ('throws', 'throw')\n  ('throws', 'Throw')\n  ('isExtensible', 'extensible')\n  ('isNotExtensible', 'notExtensible')\n  ('isSealed', 'sealed')\n  ('isNotSealed', 'notSealed')\n  ('isFrozen', 'frozen')\n  ('isNotFrozen', 'notFrozen')\n  ('isEmpty', 'empty')\n  ('isNotEmpty', 'notEmpty');\n};\n\n\n//# sourceURL=webpack:////home/marcello/mdb/Code/olojs/node_modules/chai/lib/chai/interface/assert.js?");

/***/ }),

/***/ "../../node_modules/chai/lib/chai/interface/expect.js":
/*!************************************************************************************!*\
  !*** /home/marcello/mdb/Code/olojs/node_modules/chai/lib/chai/interface/expect.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/*!\n * chai\n * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\nmodule.exports = function (chai, util) {\n  chai.expect = function (val, message) {\n    return new chai.Assertion(val, message);\n  };\n\n  /**\n   * ### .fail([message])\n   * ### .fail(actual, expected, [message], [operator])\n   *\n   * Throw a failure.\n   *\n   *     expect.fail();\n   *     expect.fail(\"custom error message\");\n   *     expect.fail(1, 2);\n   *     expect.fail(1, 2, \"custom error message\");\n   *     expect.fail(1, 2, \"custom error message\", \">\");\n   *     expect.fail(1, 2, undefined, \">\");\n   *\n   * @name fail\n   * @param {Mixed} actual\n   * @param {Mixed} expected\n   * @param {String} message\n   * @param {String} operator\n   * @namespace BDD\n   * @api public\n   */\n\n  chai.expect.fail = function (actual, expected, message, operator) {\n    if (arguments.length < 2) {\n        message = actual;\n        actual = undefined;\n    }\n\n    message = message || 'expect.fail()';\n    throw new chai.AssertionError(message, {\n        actual: actual\n      , expected: expected\n      , operator: operator\n    }, chai.expect.fail);\n  };\n};\n\n\n//# sourceURL=webpack:////home/marcello/mdb/Code/olojs/node_modules/chai/lib/chai/interface/expect.js?");

/***/ }),

/***/ "../../node_modules/chai/lib/chai/interface/should.js":
/*!************************************************************************************!*\
  !*** /home/marcello/mdb/Code/olojs/node_modules/chai/lib/chai/interface/should.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/*!\n * chai\n * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\nmodule.exports = function (chai, util) {\n  var Assertion = chai.Assertion;\n\n  function loadShould () {\n    // explicitly define this method as function as to have it's name to include as `ssfi`\n    function shouldGetter() {\n      if (this instanceof String\n          || this instanceof Number\n          || this instanceof Boolean\n          || typeof Symbol === 'function' && this instanceof Symbol) {\n        return new Assertion(this.valueOf(), null, shouldGetter);\n      }\n      return new Assertion(this, null, shouldGetter);\n    }\n    function shouldSetter(value) {\n      // See https://github.com/chaijs/chai/issues/86: this makes\n      // `whatever.should = someValue` actually set `someValue`, which is\n      // especially useful for `global.should = require('chai').should()`.\n      //\n      // Note that we have to use [[DefineProperty]] instead of [[Put]]\n      // since otherwise we would trigger this very setter!\n      Object.defineProperty(this, 'should', {\n        value: value,\n        enumerable: true,\n        configurable: true,\n        writable: true\n      });\n    }\n    // modify Object.prototype to have `should`\n    Object.defineProperty(Object.prototype, 'should', {\n      set: shouldSetter\n      , get: shouldGetter\n      , configurable: true\n    });\n\n    var should = {};\n\n    /**\n     * ### .fail([message])\n     * ### .fail(actual, expected, [message], [operator])\n     *\n     * Throw a failure.\n     *\n     *     should.fail();\n     *     should.fail(\"custom error message\");\n     *     should.fail(1, 2);\n     *     should.fail(1, 2, \"custom error message\");\n     *     should.fail(1, 2, \"custom error message\", \">\");\n     *     should.fail(1, 2, undefined, \">\");\n     *\n     *\n     * @name fail\n     * @param {Mixed} actual\n     * @param {Mixed} expected\n     * @param {String} message\n     * @param {String} operator\n     * @namespace BDD\n     * @api public\n     */\n\n    should.fail = function (actual, expected, message, operator) {\n      if (arguments.length < 2) {\n          message = actual;\n          actual = undefined;\n      }\n\n      message = message || 'should.fail()';\n      throw new chai.AssertionError(message, {\n          actual: actual\n        , expected: expected\n        , operator: operator\n      }, should.fail);\n    };\n\n    /**\n     * ### .equal(actual, expected, [message])\n     *\n     * Asserts non-strict equality (`==`) of `actual` and `expected`.\n     *\n     *     should.equal(3, '3', '== coerces values to strings');\n     *\n     * @name equal\n     * @param {Mixed} actual\n     * @param {Mixed} expected\n     * @param {String} message\n     * @namespace Should\n     * @api public\n     */\n\n    should.equal = function (val1, val2, msg) {\n      new Assertion(val1, msg).to.equal(val2);\n    };\n\n    /**\n     * ### .throw(function, [constructor/string/regexp], [string/regexp], [message])\n     *\n     * Asserts that `function` will throw an error that is an instance of\n     * `constructor`, or alternately that it will throw an error with message\n     * matching `regexp`.\n     *\n     *     should.throw(fn, 'function throws a reference error');\n     *     should.throw(fn, /function throws a reference error/);\n     *     should.throw(fn, ReferenceError);\n     *     should.throw(fn, ReferenceError, 'function throws a reference error');\n     *     should.throw(fn, ReferenceError, /function throws a reference error/);\n     *\n     * @name throw\n     * @alias Throw\n     * @param {Function} function\n     * @param {ErrorConstructor} constructor\n     * @param {RegExp} regexp\n     * @param {String} message\n     * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types\n     * @namespace Should\n     * @api public\n     */\n\n    should.Throw = function (fn, errt, errs, msg) {\n      new Assertion(fn, msg).to.Throw(errt, errs);\n    };\n\n    /**\n     * ### .exist\n     *\n     * Asserts that the target is neither `null` nor `undefined`.\n     *\n     *     var foo = 'hi';\n     *\n     *     should.exist(foo, 'foo exists');\n     *\n     * @name exist\n     * @namespace Should\n     * @api public\n     */\n\n    should.exist = function (val, msg) {\n      new Assertion(val, msg).to.exist;\n    }\n\n    // negation\n    should.not = {}\n\n    /**\n     * ### .not.equal(actual, expected, [message])\n     *\n     * Asserts non-strict inequality (`!=`) of `actual` and `expected`.\n     *\n     *     should.not.equal(3, 4, 'these numbers are not equal');\n     *\n     * @name not.equal\n     * @param {Mixed} actual\n     * @param {Mixed} expected\n     * @param {String} message\n     * @namespace Should\n     * @api public\n     */\n\n    should.not.equal = function (val1, val2, msg) {\n      new Assertion(val1, msg).to.not.equal(val2);\n    };\n\n    /**\n     * ### .throw(function, [constructor/regexp], [message])\n     *\n     * Asserts that `function` will _not_ throw an error that is an instance of\n     * `constructor`, or alternately that it will not throw an error with message\n     * matching `regexp`.\n     *\n     *     should.not.throw(fn, Error, 'function does not throw');\n     *\n     * @name not.throw\n     * @alias not.Throw\n     * @param {Function} function\n     * @param {ErrorConstructor} constructor\n     * @param {RegExp} regexp\n     * @param {String} message\n     * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types\n     * @namespace Should\n     * @api public\n     */\n\n    should.not.Throw = function (fn, errt, errs, msg) {\n      new Assertion(fn, msg).to.not.Throw(errt, errs);\n    };\n\n    /**\n     * ### .not.exist\n     *\n     * Asserts that the target is neither `null` nor `undefined`.\n     *\n     *     var bar = null;\n     *\n     *     should.not.exist(bar, 'bar does not exist');\n     *\n     * @name not.exist\n     * @namespace Should\n     * @api public\n     */\n\n    should.not.exist = function (val, msg) {\n      new Assertion(val, msg).to.not.exist;\n    }\n\n    should['throw'] = should['Throw'];\n    should.not['throw'] = should.not['Throw'];\n\n    return should;\n  };\n\n  chai.should = loadShould;\n  chai.Should = loadShould;\n};\n\n\n//# sourceURL=webpack:////home/marcello/mdb/Code/olojs/node_modules/chai/lib/chai/interface/should.js?");

/***/ }),

/***/ "../../node_modules/chai/lib/chai/utils/addChainableMethod.js":
/*!********************************************************************************************!*\
  !*** /home/marcello/mdb/Code/olojs/node_modules/chai/lib/chai/utils/addChainableMethod.js ***!
  \********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/*!\n * Chai - addChainingMethod utility\n * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\n/*!\n * Module dependencies\n */\n\nvar addLengthGuard = __webpack_require__(/*! ./addLengthGuard */ \"../../node_modules/chai/lib/chai/utils/addLengthGuard.js\");\nvar chai = __webpack_require__(/*! ../../chai */ \"../../node_modules/chai/lib/chai.js\");\nvar flag = __webpack_require__(/*! ./flag */ \"../../node_modules/chai/lib/chai/utils/flag.js\");\nvar proxify = __webpack_require__(/*! ./proxify */ \"../../node_modules/chai/lib/chai/utils/proxify.js\");\nvar transferFlags = __webpack_require__(/*! ./transferFlags */ \"../../node_modules/chai/lib/chai/utils/transferFlags.js\");\n\n/*!\n * Module variables\n */\n\n// Check whether `Object.setPrototypeOf` is supported\nvar canSetPrototype = typeof Object.setPrototypeOf === 'function';\n\n// Without `Object.setPrototypeOf` support, this module will need to add properties to a function.\n// However, some of functions' own props are not configurable and should be skipped.\nvar testFn = function() {};\nvar excludeNames = Object.getOwnPropertyNames(testFn).filter(function(name) {\n  var propDesc = Object.getOwnPropertyDescriptor(testFn, name);\n\n  // Note: PhantomJS 1.x includes `callee` as one of `testFn`'s own properties,\n  // but then returns `undefined` as the property descriptor for `callee`. As a\n  // workaround, we perform an otherwise unnecessary type-check for `propDesc`,\n  // and then filter it out if it's not an object as it should be.\n  if (typeof propDesc !== 'object')\n    return true;\n\n  return !propDesc.configurable;\n});\n\n// Cache `Function` properties\nvar call  = Function.prototype.call,\n    apply = Function.prototype.apply;\n\n/**\n * ### .addChainableMethod(ctx, name, method, chainingBehavior)\n *\n * Adds a method to an object, such that the method can also be chained.\n *\n *     utils.addChainableMethod(chai.Assertion.prototype, 'foo', function (str) {\n *       var obj = utils.flag(this, 'object');\n *       new chai.Assertion(obj).to.be.equal(str);\n *     });\n *\n * Can also be accessed directly from `chai.Assertion`.\n *\n *     chai.Assertion.addChainableMethod('foo', fn, chainingBehavior);\n *\n * The result can then be used as both a method assertion, executing both `method` and\n * `chainingBehavior`, or as a language chain, which only executes `chainingBehavior`.\n *\n *     expect(fooStr).to.be.foo('bar');\n *     expect(fooStr).to.be.foo.equal('foo');\n *\n * @param {Object} ctx object to which the method is added\n * @param {String} name of method to add\n * @param {Function} method function to be used for `name`, when called\n * @param {Function} chainingBehavior function to be called every time the property is accessed\n * @namespace Utils\n * @name addChainableMethod\n * @api public\n */\n\nmodule.exports = function addChainableMethod(ctx, name, method, chainingBehavior) {\n  if (typeof chainingBehavior !== 'function') {\n    chainingBehavior = function () { };\n  }\n\n  var chainableBehavior = {\n      method: method\n    , chainingBehavior: chainingBehavior\n  };\n\n  // save the methods so we can overwrite them later, if we need to.\n  if (!ctx.__methods) {\n    ctx.__methods = {};\n  }\n  ctx.__methods[name] = chainableBehavior;\n\n  Object.defineProperty(ctx, name,\n    { get: function chainableMethodGetter() {\n        chainableBehavior.chainingBehavior.call(this);\n\n        var chainableMethodWrapper = function () {\n          // Setting the `ssfi` flag to `chainableMethodWrapper` causes this\n          // function to be the starting point for removing implementation\n          // frames from the stack trace of a failed assertion.\n          //\n          // However, we only want to use this function as the starting point if\n          // the `lockSsfi` flag isn't set.\n          //\n          // If the `lockSsfi` flag is set, then this assertion is being\n          // invoked from inside of another assertion. In this case, the `ssfi`\n          // flag has already been set by the outer assertion.\n          //\n          // Note that overwriting a chainable method merely replaces the saved\n          // methods in `ctx.__methods` instead of completely replacing the\n          // overwritten assertion. Therefore, an overwriting assertion won't\n          // set the `ssfi` or `lockSsfi` flags.\n          if (!flag(this, 'lockSsfi')) {\n            flag(this, 'ssfi', chainableMethodWrapper);\n          }\n\n          var result = chainableBehavior.method.apply(this, arguments);\n          if (result !== undefined) {\n            return result;\n          }\n\n          var newAssertion = new chai.Assertion();\n          transferFlags(this, newAssertion);\n          return newAssertion;\n        };\n\n        addLengthGuard(chainableMethodWrapper, name, true);\n\n        // Use `Object.setPrototypeOf` if available\n        if (canSetPrototype) {\n          // Inherit all properties from the object by replacing the `Function` prototype\n          var prototype = Object.create(this);\n          // Restore the `call` and `apply` methods from `Function`\n          prototype.call = call;\n          prototype.apply = apply;\n          Object.setPrototypeOf(chainableMethodWrapper, prototype);\n        }\n        // Otherwise, redefine all properties (slow!)\n        else {\n          var asserterNames = Object.getOwnPropertyNames(ctx);\n          asserterNames.forEach(function (asserterName) {\n            if (excludeNames.indexOf(asserterName) !== -1) {\n              return;\n            }\n\n            var pd = Object.getOwnPropertyDescriptor(ctx, asserterName);\n            Object.defineProperty(chainableMethodWrapper, asserterName, pd);\n          });\n        }\n\n        transferFlags(this, chainableMethodWrapper);\n        return proxify(chainableMethodWrapper);\n      }\n    , configurable: true\n  });\n};\n\n\n//# sourceURL=webpack:////home/marcello/mdb/Code/olojs/node_modules/chai/lib/chai/utils/addChainableMethod.js?");

/***/ }),

/***/ "../../node_modules/chai/lib/chai/utils/addLengthGuard.js":
/*!****************************************************************************************!*\
  !*** /home/marcello/mdb/Code/olojs/node_modules/chai/lib/chai/utils/addLengthGuard.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var fnLengthDesc = Object.getOwnPropertyDescriptor(function () {}, 'length');\n\n/*!\n * Chai - addLengthGuard utility\n * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\n/**\n * ### .addLengthGuard(fn, assertionName, isChainable)\n *\n * Define `length` as a getter on the given uninvoked method assertion. The\n * getter acts as a guard against chaining `length` directly off of an uninvoked\n * method assertion, which is a problem because it references `function`'s\n * built-in `length` property instead of Chai's `length` assertion. When the\n * getter catches the user making this mistake, it throws an error with a\n * helpful message.\n *\n * There are two ways in which this mistake can be made. The first way is by\n * chaining the `length` assertion directly off of an uninvoked chainable\n * method. In this case, Chai suggests that the user use `lengthOf` instead. The\n * second way is by chaining the `length` assertion directly off of an uninvoked\n * non-chainable method. Non-chainable methods must be invoked prior to\n * chaining. In this case, Chai suggests that the user consult the docs for the\n * given assertion.\n *\n * If the `length` property of functions is unconfigurable, then return `fn`\n * without modification.\n *\n * Note that in ES6, the function's `length` property is configurable, so once\n * support for legacy environments is dropped, Chai's `length` property can\n * replace the built-in function's `length` property, and this length guard will\n * no longer be necessary. In the mean time, maintaining consistency across all\n * environments is the priority.\n *\n * @param {Function} fn\n * @param {String} assertionName\n * @param {Boolean} isChainable\n * @namespace Utils\n * @name addLengthGuard\n */\n\nmodule.exports = function addLengthGuard (fn, assertionName, isChainable) {\n  if (!fnLengthDesc.configurable) return fn;\n\n  Object.defineProperty(fn, 'length', {\n    get: function () {\n      if (isChainable) {\n        throw Error('Invalid Chai property: ' + assertionName + '.length. Due' +\n          ' to a compatibility issue, \"length\" cannot directly follow \"' +\n          assertionName + '\". Use \"' + assertionName + '.lengthOf\" instead.');\n      }\n\n      throw Error('Invalid Chai property: ' + assertionName + '.length. See' +\n        ' docs for proper usage of \"' + assertionName + '\".');\n    }\n  });\n\n  return fn;\n};\n\n\n//# sourceURL=webpack:////home/marcello/mdb/Code/olojs/node_modules/chai/lib/chai/utils/addLengthGuard.js?");

/***/ }),

/***/ "../../node_modules/chai/lib/chai/utils/addMethod.js":
/*!***********************************************************************************!*\
  !*** /home/marcello/mdb/Code/olojs/node_modules/chai/lib/chai/utils/addMethod.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/*!\n * Chai - addMethod utility\n * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\nvar addLengthGuard = __webpack_require__(/*! ./addLengthGuard */ \"../../node_modules/chai/lib/chai/utils/addLengthGuard.js\");\nvar chai = __webpack_require__(/*! ../../chai */ \"../../node_modules/chai/lib/chai.js\");\nvar flag = __webpack_require__(/*! ./flag */ \"../../node_modules/chai/lib/chai/utils/flag.js\");\nvar proxify = __webpack_require__(/*! ./proxify */ \"../../node_modules/chai/lib/chai/utils/proxify.js\");\nvar transferFlags = __webpack_require__(/*! ./transferFlags */ \"../../node_modules/chai/lib/chai/utils/transferFlags.js\");\n\n/**\n * ### .addMethod(ctx, name, method)\n *\n * Adds a method to the prototype of an object.\n *\n *     utils.addMethod(chai.Assertion.prototype, 'foo', function (str) {\n *       var obj = utils.flag(this, 'object');\n *       new chai.Assertion(obj).to.be.equal(str);\n *     });\n *\n * Can also be accessed directly from `chai.Assertion`.\n *\n *     chai.Assertion.addMethod('foo', fn);\n *\n * Then can be used as any other assertion.\n *\n *     expect(fooStr).to.be.foo('bar');\n *\n * @param {Object} ctx object to which the method is added\n * @param {String} name of method to add\n * @param {Function} method function to be used for name\n * @namespace Utils\n * @name addMethod\n * @api public\n */\n\nmodule.exports = function addMethod(ctx, name, method) {\n  var methodWrapper = function () {\n    // Setting the `ssfi` flag to `methodWrapper` causes this function to be the\n    // starting point for removing implementation frames from the stack trace of\n    // a failed assertion.\n    //\n    // However, we only want to use this function as the starting point if the\n    // `lockSsfi` flag isn't set.\n    //\n    // If the `lockSsfi` flag is set, then either this assertion has been\n    // overwritten by another assertion, or this assertion is being invoked from\n    // inside of another assertion. In the first case, the `ssfi` flag has\n    // already been set by the overwriting assertion. In the second case, the\n    // `ssfi` flag has already been set by the outer assertion.\n    if (!flag(this, 'lockSsfi')) {\n      flag(this, 'ssfi', methodWrapper);\n    }\n\n    var result = method.apply(this, arguments);\n    if (result !== undefined)\n      return result;\n\n    var newAssertion = new chai.Assertion();\n    transferFlags(this, newAssertion);\n    return newAssertion;\n  };\n\n  addLengthGuard(methodWrapper, name, false);\n  ctx[name] = proxify(methodWrapper, name);\n};\n\n\n//# sourceURL=webpack:////home/marcello/mdb/Code/olojs/node_modules/chai/lib/chai/utils/addMethod.js?");

/***/ }),

/***/ "../../node_modules/chai/lib/chai/utils/addProperty.js":
/*!*************************************************************************************!*\
  !*** /home/marcello/mdb/Code/olojs/node_modules/chai/lib/chai/utils/addProperty.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/*!\n * Chai - addProperty utility\n * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\nvar chai = __webpack_require__(/*! ../../chai */ \"../../node_modules/chai/lib/chai.js\");\nvar flag = __webpack_require__(/*! ./flag */ \"../../node_modules/chai/lib/chai/utils/flag.js\");\nvar isProxyEnabled = __webpack_require__(/*! ./isProxyEnabled */ \"../../node_modules/chai/lib/chai/utils/isProxyEnabled.js\");\nvar transferFlags = __webpack_require__(/*! ./transferFlags */ \"../../node_modules/chai/lib/chai/utils/transferFlags.js\");\n\n/**\n * ### .addProperty(ctx, name, getter)\n *\n * Adds a property to the prototype of an object.\n *\n *     utils.addProperty(chai.Assertion.prototype, 'foo', function () {\n *       var obj = utils.flag(this, 'object');\n *       new chai.Assertion(obj).to.be.instanceof(Foo);\n *     });\n *\n * Can also be accessed directly from `chai.Assertion`.\n *\n *     chai.Assertion.addProperty('foo', fn);\n *\n * Then can be used as any other assertion.\n *\n *     expect(myFoo).to.be.foo;\n *\n * @param {Object} ctx object to which the property is added\n * @param {String} name of property to add\n * @param {Function} getter function to be used for name\n * @namespace Utils\n * @name addProperty\n * @api public\n */\n\nmodule.exports = function addProperty(ctx, name, getter) {\n  getter = getter === undefined ? function () {} : getter;\n\n  Object.defineProperty(ctx, name,\n    { get: function propertyGetter() {\n        // Setting the `ssfi` flag to `propertyGetter` causes this function to\n        // be the starting point for removing implementation frames from the\n        // stack trace of a failed assertion.\n        //\n        // However, we only want to use this function as the starting point if\n        // the `lockSsfi` flag isn't set and proxy protection is disabled.\n        //\n        // If the `lockSsfi` flag is set, then either this assertion has been\n        // overwritten by another assertion, or this assertion is being invoked\n        // from inside of another assertion. In the first case, the `ssfi` flag\n        // has already been set by the overwriting assertion. In the second\n        // case, the `ssfi` flag has already been set by the outer assertion.\n        //\n        // If proxy protection is enabled, then the `ssfi` flag has already been\n        // set by the proxy getter.\n        if (!isProxyEnabled() && !flag(this, 'lockSsfi')) {\n          flag(this, 'ssfi', propertyGetter);\n        }\n\n        var result = getter.call(this);\n        if (result !== undefined)\n          return result;\n\n        var newAssertion = new chai.Assertion();\n        transferFlags(this, newAssertion);\n        return newAssertion;\n      }\n    , configurable: true\n  });\n};\n\n\n//# sourceURL=webpack:////home/marcello/mdb/Code/olojs/node_modules/chai/lib/chai/utils/addProperty.js?");

/***/ }),

/***/ "../../node_modules/chai/lib/chai/utils/compareByInspect.js":
/*!******************************************************************************************!*\
  !*** /home/marcello/mdb/Code/olojs/node_modules/chai/lib/chai/utils/compareByInspect.js ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/*!\n * Chai - compareByInspect utility\n * Copyright(c) 2011-2016 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\n/*!\n * Module dependencies\n */\n\nvar inspect = __webpack_require__(/*! ./inspect */ \"../../node_modules/chai/lib/chai/utils/inspect.js\");\n\n/**\n * ### .compareByInspect(mixed, mixed)\n *\n * To be used as a compareFunction with Array.prototype.sort. Compares elements\n * using inspect instead of default behavior of using toString so that Symbols\n * and objects with irregular/missing toString can still be sorted without a\n * TypeError.\n *\n * @param {Mixed} first element to compare\n * @param {Mixed} second element to compare\n * @returns {Number} -1 if 'a' should come before 'b'; otherwise 1\n * @name compareByInspect\n * @namespace Utils\n * @api public\n */\n\nmodule.exports = function compareByInspect(a, b) {\n  return inspect(a) < inspect(b) ? -1 : 1;\n};\n\n\n//# sourceURL=webpack:////home/marcello/mdb/Code/olojs/node_modules/chai/lib/chai/utils/compareByInspect.js?");

/***/ }),

/***/ "../../node_modules/chai/lib/chai/utils/expectTypes.js":
/*!*************************************************************************************!*\
  !*** /home/marcello/mdb/Code/olojs/node_modules/chai/lib/chai/utils/expectTypes.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/*!\n * Chai - expectTypes utility\n * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\n/**\n * ### .expectTypes(obj, types)\n *\n * Ensures that the object being tested against is of a valid type.\n *\n *     utils.expectTypes(this, ['array', 'object', 'string']);\n *\n * @param {Mixed} obj constructed Assertion\n * @param {Array} type A list of allowed types for this assertion\n * @namespace Utils\n * @name expectTypes\n * @api public\n */\n\nvar AssertionError = __webpack_require__(/*! assertion-error */ \"../../node_modules/assertion-error/index.js\");\nvar flag = __webpack_require__(/*! ./flag */ \"../../node_modules/chai/lib/chai/utils/flag.js\");\nvar type = __webpack_require__(/*! type-detect */ \"../../node_modules/type-detect/type-detect.js\");\n\nmodule.exports = function expectTypes(obj, types) {\n  var flagMsg = flag(obj, 'message');\n  var ssfi = flag(obj, 'ssfi');\n\n  flagMsg = flagMsg ? flagMsg + ': ' : '';\n\n  obj = flag(obj, 'object');\n  types = types.map(function (t) { return t.toLowerCase(); });\n  types.sort();\n\n  // Transforms ['lorem', 'ipsum'] into 'a lorem, or an ipsum'\n  var str = types.map(function (t, index) {\n    var art = ~[ 'a', 'e', 'i', 'o', 'u' ].indexOf(t.charAt(0)) ? 'an' : 'a';\n    var or = types.length > 1 && index === types.length - 1 ? 'or ' : '';\n    return or + art + ' ' + t;\n  }).join(', ');\n\n  var objType = type(obj).toLowerCase();\n\n  if (!types.some(function (expected) { return objType === expected; })) {\n    throw new AssertionError(\n      flagMsg + 'object tested must be ' + str + ', but ' + objType + ' given',\n      undefined,\n      ssfi\n    );\n  }\n};\n\n\n//# sourceURL=webpack:////home/marcello/mdb/Code/olojs/node_modules/chai/lib/chai/utils/expectTypes.js?");

/***/ }),

/***/ "../../node_modules/chai/lib/chai/utils/flag.js":
/*!******************************************************************************!*\
  !*** /home/marcello/mdb/Code/olojs/node_modules/chai/lib/chai/utils/flag.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/*!\n * Chai - flag utility\n * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\n/**\n * ### .flag(object, key, [value])\n *\n * Get or set a flag value on an object. If a\n * value is provided it will be set, else it will\n * return the currently set value or `undefined` if\n * the value is not set.\n *\n *     utils.flag(this, 'foo', 'bar'); // setter\n *     utils.flag(this, 'foo'); // getter, returns `bar`\n *\n * @param {Object} object constructed Assertion\n * @param {String} key\n * @param {Mixed} value (optional)\n * @namespace Utils\n * @name flag\n * @api private\n */\n\nmodule.exports = function flag(obj, key, value) {\n  var flags = obj.__flags || (obj.__flags = Object.create(null));\n  if (arguments.length === 3) {\n    flags[key] = value;\n  } else {\n    return flags[key];\n  }\n};\n\n\n//# sourceURL=webpack:////home/marcello/mdb/Code/olojs/node_modules/chai/lib/chai/utils/flag.js?");

/***/ }),

/***/ "../../node_modules/chai/lib/chai/utils/getActual.js":
/*!***********************************************************************************!*\
  !*** /home/marcello/mdb/Code/olojs/node_modules/chai/lib/chai/utils/getActual.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/*!\n * Chai - getActual utility\n * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\n/**\n * ### .getActual(object, [actual])\n *\n * Returns the `actual` value for an Assertion.\n *\n * @param {Object} object (constructed Assertion)\n * @param {Arguments} chai.Assertion.prototype.assert arguments\n * @namespace Utils\n * @name getActual\n */\n\nmodule.exports = function getActual(obj, args) {\n  return args.length > 4 ? args[4] : obj._obj;\n};\n\n\n//# sourceURL=webpack:////home/marcello/mdb/Code/olojs/node_modules/chai/lib/chai/utils/getActual.js?");

/***/ }),

/***/ "../../node_modules/chai/lib/chai/utils/getEnumerableProperties.js":
/*!*************************************************************************************************!*\
  !*** /home/marcello/mdb/Code/olojs/node_modules/chai/lib/chai/utils/getEnumerableProperties.js ***!
  \*************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/*!\n * Chai - getEnumerableProperties utility\n * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\n/**\n * ### .getEnumerableProperties(object)\n *\n * This allows the retrieval of enumerable property names of an object,\n * inherited or not.\n *\n * @param {Object} object\n * @returns {Array}\n * @namespace Utils\n * @name getEnumerableProperties\n * @api public\n */\n\nmodule.exports = function getEnumerableProperties(object) {\n  var result = [];\n  for (var name in object) {\n    result.push(name);\n  }\n  return result;\n};\n\n\n//# sourceURL=webpack:////home/marcello/mdb/Code/olojs/node_modules/chai/lib/chai/utils/getEnumerableProperties.js?");

/***/ }),

/***/ "../../node_modules/chai/lib/chai/utils/getMessage.js":
/*!************************************************************************************!*\
  !*** /home/marcello/mdb/Code/olojs/node_modules/chai/lib/chai/utils/getMessage.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/*!\n * Chai - message composition utility\n * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\n/*!\n * Module dependencies\n */\n\nvar flag = __webpack_require__(/*! ./flag */ \"../../node_modules/chai/lib/chai/utils/flag.js\")\n  , getActual = __webpack_require__(/*! ./getActual */ \"../../node_modules/chai/lib/chai/utils/getActual.js\")\n  , objDisplay = __webpack_require__(/*! ./objDisplay */ \"../../node_modules/chai/lib/chai/utils/objDisplay.js\");\n\n/**\n * ### .getMessage(object, message, negateMessage)\n *\n * Construct the error message based on flags\n * and template tags. Template tags will return\n * a stringified inspection of the object referenced.\n *\n * Message template tags:\n * - `#{this}` current asserted object\n * - `#{act}` actual value\n * - `#{exp}` expected value\n *\n * @param {Object} object (constructed Assertion)\n * @param {Arguments} chai.Assertion.prototype.assert arguments\n * @namespace Utils\n * @name getMessage\n * @api public\n */\n\nmodule.exports = function getMessage(obj, args) {\n  var negate = flag(obj, 'negate')\n    , val = flag(obj, 'object')\n    , expected = args[3]\n    , actual = getActual(obj, args)\n    , msg = negate ? args[2] : args[1]\n    , flagMsg = flag(obj, 'message');\n\n  if(typeof msg === \"function\") msg = msg();\n  msg = msg || '';\n  msg = msg\n    .replace(/#\\{this\\}/g, function () { return objDisplay(val); })\n    .replace(/#\\{act\\}/g, function () { return objDisplay(actual); })\n    .replace(/#\\{exp\\}/g, function () { return objDisplay(expected); });\n\n  return flagMsg ? flagMsg + ': ' + msg : msg;\n};\n\n\n//# sourceURL=webpack:////home/marcello/mdb/Code/olojs/node_modules/chai/lib/chai/utils/getMessage.js?");

/***/ }),

/***/ "../../node_modules/chai/lib/chai/utils/getOwnEnumerableProperties.js":
/*!****************************************************************************************************!*\
  !*** /home/marcello/mdb/Code/olojs/node_modules/chai/lib/chai/utils/getOwnEnumerableProperties.js ***!
  \****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/*!\n * Chai - getOwnEnumerableProperties utility\n * Copyright(c) 2011-2016 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\n/*!\n * Module dependencies\n */\n\nvar getOwnEnumerablePropertySymbols = __webpack_require__(/*! ./getOwnEnumerablePropertySymbols */ \"../../node_modules/chai/lib/chai/utils/getOwnEnumerablePropertySymbols.js\");\n\n/**\n * ### .getOwnEnumerableProperties(object)\n *\n * This allows the retrieval of directly-owned enumerable property names and\n * symbols of an object. This function is necessary because Object.keys only\n * returns enumerable property names, not enumerable property symbols.\n *\n * @param {Object} object\n * @returns {Array}\n * @namespace Utils\n * @name getOwnEnumerableProperties\n * @api public\n */\n\nmodule.exports = function getOwnEnumerableProperties(obj) {\n  return Object.keys(obj).concat(getOwnEnumerablePropertySymbols(obj));\n};\n\n\n//# sourceURL=webpack:////home/marcello/mdb/Code/olojs/node_modules/chai/lib/chai/utils/getOwnEnumerableProperties.js?");

/***/ }),

/***/ "../../node_modules/chai/lib/chai/utils/getOwnEnumerablePropertySymbols.js":
/*!*********************************************************************************************************!*\
  !*** /home/marcello/mdb/Code/olojs/node_modules/chai/lib/chai/utils/getOwnEnumerablePropertySymbols.js ***!
  \*********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/*!\n * Chai - getOwnEnumerablePropertySymbols utility\n * Copyright(c) 2011-2016 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\n/**\n * ### .getOwnEnumerablePropertySymbols(object)\n *\n * This allows the retrieval of directly-owned enumerable property symbols of an\n * object. This function is necessary because Object.getOwnPropertySymbols\n * returns both enumerable and non-enumerable property symbols.\n *\n * @param {Object} object\n * @returns {Array}\n * @namespace Utils\n * @name getOwnEnumerablePropertySymbols\n * @api public\n */\n\nmodule.exports = function getOwnEnumerablePropertySymbols(obj) {\n  if (typeof Object.getOwnPropertySymbols !== 'function') return [];\n\n  return Object.getOwnPropertySymbols(obj).filter(function (sym) {\n    return Object.getOwnPropertyDescriptor(obj, sym).enumerable;\n  });\n};\n\n\n//# sourceURL=webpack:////home/marcello/mdb/Code/olojs/node_modules/chai/lib/chai/utils/getOwnEnumerablePropertySymbols.js?");

/***/ }),

/***/ "../../node_modules/chai/lib/chai/utils/getProperties.js":
/*!***************************************************************************************!*\
  !*** /home/marcello/mdb/Code/olojs/node_modules/chai/lib/chai/utils/getProperties.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/*!\n * Chai - getProperties utility\n * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\n/**\n * ### .getProperties(object)\n *\n * This allows the retrieval of property names of an object, enumerable or not,\n * inherited or not.\n *\n * @param {Object} object\n * @returns {Array}\n * @namespace Utils\n * @name getProperties\n * @api public\n */\n\nmodule.exports = function getProperties(object) {\n  var result = Object.getOwnPropertyNames(object);\n\n  function addProperty(property) {\n    if (result.indexOf(property) === -1) {\n      result.push(property);\n    }\n  }\n\n  var proto = Object.getPrototypeOf(object);\n  while (proto !== null) {\n    Object.getOwnPropertyNames(proto).forEach(addProperty);\n    proto = Object.getPrototypeOf(proto);\n  }\n\n  return result;\n};\n\n\n//# sourceURL=webpack:////home/marcello/mdb/Code/olojs/node_modules/chai/lib/chai/utils/getProperties.js?");

/***/ }),

/***/ "../../node_modules/chai/lib/chai/utils/index.js":
/*!*******************************************************************************!*\
  !*** /home/marcello/mdb/Code/olojs/node_modules/chai/lib/chai/utils/index.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/*!\n * chai\n * Copyright(c) 2011 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\n/*!\n * Dependencies that are used for multiple exports are required here only once\n */\n\nvar pathval = __webpack_require__(/*! pathval */ \"../../node_modules/pathval/index.js\");\n\n/*!\n * test utility\n */\n\nexports.test = __webpack_require__(/*! ./test */ \"../../node_modules/chai/lib/chai/utils/test.js\");\n\n/*!\n * type utility\n */\n\nexports.type = __webpack_require__(/*! type-detect */ \"../../node_modules/type-detect/type-detect.js\");\n\n/*!\n * expectTypes utility\n */\nexports.expectTypes = __webpack_require__(/*! ./expectTypes */ \"../../node_modules/chai/lib/chai/utils/expectTypes.js\");\n\n/*!\n * message utility\n */\n\nexports.getMessage = __webpack_require__(/*! ./getMessage */ \"../../node_modules/chai/lib/chai/utils/getMessage.js\");\n\n/*!\n * actual utility\n */\n\nexports.getActual = __webpack_require__(/*! ./getActual */ \"../../node_modules/chai/lib/chai/utils/getActual.js\");\n\n/*!\n * Inspect util\n */\n\nexports.inspect = __webpack_require__(/*! ./inspect */ \"../../node_modules/chai/lib/chai/utils/inspect.js\");\n\n/*!\n * Object Display util\n */\n\nexports.objDisplay = __webpack_require__(/*! ./objDisplay */ \"../../node_modules/chai/lib/chai/utils/objDisplay.js\");\n\n/*!\n * Flag utility\n */\n\nexports.flag = __webpack_require__(/*! ./flag */ \"../../node_modules/chai/lib/chai/utils/flag.js\");\n\n/*!\n * Flag transferring utility\n */\n\nexports.transferFlags = __webpack_require__(/*! ./transferFlags */ \"../../node_modules/chai/lib/chai/utils/transferFlags.js\");\n\n/*!\n * Deep equal utility\n */\n\nexports.eql = __webpack_require__(/*! deep-eql */ \"../../node_modules/deep-eql/index.js\");\n\n/*!\n * Deep path info\n */\n\nexports.getPathInfo = pathval.getPathInfo;\n\n/*!\n * Check if a property exists\n */\n\nexports.hasProperty = pathval.hasProperty;\n\n/*!\n * Function name\n */\n\nexports.getName = __webpack_require__(/*! get-func-name */ \"../../node_modules/get-func-name/index.js\");\n\n/*!\n * add Property\n */\n\nexports.addProperty = __webpack_require__(/*! ./addProperty */ \"../../node_modules/chai/lib/chai/utils/addProperty.js\");\n\n/*!\n * add Method\n */\n\nexports.addMethod = __webpack_require__(/*! ./addMethod */ \"../../node_modules/chai/lib/chai/utils/addMethod.js\");\n\n/*!\n * overwrite Property\n */\n\nexports.overwriteProperty = __webpack_require__(/*! ./overwriteProperty */ \"../../node_modules/chai/lib/chai/utils/overwriteProperty.js\");\n\n/*!\n * overwrite Method\n */\n\nexports.overwriteMethod = __webpack_require__(/*! ./overwriteMethod */ \"../../node_modules/chai/lib/chai/utils/overwriteMethod.js\");\n\n/*!\n * Add a chainable method\n */\n\nexports.addChainableMethod = __webpack_require__(/*! ./addChainableMethod */ \"../../node_modules/chai/lib/chai/utils/addChainableMethod.js\");\n\n/*!\n * Overwrite chainable method\n */\n\nexports.overwriteChainableMethod = __webpack_require__(/*! ./overwriteChainableMethod */ \"../../node_modules/chai/lib/chai/utils/overwriteChainableMethod.js\");\n\n/*!\n * Compare by inspect method\n */\n\nexports.compareByInspect = __webpack_require__(/*! ./compareByInspect */ \"../../node_modules/chai/lib/chai/utils/compareByInspect.js\");\n\n/*!\n * Get own enumerable property symbols method\n */\n\nexports.getOwnEnumerablePropertySymbols = __webpack_require__(/*! ./getOwnEnumerablePropertySymbols */ \"../../node_modules/chai/lib/chai/utils/getOwnEnumerablePropertySymbols.js\");\n\n/*!\n * Get own enumerable properties method\n */\n\nexports.getOwnEnumerableProperties = __webpack_require__(/*! ./getOwnEnumerableProperties */ \"../../node_modules/chai/lib/chai/utils/getOwnEnumerableProperties.js\");\n\n/*!\n * Checks error against a given set of criteria\n */\n\nexports.checkError = __webpack_require__(/*! check-error */ \"../../node_modules/check-error/index.js\");\n\n/*!\n * Proxify util\n */\n\nexports.proxify = __webpack_require__(/*! ./proxify */ \"../../node_modules/chai/lib/chai/utils/proxify.js\");\n\n/*!\n * addLengthGuard util\n */\n\nexports.addLengthGuard = __webpack_require__(/*! ./addLengthGuard */ \"../../node_modules/chai/lib/chai/utils/addLengthGuard.js\");\n\n/*!\n * isProxyEnabled helper\n */\n\nexports.isProxyEnabled = __webpack_require__(/*! ./isProxyEnabled */ \"../../node_modules/chai/lib/chai/utils/isProxyEnabled.js\");\n\n/*!\n * isNaN method\n */\n\nexports.isNaN = __webpack_require__(/*! ./isNaN */ \"../../node_modules/chai/lib/chai/utils/isNaN.js\");\n\n\n//# sourceURL=webpack:////home/marcello/mdb/Code/olojs/node_modules/chai/lib/chai/utils/index.js?");

/***/ }),

/***/ "../../node_modules/chai/lib/chai/utils/inspect.js":
/*!*********************************************************************************!*\
  !*** /home/marcello/mdb/Code/olojs/node_modules/chai/lib/chai/utils/inspect.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// This is (almost) directly from Node.js utils\n// https://github.com/joyent/node/blob/f8c335d0caf47f16d31413f89aa28eda3878e3aa/lib/util.js\n\nvar getName = __webpack_require__(/*! get-func-name */ \"../../node_modules/get-func-name/index.js\");\nvar getProperties = __webpack_require__(/*! ./getProperties */ \"../../node_modules/chai/lib/chai/utils/getProperties.js\");\nvar getEnumerableProperties = __webpack_require__(/*! ./getEnumerableProperties */ \"../../node_modules/chai/lib/chai/utils/getEnumerableProperties.js\");\nvar config = __webpack_require__(/*! ../config */ \"../../node_modules/chai/lib/chai/config.js\");\n\nmodule.exports = inspect;\n\n/**\n * ### .inspect(obj, [showHidden], [depth], [colors])\n *\n * Echoes the value of a value. Tries to print the value out\n * in the best way possible given the different types.\n *\n * @param {Object} obj The object to print out.\n * @param {Boolean} showHidden Flag that shows hidden (not enumerable)\n *    properties of objects. Default is false.\n * @param {Number} depth Depth in which to descend in object. Default is 2.\n * @param {Boolean} colors Flag to turn on ANSI escape codes to color the\n *    output. Default is false (no coloring).\n * @namespace Utils\n * @name inspect\n */\nfunction inspect(obj, showHidden, depth, colors) {\n  var ctx = {\n    showHidden: showHidden,\n    seen: [],\n    stylize: function (str) { return str; }\n  };\n  return formatValue(ctx, obj, (typeof depth === 'undefined' ? 2 : depth));\n}\n\n// Returns true if object is a DOM element.\nvar isDOMElement = function (object) {\n  if (typeof HTMLElement === 'object') {\n    return object instanceof HTMLElement;\n  } else {\n    return object &&\n      typeof object === 'object' &&\n      'nodeType' in object &&\n      object.nodeType === 1 &&\n      typeof object.nodeName === 'string';\n  }\n};\n\nfunction formatValue(ctx, value, recurseTimes) {\n  // Provide a hook for user-specified inspect functions.\n  // Check that value is an object with an inspect function on it\n  if (value && typeof value.inspect === 'function' &&\n      // Filter out the util module, it's inspect function is special\n      value.inspect !== exports.inspect &&\n      // Also filter out any prototype objects using the circular check.\n      !(value.constructor && value.constructor.prototype === value)) {\n    var ret = value.inspect(recurseTimes, ctx);\n    if (typeof ret !== 'string') {\n      ret = formatValue(ctx, ret, recurseTimes);\n    }\n    return ret;\n  }\n\n  // Primitive types cannot have properties\n  var primitive = formatPrimitive(ctx, value);\n  if (primitive) {\n    return primitive;\n  }\n\n  // If this is a DOM element, try to get the outer HTML.\n  if (isDOMElement(value)) {\n    if ('outerHTML' in value) {\n      return value.outerHTML;\n      // This value does not have an outerHTML attribute,\n      //   it could still be an XML element\n    } else {\n      // Attempt to serialize it\n      try {\n        if (document.xmlVersion) {\n          var xmlSerializer = new XMLSerializer();\n          return xmlSerializer.serializeToString(value);\n        } else {\n          // Firefox 11- do not support outerHTML\n          //   It does, however, support innerHTML\n          //   Use the following to render the element\n          var ns = \"http://www.w3.org/1999/xhtml\";\n          var container = document.createElementNS(ns, '_');\n\n          container.appendChild(value.cloneNode(false));\n          var html = container.innerHTML\n            .replace('><', '>' + value.innerHTML + '<');\n          container.innerHTML = '';\n          return html;\n        }\n      } catch (err) {\n        // This could be a non-native DOM implementation,\n        //   continue with the normal flow:\n        //   printing the element as if it is an object.\n      }\n    }\n  }\n\n  // Look up the keys of the object.\n  var visibleKeys = getEnumerableProperties(value);\n  var keys = ctx.showHidden ? getProperties(value) : visibleKeys;\n\n  var name, nameSuffix;\n\n  // Some type of object without properties can be shortcut.\n  // In IE, errors have a single `stack` property, or if they are vanilla `Error`,\n  // a `stack` plus `description` property; ignore those for consistency.\n  if (keys.length === 0 || (isError(value) && (\n      (keys.length === 1 && keys[0] === 'stack') ||\n      (keys.length === 2 && keys[0] === 'description' && keys[1] === 'stack')\n     ))) {\n    if (typeof value === 'function') {\n      name = getName(value);\n      nameSuffix = name ? ': ' + name : '';\n      return ctx.stylize('[Function' + nameSuffix + ']', 'special');\n    }\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    }\n    if (isDate(value)) {\n      return ctx.stylize(Date.prototype.toUTCString.call(value), 'date');\n    }\n    if (isError(value)) {\n      return formatError(value);\n    }\n  }\n\n  var base = ''\n    , array = false\n    , typedArray = false\n    , braces = ['{', '}'];\n\n  if (isTypedArray(value)) {\n    typedArray = true;\n    braces = ['[', ']'];\n  }\n\n  // Make Array say that they are Array\n  if (isArray(value)) {\n    array = true;\n    braces = ['[', ']'];\n  }\n\n  // Make functions say that they are functions\n  if (typeof value === 'function') {\n    name = getName(value);\n    nameSuffix = name ? ': ' + name : '';\n    base = ' [Function' + nameSuffix + ']';\n  }\n\n  // Make RegExps say that they are RegExps\n  if (isRegExp(value)) {\n    base = ' ' + RegExp.prototype.toString.call(value);\n  }\n\n  // Make dates with properties first say the date\n  if (isDate(value)) {\n    base = ' ' + Date.prototype.toUTCString.call(value);\n  }\n\n  // Make error with message first say the error\n  if (isError(value)) {\n    return formatError(value);\n  }\n\n  if (keys.length === 0 && (!array || value.length == 0)) {\n    return braces[0] + base + braces[1];\n  }\n\n  if (recurseTimes < 0) {\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    } else {\n      return ctx.stylize('[Object]', 'special');\n    }\n  }\n\n  ctx.seen.push(value);\n\n  var output;\n  if (array) {\n    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);\n  } else if (typedArray) {\n    return formatTypedArray(value);\n  } else {\n    output = keys.map(function(key) {\n      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);\n    });\n  }\n\n  ctx.seen.pop();\n\n  return reduceToSingleString(output, base, braces);\n}\n\nfunction formatPrimitive(ctx, value) {\n  switch (typeof value) {\n    case 'undefined':\n      return ctx.stylize('undefined', 'undefined');\n\n    case 'string':\n      var simple = '\\'' + JSON.stringify(value).replace(/^\"|\"$/g, '')\n                                               .replace(/'/g, \"\\\\'\")\n                                               .replace(/\\\\\"/g, '\"') + '\\'';\n      return ctx.stylize(simple, 'string');\n\n    case 'number':\n      if (value === 0 && (1/value) === -Infinity) {\n        return ctx.stylize('-0', 'number');\n      }\n      return ctx.stylize('' + value, 'number');\n\n    case 'boolean':\n      return ctx.stylize('' + value, 'boolean');\n\n    case 'symbol':\n      return ctx.stylize(value.toString(), 'symbol');\n  }\n  // For some reason typeof null is \"object\", so special case here.\n  if (value === null) {\n    return ctx.stylize('null', 'null');\n  }\n}\n\nfunction formatError(value) {\n  return '[' + Error.prototype.toString.call(value) + ']';\n}\n\nfunction formatArray(ctx, value, recurseTimes, visibleKeys, keys) {\n  var output = [];\n  for (var i = 0, l = value.length; i < l; ++i) {\n    if (Object.prototype.hasOwnProperty.call(value, String(i))) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          String(i), true));\n    } else {\n      output.push('');\n    }\n  }\n\n  keys.forEach(function(key) {\n    if (!key.match(/^\\d+$/)) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          key, true));\n    }\n  });\n  return output;\n}\n\nfunction formatTypedArray(value) {\n  var str = '[ ';\n\n  for (var i = 0; i < value.length; ++i) {\n    if (str.length >= config.truncateThreshold - 7) {\n      str += '...';\n      break;\n    }\n    str += value[i] + ', ';\n  }\n  str += ' ]';\n\n  // Removing trailing `, ` if the array was not truncated\n  if (str.indexOf(',  ]') !== -1) {\n    str = str.replace(',  ]', ' ]');\n  }\n\n  return str;\n}\n\nfunction formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {\n  var name;\n  var propDescriptor = Object.getOwnPropertyDescriptor(value, key);\n  var str;\n\n  if (propDescriptor) {\n    if (propDescriptor.get) {\n      if (propDescriptor.set) {\n        str = ctx.stylize('[Getter/Setter]', 'special');\n      } else {\n        str = ctx.stylize('[Getter]', 'special');\n      }\n    } else {\n      if (propDescriptor.set) {\n        str = ctx.stylize('[Setter]', 'special');\n      }\n    }\n  }\n  if (visibleKeys.indexOf(key) < 0) {\n    name = '[' + key + ']';\n  }\n  if (!str) {\n    if (ctx.seen.indexOf(value[key]) < 0) {\n      if (recurseTimes === null) {\n        str = formatValue(ctx, value[key], null);\n      } else {\n        str = formatValue(ctx, value[key], recurseTimes - 1);\n      }\n      if (str.indexOf('\\n') > -1) {\n        if (array) {\n          str = str.split('\\n').map(function(line) {\n            return '  ' + line;\n          }).join('\\n').substr(2);\n        } else {\n          str = '\\n' + str.split('\\n').map(function(line) {\n            return '   ' + line;\n          }).join('\\n');\n        }\n      }\n    } else {\n      str = ctx.stylize('[Circular]', 'special');\n    }\n  }\n  if (typeof name === 'undefined') {\n    if (array && key.match(/^\\d+$/)) {\n      return str;\n    }\n    name = JSON.stringify('' + key);\n    if (name.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)) {\n      name = name.substr(1, name.length - 2);\n      name = ctx.stylize(name, 'name');\n    } else {\n      name = name.replace(/'/g, \"\\\\'\")\n                 .replace(/\\\\\"/g, '\"')\n                 .replace(/(^\"|\"$)/g, \"'\");\n      name = ctx.stylize(name, 'string');\n    }\n  }\n\n  return name + ': ' + str;\n}\n\nfunction reduceToSingleString(output, base, braces) {\n  var length = output.reduce(function(prev, cur) {\n    return prev + cur.length + 1;\n  }, 0);\n\n  if (length > 60) {\n    return braces[0] +\n           (base === '' ? '' : base + '\\n ') +\n           ' ' +\n           output.join(',\\n  ') +\n           ' ' +\n           braces[1];\n  }\n\n  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];\n}\n\nfunction isTypedArray(ar) {\n  // Unfortunately there's no way to check if an object is a TypedArray\n  // We have to check if it's one of these types\n  return (typeof ar === 'object' && /\\w+Array]$/.test(objectToString(ar)));\n}\n\nfunction isArray(ar) {\n  return Array.isArray(ar) ||\n         (typeof ar === 'object' && objectToString(ar) === '[object Array]');\n}\n\nfunction isRegExp(re) {\n  return typeof re === 'object' && objectToString(re) === '[object RegExp]';\n}\n\nfunction isDate(d) {\n  return typeof d === 'object' && objectToString(d) === '[object Date]';\n}\n\nfunction isError(e) {\n  return typeof e === 'object' && objectToString(e) === '[object Error]';\n}\n\nfunction objectToString(o) {\n  return Object.prototype.toString.call(o);\n}\n\n\n//# sourceURL=webpack:////home/marcello/mdb/Code/olojs/node_modules/chai/lib/chai/utils/inspect.js?");

/***/ }),

/***/ "../../node_modules/chai/lib/chai/utils/isNaN.js":
/*!*******************************************************************************!*\
  !*** /home/marcello/mdb/Code/olojs/node_modules/chai/lib/chai/utils/isNaN.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/*!\n * Chai - isNaN utility\n * Copyright(c) 2012-2015 Sakthipriyan Vairamani <thechargingvolcano@gmail.com>\n * MIT Licensed\n */\n\n/**\n * ### .isNaN(value)\n *\n * Checks if the given value is NaN or not.\n *\n *     utils.isNaN(NaN); // true\n *\n * @param {Value} The value which has to be checked if it is NaN\n * @name isNaN\n * @api private\n */\n\nfunction isNaN(value) {\n  // Refer http://www.ecma-international.org/ecma-262/6.0/#sec-isnan-number\n  // section's NOTE.\n  return value !== value;\n}\n\n// If ECMAScript 6's Number.isNaN is present, prefer that.\nmodule.exports = Number.isNaN || isNaN;\n\n\n//# sourceURL=webpack:////home/marcello/mdb/Code/olojs/node_modules/chai/lib/chai/utils/isNaN.js?");

/***/ }),

/***/ "../../node_modules/chai/lib/chai/utils/isProxyEnabled.js":
/*!****************************************************************************************!*\
  !*** /home/marcello/mdb/Code/olojs/node_modules/chai/lib/chai/utils/isProxyEnabled.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var config = __webpack_require__(/*! ../config */ \"../../node_modules/chai/lib/chai/config.js\");\n\n/*!\n * Chai - isProxyEnabled helper\n * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\n/**\n * ### .isProxyEnabled()\n *\n * Helper function to check if Chai's proxy protection feature is enabled. If\n * proxies are unsupported or disabled via the user's Chai config, then return\n * false. Otherwise, return true.\n *\n * @namespace Utils\n * @name isProxyEnabled\n */\n\nmodule.exports = function isProxyEnabled() {\n  return config.useProxy &&\n    typeof Proxy !== 'undefined' &&\n    typeof Reflect !== 'undefined';\n};\n\n\n//# sourceURL=webpack:////home/marcello/mdb/Code/olojs/node_modules/chai/lib/chai/utils/isProxyEnabled.js?");

/***/ }),

/***/ "../../node_modules/chai/lib/chai/utils/objDisplay.js":
/*!************************************************************************************!*\
  !*** /home/marcello/mdb/Code/olojs/node_modules/chai/lib/chai/utils/objDisplay.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/*!\n * Chai - flag utility\n * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\n/*!\n * Module dependencies\n */\n\nvar inspect = __webpack_require__(/*! ./inspect */ \"../../node_modules/chai/lib/chai/utils/inspect.js\");\nvar config = __webpack_require__(/*! ../config */ \"../../node_modules/chai/lib/chai/config.js\");\n\n/**\n * ### .objDisplay(object)\n *\n * Determines if an object or an array matches\n * criteria to be inspected in-line for error\n * messages or should be truncated.\n *\n * @param {Mixed} javascript object to inspect\n * @name objDisplay\n * @namespace Utils\n * @api public\n */\n\nmodule.exports = function objDisplay(obj) {\n  var str = inspect(obj)\n    , type = Object.prototype.toString.call(obj);\n\n  if (config.truncateThreshold && str.length >= config.truncateThreshold) {\n    if (type === '[object Function]') {\n      return !obj.name || obj.name === ''\n        ? '[Function]'\n        : '[Function: ' + obj.name + ']';\n    } else if (type === '[object Array]') {\n      return '[ Array(' + obj.length + ') ]';\n    } else if (type === '[object Object]') {\n      var keys = Object.keys(obj)\n        , kstr = keys.length > 2\n          ? keys.splice(0, 2).join(', ') + ', ...'\n          : keys.join(', ');\n      return '{ Object (' + kstr + ') }';\n    } else {\n      return str;\n    }\n  } else {\n    return str;\n  }\n};\n\n\n//# sourceURL=webpack:////home/marcello/mdb/Code/olojs/node_modules/chai/lib/chai/utils/objDisplay.js?");

/***/ }),

/***/ "../../node_modules/chai/lib/chai/utils/overwriteChainableMethod.js":
/*!**************************************************************************************************!*\
  !*** /home/marcello/mdb/Code/olojs/node_modules/chai/lib/chai/utils/overwriteChainableMethod.js ***!
  \**************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/*!\n * Chai - overwriteChainableMethod utility\n * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\nvar chai = __webpack_require__(/*! ../../chai */ \"../../node_modules/chai/lib/chai.js\");\nvar transferFlags = __webpack_require__(/*! ./transferFlags */ \"../../node_modules/chai/lib/chai/utils/transferFlags.js\");\n\n/**\n * ### .overwriteChainableMethod(ctx, name, method, chainingBehavior)\n *\n * Overwrites an already existing chainable method\n * and provides access to the previous function or\n * property.  Must return functions to be used for\n * name.\n *\n *     utils.overwriteChainableMethod(chai.Assertion.prototype, 'lengthOf',\n *       function (_super) {\n *       }\n *     , function (_super) {\n *       }\n *     );\n *\n * Can also be accessed directly from `chai.Assertion`.\n *\n *     chai.Assertion.overwriteChainableMethod('foo', fn, fn);\n *\n * Then can be used as any other assertion.\n *\n *     expect(myFoo).to.have.lengthOf(3);\n *     expect(myFoo).to.have.lengthOf.above(3);\n *\n * @param {Object} ctx object whose method / property is to be overwritten\n * @param {String} name of method / property to overwrite\n * @param {Function} method function that returns a function to be used for name\n * @param {Function} chainingBehavior function that returns a function to be used for property\n * @namespace Utils\n * @name overwriteChainableMethod\n * @api public\n */\n\nmodule.exports = function overwriteChainableMethod(ctx, name, method, chainingBehavior) {\n  var chainableBehavior = ctx.__methods[name];\n\n  var _chainingBehavior = chainableBehavior.chainingBehavior;\n  chainableBehavior.chainingBehavior = function overwritingChainableMethodGetter() {\n    var result = chainingBehavior(_chainingBehavior).call(this);\n    if (result !== undefined) {\n      return result;\n    }\n\n    var newAssertion = new chai.Assertion();\n    transferFlags(this, newAssertion);\n    return newAssertion;\n  };\n\n  var _method = chainableBehavior.method;\n  chainableBehavior.method = function overwritingChainableMethodWrapper() {\n    var result = method(_method).apply(this, arguments);\n    if (result !== undefined) {\n      return result;\n    }\n\n    var newAssertion = new chai.Assertion();\n    transferFlags(this, newAssertion);\n    return newAssertion;\n  };\n};\n\n\n//# sourceURL=webpack:////home/marcello/mdb/Code/olojs/node_modules/chai/lib/chai/utils/overwriteChainableMethod.js?");

/***/ }),

/***/ "../../node_modules/chai/lib/chai/utils/overwriteMethod.js":
/*!*****************************************************************************************!*\
  !*** /home/marcello/mdb/Code/olojs/node_modules/chai/lib/chai/utils/overwriteMethod.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/*!\n * Chai - overwriteMethod utility\n * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\nvar addLengthGuard = __webpack_require__(/*! ./addLengthGuard */ \"../../node_modules/chai/lib/chai/utils/addLengthGuard.js\");\nvar chai = __webpack_require__(/*! ../../chai */ \"../../node_modules/chai/lib/chai.js\");\nvar flag = __webpack_require__(/*! ./flag */ \"../../node_modules/chai/lib/chai/utils/flag.js\");\nvar proxify = __webpack_require__(/*! ./proxify */ \"../../node_modules/chai/lib/chai/utils/proxify.js\");\nvar transferFlags = __webpack_require__(/*! ./transferFlags */ \"../../node_modules/chai/lib/chai/utils/transferFlags.js\");\n\n/**\n * ### .overwriteMethod(ctx, name, fn)\n *\n * Overwrites an already existing method and provides\n * access to previous function. Must return function\n * to be used for name.\n *\n *     utils.overwriteMethod(chai.Assertion.prototype, 'equal', function (_super) {\n *       return function (str) {\n *         var obj = utils.flag(this, 'object');\n *         if (obj instanceof Foo) {\n *           new chai.Assertion(obj.value).to.equal(str);\n *         } else {\n *           _super.apply(this, arguments);\n *         }\n *       }\n *     });\n *\n * Can also be accessed directly from `chai.Assertion`.\n *\n *     chai.Assertion.overwriteMethod('foo', fn);\n *\n * Then can be used as any other assertion.\n *\n *     expect(myFoo).to.equal('bar');\n *\n * @param {Object} ctx object whose method is to be overwritten\n * @param {String} name of method to overwrite\n * @param {Function} method function that returns a function to be used for name\n * @namespace Utils\n * @name overwriteMethod\n * @api public\n */\n\nmodule.exports = function overwriteMethod(ctx, name, method) {\n  var _method = ctx[name]\n    , _super = function () {\n      throw new Error(name + ' is not a function');\n    };\n\n  if (_method && 'function' === typeof _method)\n    _super = _method;\n\n  var overwritingMethodWrapper = function () {\n    // Setting the `ssfi` flag to `overwritingMethodWrapper` causes this\n    // function to be the starting point for removing implementation frames from\n    // the stack trace of a failed assertion.\n    //\n    // However, we only want to use this function as the starting point if the\n    // `lockSsfi` flag isn't set.\n    //\n    // If the `lockSsfi` flag is set, then either this assertion has been\n    // overwritten by another assertion, or this assertion is being invoked from\n    // inside of another assertion. In the first case, the `ssfi` flag has\n    // already been set by the overwriting assertion. In the second case, the\n    // `ssfi` flag has already been set by the outer assertion.\n    if (!flag(this, 'lockSsfi')) {\n      flag(this, 'ssfi', overwritingMethodWrapper);\n    }\n\n    // Setting the `lockSsfi` flag to `true` prevents the overwritten assertion\n    // from changing the `ssfi` flag. By this point, the `ssfi` flag is already\n    // set to the correct starting point for this assertion.\n    var origLockSsfi = flag(this, 'lockSsfi');\n    flag(this, 'lockSsfi', true);\n    var result = method(_super).apply(this, arguments);\n    flag(this, 'lockSsfi', origLockSsfi);\n\n    if (result !== undefined) {\n      return result;\n    }\n\n    var newAssertion = new chai.Assertion();\n    transferFlags(this, newAssertion);\n    return newAssertion;\n  }\n\n  addLengthGuard(overwritingMethodWrapper, name, false);\n  ctx[name] = proxify(overwritingMethodWrapper, name);\n};\n\n\n//# sourceURL=webpack:////home/marcello/mdb/Code/olojs/node_modules/chai/lib/chai/utils/overwriteMethod.js?");

/***/ }),

/***/ "../../node_modules/chai/lib/chai/utils/overwriteProperty.js":
/*!*******************************************************************************************!*\
  !*** /home/marcello/mdb/Code/olojs/node_modules/chai/lib/chai/utils/overwriteProperty.js ***!
  \*******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/*!\n * Chai - overwriteProperty utility\n * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\nvar chai = __webpack_require__(/*! ../../chai */ \"../../node_modules/chai/lib/chai.js\");\nvar flag = __webpack_require__(/*! ./flag */ \"../../node_modules/chai/lib/chai/utils/flag.js\");\nvar isProxyEnabled = __webpack_require__(/*! ./isProxyEnabled */ \"../../node_modules/chai/lib/chai/utils/isProxyEnabled.js\");\nvar transferFlags = __webpack_require__(/*! ./transferFlags */ \"../../node_modules/chai/lib/chai/utils/transferFlags.js\");\n\n/**\n * ### .overwriteProperty(ctx, name, fn)\n *\n * Overwrites an already existing property getter and provides\n * access to previous value. Must return function to use as getter.\n *\n *     utils.overwriteProperty(chai.Assertion.prototype, 'ok', function (_super) {\n *       return function () {\n *         var obj = utils.flag(this, 'object');\n *         if (obj instanceof Foo) {\n *           new chai.Assertion(obj.name).to.equal('bar');\n *         } else {\n *           _super.call(this);\n *         }\n *       }\n *     });\n *\n *\n * Can also be accessed directly from `chai.Assertion`.\n *\n *     chai.Assertion.overwriteProperty('foo', fn);\n *\n * Then can be used as any other assertion.\n *\n *     expect(myFoo).to.be.ok;\n *\n * @param {Object} ctx object whose property is to be overwritten\n * @param {String} name of property to overwrite\n * @param {Function} getter function that returns a getter function to be used for name\n * @namespace Utils\n * @name overwriteProperty\n * @api public\n */\n\nmodule.exports = function overwriteProperty(ctx, name, getter) {\n  var _get = Object.getOwnPropertyDescriptor(ctx, name)\n    , _super = function () {};\n\n  if (_get && 'function' === typeof _get.get)\n    _super = _get.get\n\n  Object.defineProperty(ctx, name,\n    { get: function overwritingPropertyGetter() {\n        // Setting the `ssfi` flag to `overwritingPropertyGetter` causes this\n        // function to be the starting point for removing implementation frames\n        // from the stack trace of a failed assertion.\n        //\n        // However, we only want to use this function as the starting point if\n        // the `lockSsfi` flag isn't set and proxy protection is disabled.\n        //\n        // If the `lockSsfi` flag is set, then either this assertion has been\n        // overwritten by another assertion, or this assertion is being invoked\n        // from inside of another assertion. In the first case, the `ssfi` flag\n        // has already been set by the overwriting assertion. In the second\n        // case, the `ssfi` flag has already been set by the outer assertion.\n        //\n        // If proxy protection is enabled, then the `ssfi` flag has already been\n        // set by the proxy getter.\n        if (!isProxyEnabled() && !flag(this, 'lockSsfi')) {\n          flag(this, 'ssfi', overwritingPropertyGetter);\n        }\n\n        // Setting the `lockSsfi` flag to `true` prevents the overwritten\n        // assertion from changing the `ssfi` flag. By this point, the `ssfi`\n        // flag is already set to the correct starting point for this assertion.\n        var origLockSsfi = flag(this, 'lockSsfi');\n        flag(this, 'lockSsfi', true);\n        var result = getter(_super).call(this);\n        flag(this, 'lockSsfi', origLockSsfi);\n\n        if (result !== undefined) {\n          return result;\n        }\n\n        var newAssertion = new chai.Assertion();\n        transferFlags(this, newAssertion);\n        return newAssertion;\n      }\n    , configurable: true\n  });\n};\n\n\n//# sourceURL=webpack:////home/marcello/mdb/Code/olojs/node_modules/chai/lib/chai/utils/overwriteProperty.js?");

/***/ }),

/***/ "../../node_modules/chai/lib/chai/utils/proxify.js":
/*!*********************************************************************************!*\
  !*** /home/marcello/mdb/Code/olojs/node_modules/chai/lib/chai/utils/proxify.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var config = __webpack_require__(/*! ../config */ \"../../node_modules/chai/lib/chai/config.js\");\nvar flag = __webpack_require__(/*! ./flag */ \"../../node_modules/chai/lib/chai/utils/flag.js\");\nvar getProperties = __webpack_require__(/*! ./getProperties */ \"../../node_modules/chai/lib/chai/utils/getProperties.js\");\nvar isProxyEnabled = __webpack_require__(/*! ./isProxyEnabled */ \"../../node_modules/chai/lib/chai/utils/isProxyEnabled.js\");\n\n/*!\n * Chai - proxify utility\n * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\n/**\n * ### .proxify(object)\n *\n * Return a proxy of given object that throws an error when a non-existent\n * property is read. By default, the root cause is assumed to be a misspelled\n * property, and thus an attempt is made to offer a reasonable suggestion from\n * the list of existing properties. However, if a nonChainableMethodName is\n * provided, then the root cause is instead a failure to invoke a non-chainable\n * method prior to reading the non-existent property.\n *\n * If proxies are unsupported or disabled via the user's Chai config, then\n * return object without modification.\n *\n * @param {Object} obj\n * @param {String} nonChainableMethodName\n * @namespace Utils\n * @name proxify\n */\n\nvar builtins = ['__flags', '__methods', '_obj', 'assert'];\n\nmodule.exports = function proxify(obj, nonChainableMethodName) {\n  if (!isProxyEnabled()) return obj;\n\n  return new Proxy(obj, {\n    get: function proxyGetter(target, property) {\n      // This check is here because we should not throw errors on Symbol properties\n      // such as `Symbol.toStringTag`.\n      // The values for which an error should be thrown can be configured using\n      // the `config.proxyExcludedKeys` setting.\n      if (typeof property === 'string' &&\n          config.proxyExcludedKeys.indexOf(property) === -1 &&\n          !Reflect.has(target, property)) {\n        // Special message for invalid property access of non-chainable methods.\n        if (nonChainableMethodName) {\n          throw Error('Invalid Chai property: ' + nonChainableMethodName + '.' +\n            property + '. See docs for proper usage of \"' +\n            nonChainableMethodName + '\".');\n        }\n\n        // If the property is reasonably close to an existing Chai property,\n        // suggest that property to the user. Only suggest properties with a\n        // distance less than 4.\n        var suggestion = null;\n        var suggestionDistance = 4;\n        getProperties(target).forEach(function(prop) {\n          if (\n            !Object.prototype.hasOwnProperty(prop) &&\n            builtins.indexOf(prop) === -1\n          ) {\n            var dist = stringDistanceCapped(\n              property,\n              prop,\n              suggestionDistance\n            );\n            if (dist < suggestionDistance) {\n              suggestion = prop;\n              suggestionDistance = dist;\n            }\n          }\n        });\n\n        if (suggestion !== null) {\n          throw Error('Invalid Chai property: ' + property +\n            '. Did you mean \"' + suggestion + '\"?');\n        } else {\n          throw Error('Invalid Chai property: ' + property);\n        }\n      }\n\n      // Use this proxy getter as the starting point for removing implementation\n      // frames from the stack trace of a failed assertion. For property\n      // assertions, this prevents the proxy getter from showing up in the stack\n      // trace since it's invoked before the property getter. For method and\n      // chainable method assertions, this flag will end up getting changed to\n      // the method wrapper, which is good since this frame will no longer be in\n      // the stack once the method is invoked. Note that Chai builtin assertion\n      // properties such as `__flags` are skipped since this is only meant to\n      // capture the starting point of an assertion. This step is also skipped\n      // if the `lockSsfi` flag is set, thus indicating that this assertion is\n      // being called from within another assertion. In that case, the `ssfi`\n      // flag is already set to the outer assertion's starting point.\n      if (builtins.indexOf(property) === -1 && !flag(target, 'lockSsfi')) {\n        flag(target, 'ssfi', proxyGetter);\n      }\n\n      return Reflect.get(target, property);\n    }\n  });\n};\n\n/**\n * # stringDistanceCapped(strA, strB, cap)\n * Return the Levenshtein distance between two strings, but no more than cap.\n * @param {string} strA\n * @param {string} strB\n * @param {number} number\n * @return {number} min(string distance between strA and strB, cap)\n * @api private\n */\n\nfunction stringDistanceCapped(strA, strB, cap) {\n  if (Math.abs(strA.length - strB.length) >= cap) {\n    return cap;\n  }\n\n  var memo = [];\n  // `memo` is a two-dimensional array containing distances.\n  // memo[i][j] is the distance between strA.slice(0, i) and\n  // strB.slice(0, j).\n  for (var i = 0; i <= strA.length; i++) {\n    memo[i] = Array(strB.length + 1).fill(0);\n    memo[i][0] = i;\n  }\n  for (var j = 0; j < strB.length; j++) {\n    memo[0][j] = j;\n  }\n\n  for (var i = 1; i <= strA.length; i++) {\n    var ch = strA.charCodeAt(i - 1);\n    for (var j = 1; j <= strB.length; j++) {\n      if (Math.abs(i - j) >= cap) {\n        memo[i][j] = cap;\n        continue;\n      }\n      memo[i][j] = Math.min(\n        memo[i - 1][j] + 1,\n        memo[i][j - 1] + 1,\n        memo[i - 1][j - 1] +\n          (ch === strB.charCodeAt(j - 1) ? 0 : 1)\n      );\n    }\n  }\n\n  return memo[strA.length][strB.length];\n}\n\n\n//# sourceURL=webpack:////home/marcello/mdb/Code/olojs/node_modules/chai/lib/chai/utils/proxify.js?");

/***/ }),

/***/ "../../node_modules/chai/lib/chai/utils/test.js":
/*!******************************************************************************!*\
  !*** /home/marcello/mdb/Code/olojs/node_modules/chai/lib/chai/utils/test.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/*!\n * Chai - test utility\n * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\n/*!\n * Module dependencies\n */\n\nvar flag = __webpack_require__(/*! ./flag */ \"../../node_modules/chai/lib/chai/utils/flag.js\");\n\n/**\n * ### .test(object, expression)\n *\n * Test and object for expression.\n *\n * @param {Object} object (constructed Assertion)\n * @param {Arguments} chai.Assertion.prototype.assert arguments\n * @namespace Utils\n * @name test\n */\n\nmodule.exports = function test(obj, args) {\n  var negate = flag(obj, 'negate')\n    , expr = args[0];\n  return negate ? !expr : expr;\n};\n\n\n//# sourceURL=webpack:////home/marcello/mdb/Code/olojs/node_modules/chai/lib/chai/utils/test.js?");

/***/ }),

/***/ "../../node_modules/chai/lib/chai/utils/transferFlags.js":
/*!***************************************************************************************!*\
  !*** /home/marcello/mdb/Code/olojs/node_modules/chai/lib/chai/utils/transferFlags.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/*!\n * Chai - transferFlags utility\n * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\n/**\n * ### .transferFlags(assertion, object, includeAll = true)\n *\n * Transfer all the flags for `assertion` to `object`. If\n * `includeAll` is set to `false`, then the base Chai\n * assertion flags (namely `object`, `ssfi`, `lockSsfi`,\n * and `message`) will not be transferred.\n *\n *\n *     var newAssertion = new Assertion();\n *     utils.transferFlags(assertion, newAssertion);\n *\n *     var anotherAssertion = new Assertion(myObj);\n *     utils.transferFlags(assertion, anotherAssertion, false);\n *\n * @param {Assertion} assertion the assertion to transfer the flags from\n * @param {Object} object the object to transfer the flags to; usually a new assertion\n * @param {Boolean} includeAll\n * @namespace Utils\n * @name transferFlags\n * @api private\n */\n\nmodule.exports = function transferFlags(assertion, object, includeAll) {\n  var flags = assertion.__flags || (assertion.__flags = Object.create(null));\n\n  if (!object.__flags) {\n    object.__flags = Object.create(null);\n  }\n\n  includeAll = arguments.length === 3 ? includeAll : true;\n\n  for (var flag in flags) {\n    if (includeAll ||\n        (flag !== 'object' && flag !== 'ssfi' && flag !== 'lockSsfi' && flag != 'message')) {\n      object.__flags[flag] = flags[flag];\n    }\n  }\n};\n\n\n//# sourceURL=webpack:////home/marcello/mdb/Code/olojs/node_modules/chai/lib/chai/utils/transferFlags.js?");

/***/ }),

/***/ "../../node_modules/check-error/index.js":
/*!***********************************************************************!*\
  !*** /home/marcello/mdb/Code/olojs/node_modules/check-error/index.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/* !\n * Chai - checkError utility\n * Copyright(c) 2012-2016 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\n/**\n * ### .checkError\n *\n * Checks that an error conforms to a given set of criteria and/or retrieves information about it.\n *\n * @api public\n */\n\n/**\n * ### .compatibleInstance(thrown, errorLike)\n *\n * Checks if two instances are compatible (strict equal).\n * Returns false if errorLike is not an instance of Error, because instances\n * can only be compatible if they're both error instances.\n *\n * @name compatibleInstance\n * @param {Error} thrown error\n * @param {Error|ErrorConstructor} errorLike object to compare against\n * @namespace Utils\n * @api public\n */\n\nfunction compatibleInstance(thrown, errorLike) {\n  return errorLike instanceof Error && thrown === errorLike;\n}\n\n/**\n * ### .compatibleConstructor(thrown, errorLike)\n *\n * Checks if two constructors are compatible.\n * This function can receive either an error constructor or\n * an error instance as the `errorLike` argument.\n * Constructors are compatible if they're the same or if one is\n * an instance of another.\n *\n * @name compatibleConstructor\n * @param {Error} thrown error\n * @param {Error|ErrorConstructor} errorLike object to compare against\n * @namespace Utils\n * @api public\n */\n\nfunction compatibleConstructor(thrown, errorLike) {\n  if (errorLike instanceof Error) {\n    // If `errorLike` is an instance of any error we compare their constructors\n    return thrown.constructor === errorLike.constructor || thrown instanceof errorLike.constructor;\n  } else if (errorLike.prototype instanceof Error || errorLike === Error) {\n    // If `errorLike` is a constructor that inherits from Error, we compare `thrown` to `errorLike` directly\n    return thrown.constructor === errorLike || thrown instanceof errorLike;\n  }\n\n  return false;\n}\n\n/**\n * ### .compatibleMessage(thrown, errMatcher)\n *\n * Checks if an error's message is compatible with a matcher (String or RegExp).\n * If the message contains the String or passes the RegExp test,\n * it is considered compatible.\n *\n * @name compatibleMessage\n * @param {Error} thrown error\n * @param {String|RegExp} errMatcher to look for into the message\n * @namespace Utils\n * @api public\n */\n\nfunction compatibleMessage(thrown, errMatcher) {\n  var comparisonString = typeof thrown === 'string' ? thrown : thrown.message;\n  if (errMatcher instanceof RegExp) {\n    return errMatcher.test(comparisonString);\n  } else if (typeof errMatcher === 'string') {\n    return comparisonString.indexOf(errMatcher) !== -1; // eslint-disable-line no-magic-numbers\n  }\n\n  return false;\n}\n\n/**\n * ### .getFunctionName(constructorFn)\n *\n * Returns the name of a function.\n * This also includes a polyfill function if `constructorFn.name` is not defined.\n *\n * @name getFunctionName\n * @param {Function} constructorFn\n * @namespace Utils\n * @api private\n */\n\nvar functionNameMatch = /\\s*function(?:\\s|\\s*\\/\\*[^(?:*\\/)]+\\*\\/\\s*)*([^\\(\\/]+)/;\nfunction getFunctionName(constructorFn) {\n  var name = '';\n  if (typeof constructorFn.name === 'undefined') {\n    // Here we run a polyfill if constructorFn.name is not defined\n    var match = String(constructorFn).match(functionNameMatch);\n    if (match) {\n      name = match[1];\n    }\n  } else {\n    name = constructorFn.name;\n  }\n\n  return name;\n}\n\n/**\n * ### .getConstructorName(errorLike)\n *\n * Gets the constructor name for an Error instance or constructor itself.\n *\n * @name getConstructorName\n * @param {Error|ErrorConstructor} errorLike\n * @namespace Utils\n * @api public\n */\n\nfunction getConstructorName(errorLike) {\n  var constructorName = errorLike;\n  if (errorLike instanceof Error) {\n    constructorName = getFunctionName(errorLike.constructor);\n  } else if (typeof errorLike === 'function') {\n    // If `err` is not an instance of Error it is an error constructor itself or another function.\n    // If we've got a common function we get its name, otherwise we may need to create a new instance\n    // of the error just in case it's a poorly-constructed error. Please see chaijs/chai/issues/45 to know more.\n    constructorName = getFunctionName(errorLike).trim() ||\n        getFunctionName(new errorLike()); // eslint-disable-line new-cap\n  }\n\n  return constructorName;\n}\n\n/**\n * ### .getMessage(errorLike)\n *\n * Gets the error message from an error.\n * If `err` is a String itself, we return it.\n * If the error has no message, we return an empty string.\n *\n * @name getMessage\n * @param {Error|String} errorLike\n * @namespace Utils\n * @api public\n */\n\nfunction getMessage(errorLike) {\n  var msg = '';\n  if (errorLike && errorLike.message) {\n    msg = errorLike.message;\n  } else if (typeof errorLike === 'string') {\n    msg = errorLike;\n  }\n\n  return msg;\n}\n\nmodule.exports = {\n  compatibleInstance: compatibleInstance,\n  compatibleConstructor: compatibleConstructor,\n  compatibleMessage: compatibleMessage,\n  getMessage: getMessage,\n  getConstructorName: getConstructorName,\n};\n\n\n//# sourceURL=webpack:////home/marcello/mdb/Code/olojs/node_modules/check-error/index.js?");

/***/ }),

/***/ "../../node_modules/deep-eql/index.js":
/*!********************************************************************!*\
  !*** /home/marcello/mdb/Code/olojs/node_modules/deep-eql/index.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/* globals Symbol: false, Uint8Array: false, WeakMap: false */\n/*!\n * deep-eql\n * Copyright(c) 2013 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\nvar type = __webpack_require__(/*! type-detect */ \"../../node_modules/type-detect/type-detect.js\");\nfunction FakeMap() {\n  this._key = 'chai/deep-eql__' + Math.random() + Date.now();\n}\n\nFakeMap.prototype = {\n  get: function getMap(key) {\n    return key[this._key];\n  },\n  set: function setMap(key, value) {\n    if (Object.isExtensible(key)) {\n      Object.defineProperty(key, this._key, {\n        value: value,\n        configurable: true,\n      });\n    }\n  },\n};\n\nvar MemoizeMap = typeof WeakMap === 'function' ? WeakMap : FakeMap;\n/*!\n * Check to see if the MemoizeMap has recorded a result of the two operands\n *\n * @param {Mixed} leftHandOperand\n * @param {Mixed} rightHandOperand\n * @param {MemoizeMap} memoizeMap\n * @returns {Boolean|null} result\n*/\nfunction memoizeCompare(leftHandOperand, rightHandOperand, memoizeMap) {\n  // Technically, WeakMap keys can *only* be objects, not primitives.\n  if (!memoizeMap || isPrimitive(leftHandOperand) || isPrimitive(rightHandOperand)) {\n    return null;\n  }\n  var leftHandMap = memoizeMap.get(leftHandOperand);\n  if (leftHandMap) {\n    var result = leftHandMap.get(rightHandOperand);\n    if (typeof result === 'boolean') {\n      return result;\n    }\n  }\n  return null;\n}\n\n/*!\n * Set the result of the equality into the MemoizeMap\n *\n * @param {Mixed} leftHandOperand\n * @param {Mixed} rightHandOperand\n * @param {MemoizeMap} memoizeMap\n * @param {Boolean} result\n*/\nfunction memoizeSet(leftHandOperand, rightHandOperand, memoizeMap, result) {\n  // Technically, WeakMap keys can *only* be objects, not primitives.\n  if (!memoizeMap || isPrimitive(leftHandOperand) || isPrimitive(rightHandOperand)) {\n    return;\n  }\n  var leftHandMap = memoizeMap.get(leftHandOperand);\n  if (leftHandMap) {\n    leftHandMap.set(rightHandOperand, result);\n  } else {\n    leftHandMap = new MemoizeMap();\n    leftHandMap.set(rightHandOperand, result);\n    memoizeMap.set(leftHandOperand, leftHandMap);\n  }\n}\n\n/*!\n * Primary Export\n */\n\nmodule.exports = deepEqual;\nmodule.exports.MemoizeMap = MemoizeMap;\n\n/**\n * Assert deeply nested sameValue equality between two objects of any type.\n *\n * @param {Mixed} leftHandOperand\n * @param {Mixed} rightHandOperand\n * @param {Object} [options] (optional) Additional options\n * @param {Array} [options.comparator] (optional) Override default algorithm, determining custom equality.\n * @param {Array} [options.memoize] (optional) Provide a custom memoization object which will cache the results of\n    complex objects for a speed boost. By passing `false` you can disable memoization, but this will cause circular\n    references to blow the stack.\n * @return {Boolean} equal match\n */\nfunction deepEqual(leftHandOperand, rightHandOperand, options) {\n  // If we have a comparator, we can't assume anything; so bail to its check first.\n  if (options && options.comparator) {\n    return extensiveDeepEqual(leftHandOperand, rightHandOperand, options);\n  }\n\n  var simpleResult = simpleEqual(leftHandOperand, rightHandOperand);\n  if (simpleResult !== null) {\n    return simpleResult;\n  }\n\n  // Deeper comparisons are pushed through to a larger function\n  return extensiveDeepEqual(leftHandOperand, rightHandOperand, options);\n}\n\n/**\n * Many comparisons can be canceled out early via simple equality or primitive checks.\n * @param {Mixed} leftHandOperand\n * @param {Mixed} rightHandOperand\n * @return {Boolean|null} equal match\n */\nfunction simpleEqual(leftHandOperand, rightHandOperand) {\n  // Equal references (except for Numbers) can be returned early\n  if (leftHandOperand === rightHandOperand) {\n    // Handle +-0 cases\n    return leftHandOperand !== 0 || 1 / leftHandOperand === 1 / rightHandOperand;\n  }\n\n  // handle NaN cases\n  if (\n    leftHandOperand !== leftHandOperand && // eslint-disable-line no-self-compare\n    rightHandOperand !== rightHandOperand // eslint-disable-line no-self-compare\n  ) {\n    return true;\n  }\n\n  // Anything that is not an 'object', i.e. symbols, functions, booleans, numbers,\n  // strings, and undefined, can be compared by reference.\n  if (isPrimitive(leftHandOperand) || isPrimitive(rightHandOperand)) {\n    // Easy out b/c it would have passed the first equality check\n    return false;\n  }\n  return null;\n}\n\n/*!\n * The main logic of the `deepEqual` function.\n *\n * @param {Mixed} leftHandOperand\n * @param {Mixed} rightHandOperand\n * @param {Object} [options] (optional) Additional options\n * @param {Array} [options.comparator] (optional) Override default algorithm, determining custom equality.\n * @param {Array} [options.memoize] (optional) Provide a custom memoization object which will cache the results of\n    complex objects for a speed boost. By passing `false` you can disable memoization, but this will cause circular\n    references to blow the stack.\n * @return {Boolean} equal match\n*/\nfunction extensiveDeepEqual(leftHandOperand, rightHandOperand, options) {\n  options = options || {};\n  options.memoize = options.memoize === false ? false : options.memoize || new MemoizeMap();\n  var comparator = options && options.comparator;\n\n  // Check if a memoized result exists.\n  var memoizeResultLeft = memoizeCompare(leftHandOperand, rightHandOperand, options.memoize);\n  if (memoizeResultLeft !== null) {\n    return memoizeResultLeft;\n  }\n  var memoizeResultRight = memoizeCompare(rightHandOperand, leftHandOperand, options.memoize);\n  if (memoizeResultRight !== null) {\n    return memoizeResultRight;\n  }\n\n  // If a comparator is present, use it.\n  if (comparator) {\n    var comparatorResult = comparator(leftHandOperand, rightHandOperand);\n    // Comparators may return null, in which case we want to go back to default behavior.\n    if (comparatorResult === false || comparatorResult === true) {\n      memoizeSet(leftHandOperand, rightHandOperand, options.memoize, comparatorResult);\n      return comparatorResult;\n    }\n    // To allow comparators to override *any* behavior, we ran them first. Since it didn't decide\n    // what to do, we need to make sure to return the basic tests first before we move on.\n    var simpleResult = simpleEqual(leftHandOperand, rightHandOperand);\n    if (simpleResult !== null) {\n      // Don't memoize this, it takes longer to set/retrieve than to just compare.\n      return simpleResult;\n    }\n  }\n\n  var leftHandType = type(leftHandOperand);\n  if (leftHandType !== type(rightHandOperand)) {\n    memoizeSet(leftHandOperand, rightHandOperand, options.memoize, false);\n    return false;\n  }\n\n  // Temporarily set the operands in the memoize object to prevent blowing the stack\n  memoizeSet(leftHandOperand, rightHandOperand, options.memoize, true);\n\n  var result = extensiveDeepEqualByType(leftHandOperand, rightHandOperand, leftHandType, options);\n  memoizeSet(leftHandOperand, rightHandOperand, options.memoize, result);\n  return result;\n}\n\nfunction extensiveDeepEqualByType(leftHandOperand, rightHandOperand, leftHandType, options) {\n  switch (leftHandType) {\n    case 'String':\n    case 'Number':\n    case 'Boolean':\n    case 'Date':\n      // If these types are their instance types (e.g. `new Number`) then re-deepEqual against their values\n      return deepEqual(leftHandOperand.valueOf(), rightHandOperand.valueOf());\n    case 'Promise':\n    case 'Symbol':\n    case 'function':\n    case 'WeakMap':\n    case 'WeakSet':\n    case 'Error':\n      return leftHandOperand === rightHandOperand;\n    case 'Arguments':\n    case 'Int8Array':\n    case 'Uint8Array':\n    case 'Uint8ClampedArray':\n    case 'Int16Array':\n    case 'Uint16Array':\n    case 'Int32Array':\n    case 'Uint32Array':\n    case 'Float32Array':\n    case 'Float64Array':\n    case 'Array':\n      return iterableEqual(leftHandOperand, rightHandOperand, options);\n    case 'RegExp':\n      return regexpEqual(leftHandOperand, rightHandOperand);\n    case 'Generator':\n      return generatorEqual(leftHandOperand, rightHandOperand, options);\n    case 'DataView':\n      return iterableEqual(new Uint8Array(leftHandOperand.buffer), new Uint8Array(rightHandOperand.buffer), options);\n    case 'ArrayBuffer':\n      return iterableEqual(new Uint8Array(leftHandOperand), new Uint8Array(rightHandOperand), options);\n    case 'Set':\n      return entriesEqual(leftHandOperand, rightHandOperand, options);\n    case 'Map':\n      return entriesEqual(leftHandOperand, rightHandOperand, options);\n    default:\n      return objectEqual(leftHandOperand, rightHandOperand, options);\n  }\n}\n\n/*!\n * Compare two Regular Expressions for equality.\n *\n * @param {RegExp} leftHandOperand\n * @param {RegExp} rightHandOperand\n * @return {Boolean} result\n */\n\nfunction regexpEqual(leftHandOperand, rightHandOperand) {\n  return leftHandOperand.toString() === rightHandOperand.toString();\n}\n\n/*!\n * Compare two Sets/Maps for equality. Faster than other equality functions.\n *\n * @param {Set} leftHandOperand\n * @param {Set} rightHandOperand\n * @param {Object} [options] (Optional)\n * @return {Boolean} result\n */\n\nfunction entriesEqual(leftHandOperand, rightHandOperand, options) {\n  // IE11 doesn't support Set#entries or Set#@@iterator, so we need manually populate using Set#forEach\n  if (leftHandOperand.size !== rightHandOperand.size) {\n    return false;\n  }\n  if (leftHandOperand.size === 0) {\n    return true;\n  }\n  var leftHandItems = [];\n  var rightHandItems = [];\n  leftHandOperand.forEach(function gatherEntries(key, value) {\n    leftHandItems.push([ key, value ]);\n  });\n  rightHandOperand.forEach(function gatherEntries(key, value) {\n    rightHandItems.push([ key, value ]);\n  });\n  return iterableEqual(leftHandItems.sort(), rightHandItems.sort(), options);\n}\n\n/*!\n * Simple equality for flat iterable objects such as Arrays, TypedArrays or Node.js buffers.\n *\n * @param {Iterable} leftHandOperand\n * @param {Iterable} rightHandOperand\n * @param {Object} [options] (Optional)\n * @return {Boolean} result\n */\n\nfunction iterableEqual(leftHandOperand, rightHandOperand, options) {\n  var length = leftHandOperand.length;\n  if (length !== rightHandOperand.length) {\n    return false;\n  }\n  if (length === 0) {\n    return true;\n  }\n  var index = -1;\n  while (++index < length) {\n    if (deepEqual(leftHandOperand[index], rightHandOperand[index], options) === false) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/*!\n * Simple equality for generator objects such as those returned by generator functions.\n *\n * @param {Iterable} leftHandOperand\n * @param {Iterable} rightHandOperand\n * @param {Object} [options] (Optional)\n * @return {Boolean} result\n */\n\nfunction generatorEqual(leftHandOperand, rightHandOperand, options) {\n  return iterableEqual(getGeneratorEntries(leftHandOperand), getGeneratorEntries(rightHandOperand), options);\n}\n\n/*!\n * Determine if the given object has an @@iterator function.\n *\n * @param {Object} target\n * @return {Boolean} `true` if the object has an @@iterator function.\n */\nfunction hasIteratorFunction(target) {\n  return typeof Symbol !== 'undefined' &&\n    typeof target === 'object' &&\n    typeof Symbol.iterator !== 'undefined' &&\n    typeof target[Symbol.iterator] === 'function';\n}\n\n/*!\n * Gets all iterator entries from the given Object. If the Object has no @@iterator function, returns an empty array.\n * This will consume the iterator - which could have side effects depending on the @@iterator implementation.\n *\n * @param {Object} target\n * @returns {Array} an array of entries from the @@iterator function\n */\nfunction getIteratorEntries(target) {\n  if (hasIteratorFunction(target)) {\n    try {\n      return getGeneratorEntries(target[Symbol.iterator]());\n    } catch (iteratorError) {\n      return [];\n    }\n  }\n  return [];\n}\n\n/*!\n * Gets all entries from a Generator. This will consume the generator - which could have side effects.\n *\n * @param {Generator} target\n * @returns {Array} an array of entries from the Generator.\n */\nfunction getGeneratorEntries(generator) {\n  var generatorResult = generator.next();\n  var accumulator = [ generatorResult.value ];\n  while (generatorResult.done === false) {\n    generatorResult = generator.next();\n    accumulator.push(generatorResult.value);\n  }\n  return accumulator;\n}\n\n/*!\n * Gets all own and inherited enumerable keys from a target.\n *\n * @param {Object} target\n * @returns {Array} an array of own and inherited enumerable keys from the target.\n */\nfunction getEnumerableKeys(target) {\n  var keys = [];\n  for (var key in target) {\n    keys.push(key);\n  }\n  return keys;\n}\n\n/*!\n * Determines if two objects have matching values, given a set of keys. Defers to deepEqual for the equality check of\n * each key. If any value of the given key is not equal, the function will return false (early).\n *\n * @param {Mixed} leftHandOperand\n * @param {Mixed} rightHandOperand\n * @param {Array} keys An array of keys to compare the values of leftHandOperand and rightHandOperand against\n * @param {Object} [options] (Optional)\n * @return {Boolean} result\n */\nfunction keysEqual(leftHandOperand, rightHandOperand, keys, options) {\n  var length = keys.length;\n  if (length === 0) {\n    return true;\n  }\n  for (var i = 0; i < length; i += 1) {\n    if (deepEqual(leftHandOperand[keys[i]], rightHandOperand[keys[i]], options) === false) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/*!\n * Recursively check the equality of two Objects. Once basic sameness has been established it will defer to `deepEqual`\n * for each enumerable key in the object.\n *\n * @param {Mixed} leftHandOperand\n * @param {Mixed} rightHandOperand\n * @param {Object} [options] (Optional)\n * @return {Boolean} result\n */\n\nfunction objectEqual(leftHandOperand, rightHandOperand, options) {\n  var leftHandKeys = getEnumerableKeys(leftHandOperand);\n  var rightHandKeys = getEnumerableKeys(rightHandOperand);\n  if (leftHandKeys.length && leftHandKeys.length === rightHandKeys.length) {\n    leftHandKeys.sort();\n    rightHandKeys.sort();\n    if (iterableEqual(leftHandKeys, rightHandKeys) === false) {\n      return false;\n    }\n    return keysEqual(leftHandOperand, rightHandOperand, leftHandKeys, options);\n  }\n\n  var leftHandEntries = getIteratorEntries(leftHandOperand);\n  var rightHandEntries = getIteratorEntries(rightHandOperand);\n  if (leftHandEntries.length && leftHandEntries.length === rightHandEntries.length) {\n    leftHandEntries.sort();\n    rightHandEntries.sort();\n    return iterableEqual(leftHandEntries, rightHandEntries, options);\n  }\n\n  if (leftHandKeys.length === 0 &&\n      leftHandEntries.length === 0 &&\n      rightHandKeys.length === 0 &&\n      rightHandEntries.length === 0) {\n    return true;\n  }\n\n  return false;\n}\n\n/*!\n * Returns true if the argument is a primitive.\n *\n * This intentionally returns true for all objects that can be compared by reference,\n * including functions and symbols.\n *\n * @param {Mixed} value\n * @return {Boolean} result\n */\nfunction isPrimitive(value) {\n  return value === null || typeof value !== 'object';\n}\n\n\n//# sourceURL=webpack:////home/marcello/mdb/Code/olojs/node_modules/deep-eql/index.js?");

/***/ }),

/***/ "../../node_modules/dompurify/dist/purify.js":
/*!***************************************************************************!*\
  !*** /home/marcello/mdb/Code/olojs/node_modules/dompurify/dist/purify.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/*! @license DOMPurify | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/2.2.2/LICENSE */\n\n(function (global, factory) {\n   true ? module.exports = factory() :\n  undefined;\n}(this, function () { 'use strict';\n\n  function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\n  var hasOwnProperty = Object.hasOwnProperty,\n      setPrototypeOf = Object.setPrototypeOf,\n      isFrozen = Object.isFrozen,\n      getPrototypeOf = Object.getPrototypeOf,\n      getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\n  var freeze = Object.freeze,\n      seal = Object.seal,\n      create = Object.create; // eslint-disable-line import/no-mutable-exports\n\n  var _ref = typeof Reflect !== 'undefined' && Reflect,\n      apply = _ref.apply,\n      construct = _ref.construct;\n\n  if (!apply) {\n    apply = function apply(fun, thisValue, args) {\n      return fun.apply(thisValue, args);\n    };\n  }\n\n  if (!freeze) {\n    freeze = function freeze(x) {\n      return x;\n    };\n  }\n\n  if (!seal) {\n    seal = function seal(x) {\n      return x;\n    };\n  }\n\n  if (!construct) {\n    construct = function construct(Func, args) {\n      return new (Function.prototype.bind.apply(Func, [null].concat(_toConsumableArray(args))))();\n    };\n  }\n\n  var arrayForEach = unapply(Array.prototype.forEach);\n  var arrayPop = unapply(Array.prototype.pop);\n  var arrayPush = unapply(Array.prototype.push);\n\n  var stringToLowerCase = unapply(String.prototype.toLowerCase);\n  var stringMatch = unapply(String.prototype.match);\n  var stringReplace = unapply(String.prototype.replace);\n  var stringIndexOf = unapply(String.prototype.indexOf);\n  var stringTrim = unapply(String.prototype.trim);\n\n  var regExpTest = unapply(RegExp.prototype.test);\n\n  var typeErrorCreate = unconstruct(TypeError);\n\n  function unapply(func) {\n    return function (thisArg) {\n      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n\n      return apply(func, thisArg, args);\n    };\n  }\n\n  function unconstruct(func) {\n    return function () {\n      for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n\n      return construct(func, args);\n    };\n  }\n\n  /* Add properties to a lookup table */\n  function addToSet(set, array) {\n    if (setPrototypeOf) {\n      // Make 'in' and truthy checks like Boolean(set.constructor)\n      // independent of any properties defined on Object.prototype.\n      // Prevent prototype setters from intercepting set as a this value.\n      setPrototypeOf(set, null);\n    }\n\n    var l = array.length;\n    while (l--) {\n      var element = array[l];\n      if (typeof element === 'string') {\n        var lcElement = stringToLowerCase(element);\n        if (lcElement !== element) {\n          // Config presets (e.g. tags.js, attrs.js) are immutable.\n          if (!isFrozen(array)) {\n            array[l] = lcElement;\n          }\n\n          element = lcElement;\n        }\n      }\n\n      set[element] = true;\n    }\n\n    return set;\n  }\n\n  /* Shallow clone an object */\n  function clone(object) {\n    var newObject = create(null);\n\n    var property = void 0;\n    for (property in object) {\n      if (apply(hasOwnProperty, object, [property])) {\n        newObject[property] = object[property];\n      }\n    }\n\n    return newObject;\n  }\n\n  /* IE10 doesn't support __lookupGetter__ so lets'\n   * simulate it. It also automatically checks\n   * if the prop is function or getter and behaves\n   * accordingly. */\n  function lookupGetter(object, prop) {\n    while (object !== null) {\n      var desc = getOwnPropertyDescriptor(object, prop);\n      if (desc) {\n        if (desc.get) {\n          return unapply(desc.get);\n        }\n\n        if (typeof desc.value === 'function') {\n          return unapply(desc.value);\n        }\n      }\n\n      object = getPrototypeOf(object);\n    }\n\n    return null;\n  }\n\n  var html = freeze(['a', 'abbr', 'acronym', 'address', 'area', 'article', 'aside', 'audio', 'b', 'bdi', 'bdo', 'big', 'blink', 'blockquote', 'body', 'br', 'button', 'canvas', 'caption', 'center', 'cite', 'code', 'col', 'colgroup', 'content', 'data', 'datalist', 'dd', 'decorator', 'del', 'details', 'dfn', 'dialog', 'dir', 'div', 'dl', 'dt', 'element', 'em', 'fieldset', 'figcaption', 'figure', 'font', 'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'i', 'img', 'input', 'ins', 'kbd', 'label', 'legend', 'li', 'main', 'map', 'mark', 'marquee', 'menu', 'menuitem', 'meter', 'nav', 'nobr', 'ol', 'optgroup', 'option', 'output', 'p', 'picture', 'pre', 'progress', 'q', 'rp', 'rt', 'ruby', 's', 'samp', 'section', 'select', 'shadow', 'small', 'source', 'spacer', 'span', 'strike', 'strong', 'style', 'sub', 'summary', 'sup', 'table', 'tbody', 'td', 'template', 'textarea', 'tfoot', 'th', 'thead', 'time', 'tr', 'track', 'tt', 'u', 'ul', 'var', 'video', 'wbr']);\n\n  // SVG\n  var svg = freeze(['svg', 'a', 'altglyph', 'altglyphdef', 'altglyphitem', 'animatecolor', 'animatemotion', 'animatetransform', 'circle', 'clippath', 'defs', 'desc', 'ellipse', 'filter', 'font', 'g', 'glyph', 'glyphref', 'hkern', 'image', 'line', 'lineargradient', 'marker', 'mask', 'metadata', 'mpath', 'path', 'pattern', 'polygon', 'polyline', 'radialgradient', 'rect', 'stop', 'style', 'switch', 'symbol', 'text', 'textpath', 'title', 'tref', 'tspan', 'view', 'vkern']);\n\n  var svgFilters = freeze(['feBlend', 'feColorMatrix', 'feComponentTransfer', 'feComposite', 'feConvolveMatrix', 'feDiffuseLighting', 'feDisplacementMap', 'feDistantLight', 'feFlood', 'feFuncA', 'feFuncB', 'feFuncG', 'feFuncR', 'feGaussianBlur', 'feMerge', 'feMergeNode', 'feMorphology', 'feOffset', 'fePointLight', 'feSpecularLighting', 'feSpotLight', 'feTile', 'feTurbulence']);\n\n  // List of SVG elements that are disallowed by default.\n  // We still need to know them so that we can do namespace\n  // checks properly in case one wants to add them to\n  // allow-list.\n  var svgDisallowed = freeze(['animate', 'color-profile', 'cursor', 'discard', 'fedropshadow', 'feimage', 'font-face', 'font-face-format', 'font-face-name', 'font-face-src', 'font-face-uri', 'foreignobject', 'hatch', 'hatchpath', 'mesh', 'meshgradient', 'meshpatch', 'meshrow', 'missing-glyph', 'script', 'set', 'solidcolor', 'unknown', 'use']);\n\n  var mathMl = freeze(['math', 'menclose', 'merror', 'mfenced', 'mfrac', 'mglyph', 'mi', 'mlabeledtr', 'mmultiscripts', 'mn', 'mo', 'mover', 'mpadded', 'mphantom', 'mroot', 'mrow', 'ms', 'mspace', 'msqrt', 'mstyle', 'msub', 'msup', 'msubsup', 'mtable', 'mtd', 'mtext', 'mtr', 'munder', 'munderover']);\n\n  // Similarly to SVG, we want to know all MathML elements,\n  // even those that we disallow by default.\n  var mathMlDisallowed = freeze(['maction', 'maligngroup', 'malignmark', 'mlongdiv', 'mscarries', 'mscarry', 'msgroup', 'mstack', 'msline', 'msrow', 'semantics', 'annotation', 'annotation-xml', 'mprescripts', 'none']);\n\n  var text = freeze(['#text']);\n\n  var html$1 = freeze(['accept', 'action', 'align', 'alt', 'autocapitalize', 'autocomplete', 'autopictureinpicture', 'autoplay', 'background', 'bgcolor', 'border', 'capture', 'cellpadding', 'cellspacing', 'checked', 'cite', 'class', 'clear', 'color', 'cols', 'colspan', 'controls', 'controlslist', 'coords', 'crossorigin', 'datetime', 'decoding', 'default', 'dir', 'disabled', 'disablepictureinpicture', 'disableremoteplayback', 'download', 'draggable', 'enctype', 'enterkeyhint', 'face', 'for', 'headers', 'height', 'hidden', 'high', 'href', 'hreflang', 'id', 'inputmode', 'integrity', 'ismap', 'kind', 'label', 'lang', 'list', 'loading', 'loop', 'low', 'max', 'maxlength', 'media', 'method', 'min', 'minlength', 'multiple', 'muted', 'name', 'noshade', 'novalidate', 'nowrap', 'open', 'optimum', 'pattern', 'placeholder', 'playsinline', 'poster', 'preload', 'pubdate', 'radiogroup', 'readonly', 'rel', 'required', 'rev', 'reversed', 'role', 'rows', 'rowspan', 'spellcheck', 'scope', 'selected', 'shape', 'size', 'sizes', 'span', 'srclang', 'start', 'src', 'srcset', 'step', 'style', 'summary', 'tabindex', 'title', 'translate', 'type', 'usemap', 'valign', 'value', 'width', 'xmlns']);\n\n  var svg$1 = freeze(['accent-height', 'accumulate', 'additive', 'alignment-baseline', 'ascent', 'attributename', 'attributetype', 'azimuth', 'basefrequency', 'baseline-shift', 'begin', 'bias', 'by', 'class', 'clip', 'clippathunits', 'clip-path', 'clip-rule', 'color', 'color-interpolation', 'color-interpolation-filters', 'color-profile', 'color-rendering', 'cx', 'cy', 'd', 'dx', 'dy', 'diffuseconstant', 'direction', 'display', 'divisor', 'dur', 'edgemode', 'elevation', 'end', 'fill', 'fill-opacity', 'fill-rule', 'filter', 'filterunits', 'flood-color', 'flood-opacity', 'font-family', 'font-size', 'font-size-adjust', 'font-stretch', 'font-style', 'font-variant', 'font-weight', 'fx', 'fy', 'g1', 'g2', 'glyph-name', 'glyphref', 'gradientunits', 'gradienttransform', 'height', 'href', 'id', 'image-rendering', 'in', 'in2', 'k', 'k1', 'k2', 'k3', 'k4', 'kerning', 'keypoints', 'keysplines', 'keytimes', 'lang', 'lengthadjust', 'letter-spacing', 'kernelmatrix', 'kernelunitlength', 'lighting-color', 'local', 'marker-end', 'marker-mid', 'marker-start', 'markerheight', 'markerunits', 'markerwidth', 'maskcontentunits', 'maskunits', 'max', 'mask', 'media', 'method', 'mode', 'min', 'name', 'numoctaves', 'offset', 'operator', 'opacity', 'order', 'orient', 'orientation', 'origin', 'overflow', 'paint-order', 'path', 'pathlength', 'patterncontentunits', 'patterntransform', 'patternunits', 'points', 'preservealpha', 'preserveaspectratio', 'primitiveunits', 'r', 'rx', 'ry', 'radius', 'refx', 'refy', 'repeatcount', 'repeatdur', 'restart', 'result', 'rotate', 'scale', 'seed', 'shape-rendering', 'specularconstant', 'specularexponent', 'spreadmethod', 'startoffset', 'stddeviation', 'stitchtiles', 'stop-color', 'stop-opacity', 'stroke-dasharray', 'stroke-dashoffset', 'stroke-linecap', 'stroke-linejoin', 'stroke-miterlimit', 'stroke-opacity', 'stroke', 'stroke-width', 'style', 'surfacescale', 'systemlanguage', 'tabindex', 'targetx', 'targety', 'transform', 'text-anchor', 'text-decoration', 'text-rendering', 'textlength', 'type', 'u1', 'u2', 'unicode', 'values', 'viewbox', 'visibility', 'version', 'vert-adv-y', 'vert-origin-x', 'vert-origin-y', 'width', 'word-spacing', 'wrap', 'writing-mode', 'xchannelselector', 'ychannelselector', 'x', 'x1', 'x2', 'xmlns', 'y', 'y1', 'y2', 'z', 'zoomandpan']);\n\n  var mathMl$1 = freeze(['accent', 'accentunder', 'align', 'bevelled', 'close', 'columnsalign', 'columnlines', 'columnspan', 'denomalign', 'depth', 'dir', 'display', 'displaystyle', 'encoding', 'fence', 'frame', 'height', 'href', 'id', 'largeop', 'length', 'linethickness', 'lspace', 'lquote', 'mathbackground', 'mathcolor', 'mathsize', 'mathvariant', 'maxsize', 'minsize', 'movablelimits', 'notation', 'numalign', 'open', 'rowalign', 'rowlines', 'rowspacing', 'rowspan', 'rspace', 'rquote', 'scriptlevel', 'scriptminsize', 'scriptsizemultiplier', 'selection', 'separator', 'separators', 'stretchy', 'subscriptshift', 'supscriptshift', 'symmetric', 'voffset', 'width', 'xmlns']);\n\n  var xml = freeze(['xlink:href', 'xml:id', 'xlink:title', 'xml:space', 'xmlns:xlink']);\n\n  // eslint-disable-next-line unicorn/better-regex\n  var MUSTACHE_EXPR = seal(/\\{\\{[\\s\\S]*|[\\s\\S]*\\}\\}/gm); // Specify template detection regex for SAFE_FOR_TEMPLATES mode\n  var ERB_EXPR = seal(/<%[\\s\\S]*|[\\s\\S]*%>/gm);\n  var DATA_ATTR = seal(/^data-[\\-\\w.\\u00B7-\\uFFFF]/); // eslint-disable-line no-useless-escape\n  var ARIA_ATTR = seal(/^aria-[\\-\\w]+$/); // eslint-disable-line no-useless-escape\n  var IS_ALLOWED_URI = seal(/^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp):|[^a-z]|[a-z+.\\-]+(?:[^a-z+.\\-:]|$))/i // eslint-disable-line no-useless-escape\n  );\n  var IS_SCRIPT_OR_DATA = seal(/^(?:\\w+script|data):/i);\n  var ATTR_WHITESPACE = seal(/[\\u0000-\\u0020\\u00A0\\u1680\\u180E\\u2000-\\u2029\\u205F\\u3000]/g // eslint-disable-line no-control-regex\n  );\n\n  var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n  function _toConsumableArray$1(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\n  var getGlobal = function getGlobal() {\n    return typeof window === 'undefined' ? null : window;\n  };\n\n  /**\n   * Creates a no-op policy for internal use only.\n   * Don't export this function outside this module!\n   * @param {?TrustedTypePolicyFactory} trustedTypes The policy factory.\n   * @param {Document} document The document object (to determine policy name suffix)\n   * @return {?TrustedTypePolicy} The policy created (or null, if Trusted Types\n   * are not supported).\n   */\n  var _createTrustedTypesPolicy = function _createTrustedTypesPolicy(trustedTypes, document) {\n    if ((typeof trustedTypes === 'undefined' ? 'undefined' : _typeof(trustedTypes)) !== 'object' || typeof trustedTypes.createPolicy !== 'function') {\n      return null;\n    }\n\n    // Allow the callers to control the unique policy name\n    // by adding a data-tt-policy-suffix to the script element with the DOMPurify.\n    // Policy creation with duplicate names throws in Trusted Types.\n    var suffix = null;\n    var ATTR_NAME = 'data-tt-policy-suffix';\n    if (document.currentScript && document.currentScript.hasAttribute(ATTR_NAME)) {\n      suffix = document.currentScript.getAttribute(ATTR_NAME);\n    }\n\n    var policyName = 'dompurify' + (suffix ? '#' + suffix : '');\n\n    try {\n      return trustedTypes.createPolicy(policyName, {\n        createHTML: function createHTML(html$$1) {\n          return html$$1;\n        }\n      });\n    } catch (_) {\n      // Policy creation failed (most likely another DOMPurify script has\n      // already run). Skip creating the policy, as this will only cause errors\n      // if TT are enforced.\n      console.warn('TrustedTypes policy ' + policyName + ' could not be created.');\n      return null;\n    }\n  };\n\n  function createDOMPurify() {\n    var window = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : getGlobal();\n\n    var DOMPurify = function DOMPurify(root) {\n      return createDOMPurify(root);\n    };\n\n    /**\n     * Version label, exposed for easier checks\n     * if DOMPurify is up to date or not\n     */\n    DOMPurify.version = '2.2.6';\n\n    /**\n     * Array of elements that DOMPurify removed during sanitation.\n     * Empty if nothing was removed.\n     */\n    DOMPurify.removed = [];\n\n    if (!window || !window.document || window.document.nodeType !== 9) {\n      // Not running in a browser, provide a factory function\n      // so that you can pass your own Window\n      DOMPurify.isSupported = false;\n\n      return DOMPurify;\n    }\n\n    var originalDocument = window.document;\n\n    var document = window.document;\n    var DocumentFragment = window.DocumentFragment,\n        HTMLTemplateElement = window.HTMLTemplateElement,\n        Node = window.Node,\n        Element = window.Element,\n        NodeFilter = window.NodeFilter,\n        _window$NamedNodeMap = window.NamedNodeMap,\n        NamedNodeMap = _window$NamedNodeMap === undefined ? window.NamedNodeMap || window.MozNamedAttrMap : _window$NamedNodeMap,\n        Text = window.Text,\n        Comment = window.Comment,\n        DOMParser = window.DOMParser,\n        trustedTypes = window.trustedTypes;\n\n\n    var ElementPrototype = Element.prototype;\n\n    var cloneNode = lookupGetter(ElementPrototype, 'cloneNode');\n    var getNextSibling = lookupGetter(ElementPrototype, 'nextSibling');\n    var getChildNodes = lookupGetter(ElementPrototype, 'childNodes');\n    var getParentNode = lookupGetter(ElementPrototype, 'parentNode');\n\n    // As per issue #47, the web-components registry is inherited by a\n    // new document created via createHTMLDocument. As per the spec\n    // (http://w3c.github.io/webcomponents/spec/custom/#creating-and-passing-registries)\n    // a new empty registry is used when creating a template contents owner\n    // document, so we use that as our parent document to ensure nothing\n    // is inherited.\n    if (typeof HTMLTemplateElement === 'function') {\n      var template = document.createElement('template');\n      if (template.content && template.content.ownerDocument) {\n        document = template.content.ownerDocument;\n      }\n    }\n\n    var trustedTypesPolicy = _createTrustedTypesPolicy(trustedTypes, originalDocument);\n    var emptyHTML = trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML('') : '';\n\n    var _document = document,\n        implementation = _document.implementation,\n        createNodeIterator = _document.createNodeIterator,\n        getElementsByTagName = _document.getElementsByTagName,\n        createDocumentFragment = _document.createDocumentFragment;\n    var importNode = originalDocument.importNode;\n\n\n    var documentMode = {};\n    try {\n      documentMode = clone(document).documentMode ? document.documentMode : {};\n    } catch (_) {}\n\n    var hooks = {};\n\n    /**\n     * Expose whether this browser supports running the full DOMPurify.\n     */\n    DOMPurify.isSupported = implementation && typeof implementation.createHTMLDocument !== 'undefined' && documentMode !== 9;\n\n    var MUSTACHE_EXPR$$1 = MUSTACHE_EXPR,\n        ERB_EXPR$$1 = ERB_EXPR,\n        DATA_ATTR$$1 = DATA_ATTR,\n        ARIA_ATTR$$1 = ARIA_ATTR,\n        IS_SCRIPT_OR_DATA$$1 = IS_SCRIPT_OR_DATA,\n        ATTR_WHITESPACE$$1 = ATTR_WHITESPACE;\n    var IS_ALLOWED_URI$$1 = IS_ALLOWED_URI;\n\n    /**\n     * We consider the elements and attributes below to be safe. Ideally\n     * don't add any new ones but feel free to remove unwanted ones.\n     */\n\n    /* allowed element names */\n\n    var ALLOWED_TAGS = null;\n    var DEFAULT_ALLOWED_TAGS = addToSet({}, [].concat(_toConsumableArray$1(html), _toConsumableArray$1(svg), _toConsumableArray$1(svgFilters), _toConsumableArray$1(mathMl), _toConsumableArray$1(text)));\n\n    /* Allowed attribute names */\n    var ALLOWED_ATTR = null;\n    var DEFAULT_ALLOWED_ATTR = addToSet({}, [].concat(_toConsumableArray$1(html$1), _toConsumableArray$1(svg$1), _toConsumableArray$1(mathMl$1), _toConsumableArray$1(xml)));\n\n    /* Explicitly forbidden tags (overrides ALLOWED_TAGS/ADD_TAGS) */\n    var FORBID_TAGS = null;\n\n    /* Explicitly forbidden attributes (overrides ALLOWED_ATTR/ADD_ATTR) */\n    var FORBID_ATTR = null;\n\n    /* Decide if ARIA attributes are okay */\n    var ALLOW_ARIA_ATTR = true;\n\n    /* Decide if custom data attributes are okay */\n    var ALLOW_DATA_ATTR = true;\n\n    /* Decide if unknown protocols are okay */\n    var ALLOW_UNKNOWN_PROTOCOLS = false;\n\n    /* Output should be safe for common template engines.\n     * This means, DOMPurify removes data attributes, mustaches and ERB\n     */\n    var SAFE_FOR_TEMPLATES = false;\n\n    /* Decide if document with <html>... should be returned */\n    var WHOLE_DOCUMENT = false;\n\n    /* Track whether config is already set on this instance of DOMPurify. */\n    var SET_CONFIG = false;\n\n    /* Decide if all elements (e.g. style, script) must be children of\n     * document.body. By default, browsers might move them to document.head */\n    var FORCE_BODY = false;\n\n    /* Decide if a DOM `HTMLBodyElement` should be returned, instead of a html\n     * string (or a TrustedHTML object if Trusted Types are supported).\n     * If `WHOLE_DOCUMENT` is enabled a `HTMLHtmlElement` will be returned instead\n     */\n    var RETURN_DOM = false;\n\n    /* Decide if a DOM `DocumentFragment` should be returned, instead of a html\n     * string  (or a TrustedHTML object if Trusted Types are supported) */\n    var RETURN_DOM_FRAGMENT = false;\n\n    /* If `RETURN_DOM` or `RETURN_DOM_FRAGMENT` is enabled, decide if the returned DOM\n     * `Node` is imported into the current `Document`. If this flag is not enabled the\n     * `Node` will belong (its ownerDocument) to a fresh `HTMLDocument`, created by\n     * DOMPurify.\n     *\n     * This defaults to `true` starting DOMPurify 2.2.0. Note that setting it to `false`\n     * might cause XSS from attacks hidden in closed shadowroots in case the browser\n     * supports Declarative Shadow: DOM https://web.dev/declarative-shadow-dom/\n     */\n    var RETURN_DOM_IMPORT = true;\n\n    /* Try to return a Trusted Type object instead of a string, return a string in\n     * case Trusted Types are not supported  */\n    var RETURN_TRUSTED_TYPE = false;\n\n    /* Output should be free from DOM clobbering attacks? */\n    var SANITIZE_DOM = true;\n\n    /* Keep element content when removing element? */\n    var KEEP_CONTENT = true;\n\n    /* If a `Node` is passed to sanitize(), then performs sanitization in-place instead\n     * of importing it into a new Document and returning a sanitized copy */\n    var IN_PLACE = false;\n\n    /* Allow usage of profiles like html, svg and mathMl */\n    var USE_PROFILES = {};\n\n    /* Tags to ignore content of when KEEP_CONTENT is true */\n    var FORBID_CONTENTS = addToSet({}, ['annotation-xml', 'audio', 'colgroup', 'desc', 'foreignobject', 'head', 'iframe', 'math', 'mi', 'mn', 'mo', 'ms', 'mtext', 'noembed', 'noframes', 'noscript', 'plaintext', 'script', 'style', 'svg', 'template', 'thead', 'title', 'video', 'xmp']);\n\n    /* Tags that are safe for data: URIs */\n    var DATA_URI_TAGS = null;\n    var DEFAULT_DATA_URI_TAGS = addToSet({}, ['audio', 'video', 'img', 'source', 'image', 'track']);\n\n    /* Attributes safe for values like \"javascript:\" */\n    var URI_SAFE_ATTRIBUTES = null;\n    var DEFAULT_URI_SAFE_ATTRIBUTES = addToSet({}, ['alt', 'class', 'for', 'id', 'label', 'name', 'pattern', 'placeholder', 'summary', 'title', 'value', 'style', 'xmlns']);\n\n    /* Keep a reference to config to pass to hooks */\n    var CONFIG = null;\n\n    /* Ideally, do not touch anything below this line */\n    /* ______________________________________________ */\n\n    var formElement = document.createElement('form');\n\n    /**\n     * _parseConfig\n     *\n     * @param  {Object} cfg optional config literal\n     */\n    // eslint-disable-next-line complexity\n    var _parseConfig = function _parseConfig(cfg) {\n      if (CONFIG && CONFIG === cfg) {\n        return;\n      }\n\n      /* Shield configuration object from tampering */\n      if (!cfg || (typeof cfg === 'undefined' ? 'undefined' : _typeof(cfg)) !== 'object') {\n        cfg = {};\n      }\n\n      /* Shield configuration object from prototype pollution */\n      cfg = clone(cfg);\n\n      /* Set configuration parameters */\n      ALLOWED_TAGS = 'ALLOWED_TAGS' in cfg ? addToSet({}, cfg.ALLOWED_TAGS) : DEFAULT_ALLOWED_TAGS;\n      ALLOWED_ATTR = 'ALLOWED_ATTR' in cfg ? addToSet({}, cfg.ALLOWED_ATTR) : DEFAULT_ALLOWED_ATTR;\n      URI_SAFE_ATTRIBUTES = 'ADD_URI_SAFE_ATTR' in cfg ? addToSet(clone(DEFAULT_URI_SAFE_ATTRIBUTES), cfg.ADD_URI_SAFE_ATTR) : DEFAULT_URI_SAFE_ATTRIBUTES;\n      DATA_URI_TAGS = 'ADD_DATA_URI_TAGS' in cfg ? addToSet(clone(DEFAULT_DATA_URI_TAGS), cfg.ADD_DATA_URI_TAGS) : DEFAULT_DATA_URI_TAGS;\n      FORBID_TAGS = 'FORBID_TAGS' in cfg ? addToSet({}, cfg.FORBID_TAGS) : {};\n      FORBID_ATTR = 'FORBID_ATTR' in cfg ? addToSet({}, cfg.FORBID_ATTR) : {};\n      USE_PROFILES = 'USE_PROFILES' in cfg ? cfg.USE_PROFILES : false;\n      ALLOW_ARIA_ATTR = cfg.ALLOW_ARIA_ATTR !== false; // Default true\n      ALLOW_DATA_ATTR = cfg.ALLOW_DATA_ATTR !== false; // Default true\n      ALLOW_UNKNOWN_PROTOCOLS = cfg.ALLOW_UNKNOWN_PROTOCOLS || false; // Default false\n      SAFE_FOR_TEMPLATES = cfg.SAFE_FOR_TEMPLATES || false; // Default false\n      WHOLE_DOCUMENT = cfg.WHOLE_DOCUMENT || false; // Default false\n      RETURN_DOM = cfg.RETURN_DOM || false; // Default false\n      RETURN_DOM_FRAGMENT = cfg.RETURN_DOM_FRAGMENT || false; // Default false\n      RETURN_DOM_IMPORT = cfg.RETURN_DOM_IMPORT !== false; // Default true\n      RETURN_TRUSTED_TYPE = cfg.RETURN_TRUSTED_TYPE || false; // Default false\n      FORCE_BODY = cfg.FORCE_BODY || false; // Default false\n      SANITIZE_DOM = cfg.SANITIZE_DOM !== false; // Default true\n      KEEP_CONTENT = cfg.KEEP_CONTENT !== false; // Default true\n      IN_PLACE = cfg.IN_PLACE || false; // Default false\n      IS_ALLOWED_URI$$1 = cfg.ALLOWED_URI_REGEXP || IS_ALLOWED_URI$$1;\n      if (SAFE_FOR_TEMPLATES) {\n        ALLOW_DATA_ATTR = false;\n      }\n\n      if (RETURN_DOM_FRAGMENT) {\n        RETURN_DOM = true;\n      }\n\n      /* Parse profile info */\n      if (USE_PROFILES) {\n        ALLOWED_TAGS = addToSet({}, [].concat(_toConsumableArray$1(text)));\n        ALLOWED_ATTR = [];\n        if (USE_PROFILES.html === true) {\n          addToSet(ALLOWED_TAGS, html);\n          addToSet(ALLOWED_ATTR, html$1);\n        }\n\n        if (USE_PROFILES.svg === true) {\n          addToSet(ALLOWED_TAGS, svg);\n          addToSet(ALLOWED_ATTR, svg$1);\n          addToSet(ALLOWED_ATTR, xml);\n        }\n\n        if (USE_PROFILES.svgFilters === true) {\n          addToSet(ALLOWED_TAGS, svgFilters);\n          addToSet(ALLOWED_ATTR, svg$1);\n          addToSet(ALLOWED_ATTR, xml);\n        }\n\n        if (USE_PROFILES.mathMl === true) {\n          addToSet(ALLOWED_TAGS, mathMl);\n          addToSet(ALLOWED_ATTR, mathMl$1);\n          addToSet(ALLOWED_ATTR, xml);\n        }\n      }\n\n      /* Merge configuration parameters */\n      if (cfg.ADD_TAGS) {\n        if (ALLOWED_TAGS === DEFAULT_ALLOWED_TAGS) {\n          ALLOWED_TAGS = clone(ALLOWED_TAGS);\n        }\n\n        addToSet(ALLOWED_TAGS, cfg.ADD_TAGS);\n      }\n\n      if (cfg.ADD_ATTR) {\n        if (ALLOWED_ATTR === DEFAULT_ALLOWED_ATTR) {\n          ALLOWED_ATTR = clone(ALLOWED_ATTR);\n        }\n\n        addToSet(ALLOWED_ATTR, cfg.ADD_ATTR);\n      }\n\n      if (cfg.ADD_URI_SAFE_ATTR) {\n        addToSet(URI_SAFE_ATTRIBUTES, cfg.ADD_URI_SAFE_ATTR);\n      }\n\n      /* Add #text in case KEEP_CONTENT is set to true */\n      if (KEEP_CONTENT) {\n        ALLOWED_TAGS['#text'] = true;\n      }\n\n      /* Add html, head and body to ALLOWED_TAGS in case WHOLE_DOCUMENT is true */\n      if (WHOLE_DOCUMENT) {\n        addToSet(ALLOWED_TAGS, ['html', 'head', 'body']);\n      }\n\n      /* Add tbody to ALLOWED_TAGS in case tables are permitted, see #286, #365 */\n      if (ALLOWED_TAGS.table) {\n        addToSet(ALLOWED_TAGS, ['tbody']);\n        delete FORBID_TAGS.tbody;\n      }\n\n      // Prevent further manipulation of configuration.\n      // Not available in IE8, Safari 5, etc.\n      if (freeze) {\n        freeze(cfg);\n      }\n\n      CONFIG = cfg;\n    };\n\n    var MATHML_TEXT_INTEGRATION_POINTS = addToSet({}, ['mi', 'mo', 'mn', 'ms', 'mtext']);\n\n    var HTML_INTEGRATION_POINTS = addToSet({}, ['foreignobject', 'desc', 'title', 'annotation-xml']);\n\n    /* Keep track of all possible SVG and MathML tags\n     * so that we can perform the namespace checks\n     * correctly. */\n    var ALL_SVG_TAGS = addToSet({}, svg);\n    addToSet(ALL_SVG_TAGS, svgFilters);\n    addToSet(ALL_SVG_TAGS, svgDisallowed);\n\n    var ALL_MATHML_TAGS = addToSet({}, mathMl);\n    addToSet(ALL_MATHML_TAGS, mathMlDisallowed);\n\n    var MATHML_NAMESPACE = 'http://www.w3.org/1998/Math/MathML';\n    var SVG_NAMESPACE = 'http://www.w3.org/2000/svg';\n    var HTML_NAMESPACE = 'http://www.w3.org/1999/xhtml';\n\n    /**\n     *\n     *\n     * @param  {Element} element a DOM element whose namespace is being checked\n     * @returns {boolean} Return false if the element has a\n     *  namespace that a spec-compliant parser would never\n     *  return. Return true otherwise.\n     */\n    var _checkValidNamespace = function _checkValidNamespace(element) {\n      var parent = getParentNode(element);\n\n      // In JSDOM, if we're inside shadow DOM, then parentNode\n      // can be null. We just simulate parent in this case.\n      if (!parent || !parent.tagName) {\n        parent = {\n          namespaceURI: HTML_NAMESPACE,\n          tagName: 'template'\n        };\n      }\n\n      var tagName = stringToLowerCase(element.tagName);\n      var parentTagName = stringToLowerCase(parent.tagName);\n\n      if (element.namespaceURI === SVG_NAMESPACE) {\n        // The only way to switch from HTML namespace to SVG\n        // is via <svg>. If it happens via any other tag, then\n        // it should be killed.\n        if (parent.namespaceURI === HTML_NAMESPACE) {\n          return tagName === 'svg';\n        }\n\n        // The only way to switch from MathML to SVG is via\n        // svg if parent is either <annotation-xml> or MathML\n        // text integration points.\n        if (parent.namespaceURI === MATHML_NAMESPACE) {\n          return tagName === 'svg' && (parentTagName === 'annotation-xml' || MATHML_TEXT_INTEGRATION_POINTS[parentTagName]);\n        }\n\n        // We only allow elements that are defined in SVG\n        // spec. All others are disallowed in SVG namespace.\n        return Boolean(ALL_SVG_TAGS[tagName]);\n      }\n\n      if (element.namespaceURI === MATHML_NAMESPACE) {\n        // The only way to switch from HTML namespace to MathML\n        // is via <math>. If it happens via any other tag, then\n        // it should be killed.\n        if (parent.namespaceURI === HTML_NAMESPACE) {\n          return tagName === 'math';\n        }\n\n        // The only way to switch from SVG to MathML is via\n        // <math> and HTML integration points\n        if (parent.namespaceURI === SVG_NAMESPACE) {\n          return tagName === 'math' && HTML_INTEGRATION_POINTS[parentTagName];\n        }\n\n        // We only allow elements that are defined in MathML\n        // spec. All others are disallowed in MathML namespace.\n        return Boolean(ALL_MATHML_TAGS[tagName]);\n      }\n\n      if (element.namespaceURI === HTML_NAMESPACE) {\n        // The only way to switch from SVG to HTML is via\n        // HTML integration points, and from MathML to HTML\n        // is via MathML text integration points\n        if (parent.namespaceURI === SVG_NAMESPACE && !HTML_INTEGRATION_POINTS[parentTagName]) {\n          return false;\n        }\n\n        if (parent.namespaceURI === MATHML_NAMESPACE && !MATHML_TEXT_INTEGRATION_POINTS[parentTagName]) {\n          return false;\n        }\n\n        // Certain elements are allowed in both SVG and HTML\n        // namespace. We need to specify them explicitly\n        // so that they don't get erronously deleted from\n        // HTML namespace.\n        var commonSvgAndHTMLElements = addToSet({}, ['title', 'style', 'font', 'a', 'script']);\n\n        // We disallow tags that are specific for MathML\n        // or SVG and should never appear in HTML namespace\n        return !ALL_MATHML_TAGS[tagName] && (commonSvgAndHTMLElements[tagName] || !ALL_SVG_TAGS[tagName]);\n      }\n\n      // The code should never reach this place (this means\n      // that the element somehow got namespace that is not\n      // HTML, SVG or MathML). Return false just in case.\n      return false;\n    };\n\n    /**\n     * _forceRemove\n     *\n     * @param  {Node} node a DOM node\n     */\n    var _forceRemove = function _forceRemove(node) {\n      arrayPush(DOMPurify.removed, { element: node });\n      try {\n        node.parentNode.removeChild(node);\n      } catch (_) {\n        try {\n          node.outerHTML = emptyHTML;\n        } catch (_) {\n          node.remove();\n        }\n      }\n    };\n\n    /**\n     * _removeAttribute\n     *\n     * @param  {String} name an Attribute name\n     * @param  {Node} node a DOM node\n     */\n    var _removeAttribute = function _removeAttribute(name, node) {\n      try {\n        arrayPush(DOMPurify.removed, {\n          attribute: node.getAttributeNode(name),\n          from: node\n        });\n      } catch (_) {\n        arrayPush(DOMPurify.removed, {\n          attribute: null,\n          from: node\n        });\n      }\n\n      node.removeAttribute(name);\n    };\n\n    /**\n     * _initDocument\n     *\n     * @param  {String} dirty a string of dirty markup\n     * @return {Document} a DOM, filled with the dirty markup\n     */\n    var _initDocument = function _initDocument(dirty) {\n      /* Create a HTML document */\n      var doc = void 0;\n      var leadingWhitespace = void 0;\n\n      if (FORCE_BODY) {\n        dirty = '<remove></remove>' + dirty;\n      } else {\n        /* If FORCE_BODY isn't used, leading whitespace needs to be preserved manually */\n        var matches = stringMatch(dirty, /^[\\r\\n\\t ]+/);\n        leadingWhitespace = matches && matches[0];\n      }\n\n      var dirtyPayload = trustedTypesPolicy ? trustedTypesPolicy.createHTML(dirty) : dirty;\n      /* Use the DOMParser API by default, fallback later if needs be */\n      try {\n        doc = new DOMParser().parseFromString(dirtyPayload, 'text/html');\n      } catch (_) {}\n\n      /* Use createHTMLDocument in case DOMParser is not available */\n      if (!doc || !doc.documentElement) {\n        doc = implementation.createHTMLDocument('');\n        var _doc = doc,\n            body = _doc.body;\n\n        body.parentNode.removeChild(body.parentNode.firstElementChild);\n        body.outerHTML = dirtyPayload;\n      }\n\n      if (dirty && leadingWhitespace) {\n        doc.body.insertBefore(document.createTextNode(leadingWhitespace), doc.body.childNodes[0] || null);\n      }\n\n      /* Work on whole document or just its body */\n      return getElementsByTagName.call(doc, WHOLE_DOCUMENT ? 'html' : 'body')[0];\n    };\n\n    /**\n     * _createIterator\n     *\n     * @param  {Document} root document/fragment to create iterator for\n     * @return {Iterator} iterator instance\n     */\n    var _createIterator = function _createIterator(root) {\n      return createNodeIterator.call(root.ownerDocument || root, root, NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT | NodeFilter.SHOW_TEXT, function () {\n        return NodeFilter.FILTER_ACCEPT;\n      }, false);\n    };\n\n    /**\n     * _isClobbered\n     *\n     * @param  {Node} elm element to check for clobbering attacks\n     * @return {Boolean} true if clobbered, false if safe\n     */\n    var _isClobbered = function _isClobbered(elm) {\n      if (elm instanceof Text || elm instanceof Comment) {\n        return false;\n      }\n\n      if (typeof elm.nodeName !== 'string' || typeof elm.textContent !== 'string' || typeof elm.removeChild !== 'function' || !(elm.attributes instanceof NamedNodeMap) || typeof elm.removeAttribute !== 'function' || typeof elm.setAttribute !== 'function' || typeof elm.namespaceURI !== 'string' || typeof elm.insertBefore !== 'function') {\n        return true;\n      }\n\n      return false;\n    };\n\n    /**\n     * _isNode\n     *\n     * @param  {Node} obj object to check whether it's a DOM node\n     * @return {Boolean} true is object is a DOM node\n     */\n    var _isNode = function _isNode(object) {\n      return (typeof Node === 'undefined' ? 'undefined' : _typeof(Node)) === 'object' ? object instanceof Node : object && (typeof object === 'undefined' ? 'undefined' : _typeof(object)) === 'object' && typeof object.nodeType === 'number' && typeof object.nodeName === 'string';\n    };\n\n    /**\n     * _executeHook\n     * Execute user configurable hooks\n     *\n     * @param  {String} entryPoint  Name of the hook's entry point\n     * @param  {Node} currentNode node to work on with the hook\n     * @param  {Object} data additional hook parameters\n     */\n    var _executeHook = function _executeHook(entryPoint, currentNode, data) {\n      if (!hooks[entryPoint]) {\n        return;\n      }\n\n      arrayForEach(hooks[entryPoint], function (hook) {\n        hook.call(DOMPurify, currentNode, data, CONFIG);\n      });\n    };\n\n    /**\n     * _sanitizeElements\n     *\n     * @protect nodeName\n     * @protect textContent\n     * @protect removeChild\n     *\n     * @param   {Node} currentNode to check for permission to exist\n     * @return  {Boolean} true if node was killed, false if left alive\n     */\n    var _sanitizeElements = function _sanitizeElements(currentNode) {\n      var content = void 0;\n\n      /* Execute a hook if present */\n      _executeHook('beforeSanitizeElements', currentNode, null);\n\n      /* Check if element is clobbered or can clobber */\n      if (_isClobbered(currentNode)) {\n        _forceRemove(currentNode);\n        return true;\n      }\n\n      /* Check if tagname contains Unicode */\n      if (stringMatch(currentNode.nodeName, /[\\u0080-\\uFFFF]/)) {\n        _forceRemove(currentNode);\n        return true;\n      }\n\n      /* Now let's check the element's type and name */\n      var tagName = stringToLowerCase(currentNode.nodeName);\n\n      /* Execute a hook if present */\n      _executeHook('uponSanitizeElement', currentNode, {\n        tagName: tagName,\n        allowedTags: ALLOWED_TAGS\n      });\n\n      /* Detect mXSS attempts abusing namespace confusion */\n      if (!_isNode(currentNode.firstElementChild) && (!_isNode(currentNode.content) || !_isNode(currentNode.content.firstElementChild)) && regExpTest(/<[/\\w]/g, currentNode.innerHTML) && regExpTest(/<[/\\w]/g, currentNode.textContent)) {\n        _forceRemove(currentNode);\n        return true;\n      }\n\n      /* Remove element if anything forbids its presence */\n      if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {\n        /* Keep content except for bad-listed elements */\n        if (KEEP_CONTENT && !FORBID_CONTENTS[tagName]) {\n          var parentNode = getParentNode(currentNode);\n          var childNodes = getChildNodes(currentNode);\n          var childCount = childNodes.length;\n          for (var i = childCount - 1; i >= 0; --i) {\n            parentNode.insertBefore(cloneNode(childNodes[i], true), getNextSibling(currentNode));\n          }\n        }\n\n        _forceRemove(currentNode);\n        return true;\n      }\n\n      /* Check whether element has a valid namespace */\n      if (currentNode instanceof Element && !_checkValidNamespace(currentNode)) {\n        _forceRemove(currentNode);\n        return true;\n      }\n\n      if ((tagName === 'noscript' || tagName === 'noembed') && regExpTest(/<\\/no(script|embed)/i, currentNode.innerHTML)) {\n        _forceRemove(currentNode);\n        return true;\n      }\n\n      /* Sanitize element content to be template-safe */\n      if (SAFE_FOR_TEMPLATES && currentNode.nodeType === 3) {\n        /* Get the element's text content */\n        content = currentNode.textContent;\n        content = stringReplace(content, MUSTACHE_EXPR$$1, ' ');\n        content = stringReplace(content, ERB_EXPR$$1, ' ');\n        if (currentNode.textContent !== content) {\n          arrayPush(DOMPurify.removed, { element: currentNode.cloneNode() });\n          currentNode.textContent = content;\n        }\n      }\n\n      /* Execute a hook if present */\n      _executeHook('afterSanitizeElements', currentNode, null);\n\n      return false;\n    };\n\n    /**\n     * _isValidAttribute\n     *\n     * @param  {string} lcTag Lowercase tag name of containing element.\n     * @param  {string} lcName Lowercase attribute name.\n     * @param  {string} value Attribute value.\n     * @return {Boolean} Returns true if `value` is valid, otherwise false.\n     */\n    // eslint-disable-next-line complexity\n    var _isValidAttribute = function _isValidAttribute(lcTag, lcName, value) {\n      /* Make sure attribute cannot clobber */\n      if (SANITIZE_DOM && (lcName === 'id' || lcName === 'name') && (value in document || value in formElement)) {\n        return false;\n      }\n\n      /* Allow valid data-* attributes: At least one character after \"-\"\n          (https://html.spec.whatwg.org/multipage/dom.html#embedding-custom-non-visible-data-with-the-data-*-attributes)\n          XML-compatible (https://html.spec.whatwg.org/multipage/infrastructure.html#xml-compatible and http://www.w3.org/TR/xml/#d0e804)\n          We don't need to check the value; it's always URI safe. */\n      if (ALLOW_DATA_ATTR && regExpTest(DATA_ATTR$$1, lcName)) ; else if (ALLOW_ARIA_ATTR && regExpTest(ARIA_ATTR$$1, lcName)) ; else if (!ALLOWED_ATTR[lcName] || FORBID_ATTR[lcName]) {\n        return false;\n\n        /* Check value is safe. First, is attr inert? If so, is safe */\n      } else if (URI_SAFE_ATTRIBUTES[lcName]) ; else if (regExpTest(IS_ALLOWED_URI$$1, stringReplace(value, ATTR_WHITESPACE$$1, ''))) ; else if ((lcName === 'src' || lcName === 'xlink:href' || lcName === 'href') && lcTag !== 'script' && stringIndexOf(value, 'data:') === 0 && DATA_URI_TAGS[lcTag]) ; else if (ALLOW_UNKNOWN_PROTOCOLS && !regExpTest(IS_SCRIPT_OR_DATA$$1, stringReplace(value, ATTR_WHITESPACE$$1, ''))) ; else if (!value) ; else {\n        return false;\n      }\n\n      return true;\n    };\n\n    /**\n     * _sanitizeAttributes\n     *\n     * @protect attributes\n     * @protect nodeName\n     * @protect removeAttribute\n     * @protect setAttribute\n     *\n     * @param  {Node} currentNode to sanitize\n     */\n    var _sanitizeAttributes = function _sanitizeAttributes(currentNode) {\n      var attr = void 0;\n      var value = void 0;\n      var lcName = void 0;\n      var l = void 0;\n      /* Execute a hook if present */\n      _executeHook('beforeSanitizeAttributes', currentNode, null);\n\n      var attributes = currentNode.attributes;\n\n      /* Check if we have attributes; if not we might have a text node */\n\n      if (!attributes) {\n        return;\n      }\n\n      var hookEvent = {\n        attrName: '',\n        attrValue: '',\n        keepAttr: true,\n        allowedAttributes: ALLOWED_ATTR\n      };\n      l = attributes.length;\n\n      /* Go backwards over all attributes; safely remove bad ones */\n      while (l--) {\n        attr = attributes[l];\n        var _attr = attr,\n            name = _attr.name,\n            namespaceURI = _attr.namespaceURI;\n\n        value = stringTrim(attr.value);\n        lcName = stringToLowerCase(name);\n\n        /* Execute a hook if present */\n        hookEvent.attrName = lcName;\n        hookEvent.attrValue = value;\n        hookEvent.keepAttr = true;\n        hookEvent.forceKeepAttr = undefined; // Allows developers to see this is a property they can set\n        _executeHook('uponSanitizeAttribute', currentNode, hookEvent);\n        value = hookEvent.attrValue;\n        /* Did the hooks approve of the attribute? */\n        if (hookEvent.forceKeepAttr) {\n          continue;\n        }\n\n        /* Remove attribute */\n        _removeAttribute(name, currentNode);\n\n        /* Did the hooks approve of the attribute? */\n        if (!hookEvent.keepAttr) {\n          continue;\n        }\n\n        /* Work around a security issue in jQuery 3.0 */\n        if (regExpTest(/\\/>/i, value)) {\n          _removeAttribute(name, currentNode);\n          continue;\n        }\n\n        /* Sanitize attribute content to be template-safe */\n        if (SAFE_FOR_TEMPLATES) {\n          value = stringReplace(value, MUSTACHE_EXPR$$1, ' ');\n          value = stringReplace(value, ERB_EXPR$$1, ' ');\n        }\n\n        /* Is `value` valid for this attribute? */\n        var lcTag = currentNode.nodeName.toLowerCase();\n        if (!_isValidAttribute(lcTag, lcName, value)) {\n          continue;\n        }\n\n        /* Handle invalid data-* attribute set by try-catching it */\n        try {\n          if (namespaceURI) {\n            currentNode.setAttributeNS(namespaceURI, name, value);\n          } else {\n            /* Fallback to setAttribute() for browser-unrecognized namespaces e.g. \"x-schema\". */\n            currentNode.setAttribute(name, value);\n          }\n\n          arrayPop(DOMPurify.removed);\n        } catch (_) {}\n      }\n\n      /* Execute a hook if present */\n      _executeHook('afterSanitizeAttributes', currentNode, null);\n    };\n\n    /**\n     * _sanitizeShadowDOM\n     *\n     * @param  {DocumentFragment} fragment to iterate over recursively\n     */\n    var _sanitizeShadowDOM = function _sanitizeShadowDOM(fragment) {\n      var shadowNode = void 0;\n      var shadowIterator = _createIterator(fragment);\n\n      /* Execute a hook if present */\n      _executeHook('beforeSanitizeShadowDOM', fragment, null);\n\n      while (shadowNode = shadowIterator.nextNode()) {\n        /* Execute a hook if present */\n        _executeHook('uponSanitizeShadowNode', shadowNode, null);\n\n        /* Sanitize tags and elements */\n        if (_sanitizeElements(shadowNode)) {\n          continue;\n        }\n\n        /* Deep shadow DOM detected */\n        if (shadowNode.content instanceof DocumentFragment) {\n          _sanitizeShadowDOM(shadowNode.content);\n        }\n\n        /* Check attributes, sanitize if necessary */\n        _sanitizeAttributes(shadowNode);\n      }\n\n      /* Execute a hook if present */\n      _executeHook('afterSanitizeShadowDOM', fragment, null);\n    };\n\n    /**\n     * Sanitize\n     * Public method providing core sanitation functionality\n     *\n     * @param {String|Node} dirty string or DOM node\n     * @param {Object} configuration object\n     */\n    // eslint-disable-next-line complexity\n    DOMPurify.sanitize = function (dirty, cfg) {\n      var body = void 0;\n      var importedNode = void 0;\n      var currentNode = void 0;\n      var oldNode = void 0;\n      var returnNode = void 0;\n      /* Make sure we have a string to sanitize.\n        DO NOT return early, as this will return the wrong type if\n        the user has requested a DOM object rather than a string */\n      if (!dirty) {\n        dirty = '<!-->';\n      }\n\n      /* Stringify, in case dirty is an object */\n      if (typeof dirty !== 'string' && !_isNode(dirty)) {\n        // eslint-disable-next-line no-negated-condition\n        if (typeof dirty.toString !== 'function') {\n          throw typeErrorCreate('toString is not a function');\n        } else {\n          dirty = dirty.toString();\n          if (typeof dirty !== 'string') {\n            throw typeErrorCreate('dirty is not a string, aborting');\n          }\n        }\n      }\n\n      /* Check we can run. Otherwise fall back or ignore */\n      if (!DOMPurify.isSupported) {\n        if (_typeof(window.toStaticHTML) === 'object' || typeof window.toStaticHTML === 'function') {\n          if (typeof dirty === 'string') {\n            return window.toStaticHTML(dirty);\n          }\n\n          if (_isNode(dirty)) {\n            return window.toStaticHTML(dirty.outerHTML);\n          }\n        }\n\n        return dirty;\n      }\n\n      /* Assign config vars */\n      if (!SET_CONFIG) {\n        _parseConfig(cfg);\n      }\n\n      /* Clean up removed elements */\n      DOMPurify.removed = [];\n\n      /* Check if dirty is correctly typed for IN_PLACE */\n      if (typeof dirty === 'string') {\n        IN_PLACE = false;\n      }\n\n      if (IN_PLACE) ; else if (dirty instanceof Node) {\n        /* If dirty is a DOM element, append to an empty document to avoid\n           elements being stripped by the parser */\n        body = _initDocument('<!---->');\n        importedNode = body.ownerDocument.importNode(dirty, true);\n        if (importedNode.nodeType === 1 && importedNode.nodeName === 'BODY') {\n          /* Node is already a body, use as is */\n          body = importedNode;\n        } else if (importedNode.nodeName === 'HTML') {\n          body = importedNode;\n        } else {\n          // eslint-disable-next-line unicorn/prefer-node-append\n          body.appendChild(importedNode);\n        }\n      } else {\n        /* Exit directly if we have nothing to do */\n        if (!RETURN_DOM && !SAFE_FOR_TEMPLATES && !WHOLE_DOCUMENT &&\n        // eslint-disable-next-line unicorn/prefer-includes\n        dirty.indexOf('<') === -1) {\n          return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(dirty) : dirty;\n        }\n\n        /* Initialize the document to work on */\n        body = _initDocument(dirty);\n\n        /* Check we have a DOM node from the data */\n        if (!body) {\n          return RETURN_DOM ? null : emptyHTML;\n        }\n      }\n\n      /* Remove first element node (ours) if FORCE_BODY is set */\n      if (body && FORCE_BODY) {\n        _forceRemove(body.firstChild);\n      }\n\n      /* Get node iterator */\n      var nodeIterator = _createIterator(IN_PLACE ? dirty : body);\n\n      /* Now start iterating over the created document */\n      while (currentNode = nodeIterator.nextNode()) {\n        /* Fix IE's strange behavior with manipulated textNodes #89 */\n        if (currentNode.nodeType === 3 && currentNode === oldNode) {\n          continue;\n        }\n\n        /* Sanitize tags and elements */\n        if (_sanitizeElements(currentNode)) {\n          continue;\n        }\n\n        /* Shadow DOM detected, sanitize it */\n        if (currentNode.content instanceof DocumentFragment) {\n          _sanitizeShadowDOM(currentNode.content);\n        }\n\n        /* Check attributes, sanitize if necessary */\n        _sanitizeAttributes(currentNode);\n\n        oldNode = currentNode;\n      }\n\n      oldNode = null;\n\n      /* If we sanitized `dirty` in-place, return it. */\n      if (IN_PLACE) {\n        return dirty;\n      }\n\n      /* Return sanitized string or DOM */\n      if (RETURN_DOM) {\n        if (RETURN_DOM_FRAGMENT) {\n          returnNode = createDocumentFragment.call(body.ownerDocument);\n\n          while (body.firstChild) {\n            // eslint-disable-next-line unicorn/prefer-node-append\n            returnNode.appendChild(body.firstChild);\n          }\n        } else {\n          returnNode = body;\n        }\n\n        if (RETURN_DOM_IMPORT) {\n          /*\n            AdoptNode() is not used because internal state is not reset\n            (e.g. the past names map of a HTMLFormElement), this is safe\n            in theory but we would rather not risk another attack vector.\n            The state that is cloned by importNode() is explicitly defined\n            by the specs.\n          */\n          returnNode = importNode.call(originalDocument, returnNode, true);\n        }\n\n        return returnNode;\n      }\n\n      var serializedHTML = WHOLE_DOCUMENT ? body.outerHTML : body.innerHTML;\n\n      /* Sanitize final string template-safe */\n      if (SAFE_FOR_TEMPLATES) {\n        serializedHTML = stringReplace(serializedHTML, MUSTACHE_EXPR$$1, ' ');\n        serializedHTML = stringReplace(serializedHTML, ERB_EXPR$$1, ' ');\n      }\n\n      return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(serializedHTML) : serializedHTML;\n    };\n\n    /**\n     * Public method to set the configuration once\n     * setConfig\n     *\n     * @param {Object} cfg configuration object\n     */\n    DOMPurify.setConfig = function (cfg) {\n      _parseConfig(cfg);\n      SET_CONFIG = true;\n    };\n\n    /**\n     * Public method to remove the configuration\n     * clearConfig\n     *\n     */\n    DOMPurify.clearConfig = function () {\n      CONFIG = null;\n      SET_CONFIG = false;\n    };\n\n    /**\n     * Public method to check if an attribute value is valid.\n     * Uses last set config, if any. Otherwise, uses config defaults.\n     * isValidAttribute\n     *\n     * @param  {string} tag Tag name of containing element.\n     * @param  {string} attr Attribute name.\n     * @param  {string} value Attribute value.\n     * @return {Boolean} Returns true if `value` is valid. Otherwise, returns false.\n     */\n    DOMPurify.isValidAttribute = function (tag, attr, value) {\n      /* Initialize shared config vars if necessary. */\n      if (!CONFIG) {\n        _parseConfig({});\n      }\n\n      var lcTag = stringToLowerCase(tag);\n      var lcName = stringToLowerCase(attr);\n      return _isValidAttribute(lcTag, lcName, value);\n    };\n\n    /**\n     * AddHook\n     * Public method to add DOMPurify hooks\n     *\n     * @param {String} entryPoint entry point for the hook to add\n     * @param {Function} hookFunction function to execute\n     */\n    DOMPurify.addHook = function (entryPoint, hookFunction) {\n      if (typeof hookFunction !== 'function') {\n        return;\n      }\n\n      hooks[entryPoint] = hooks[entryPoint] || [];\n      arrayPush(hooks[entryPoint], hookFunction);\n    };\n\n    /**\n     * RemoveHook\n     * Public method to remove a DOMPurify hook at a given entryPoint\n     * (pops it from the stack of hooks if more are present)\n     *\n     * @param {String} entryPoint entry point for the hook to remove\n     */\n    DOMPurify.removeHook = function (entryPoint) {\n      if (hooks[entryPoint]) {\n        arrayPop(hooks[entryPoint]);\n      }\n    };\n\n    /**\n     * RemoveHooks\n     * Public method to remove all DOMPurify hooks at a given entryPoint\n     *\n     * @param  {String} entryPoint entry point for the hooks to remove\n     */\n    DOMPurify.removeHooks = function (entryPoint) {\n      if (hooks[entryPoint]) {\n        hooks[entryPoint] = [];\n      }\n    };\n\n    /**\n     * RemoveAllHooks\n     * Public method to remove all DOMPurify hooks\n     *\n     */\n    DOMPurify.removeAllHooks = function () {\n      hooks = {};\n    };\n\n    return DOMPurify;\n  }\n\n  var purify = createDOMPurify();\n\n  return purify;\n\n}));\n//# sourceMappingURL=purify.js.map\n\n\n//# sourceURL=webpack:////home/marcello/mdb/Code/olojs/node_modules/dompurify/dist/purify.js?");

/***/ }),

/***/ "../../node_modules/get-func-name/index.js":
/*!*************************************************************************!*\
  !*** /home/marcello/mdb/Code/olojs/node_modules/get-func-name/index.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/* !\n * Chai - getFuncName utility\n * Copyright(c) 2012-2016 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\n/**\n * ### .getFuncName(constructorFn)\n *\n * Returns the name of a function.\n * When a non-function instance is passed, returns `null`.\n * This also includes a polyfill function if `aFunc.name` is not defined.\n *\n * @name getFuncName\n * @param {Function} funct\n * @namespace Utils\n * @api public\n */\n\nvar toString = Function.prototype.toString;\nvar functionNameMatch = /\\s*function(?:\\s|\\s*\\/\\*[^(?:*\\/)]+\\*\\/\\s*)*([^\\s\\(\\/]+)/;\nfunction getFuncName(aFunc) {\n  if (typeof aFunc !== 'function') {\n    return null;\n  }\n\n  var name = '';\n  if (typeof Function.prototype.name === 'undefined' && typeof aFunc.name === 'undefined') {\n    // Here we run a polyfill if Function does not support the `name` property and if aFunc.name is not defined\n    var match = toString.call(aFunc).match(functionNameMatch);\n    if (match) {\n      name = match[1];\n    }\n  } else {\n    // If we've got a `name` property we just use it\n    name = aFunc.name;\n  }\n\n  return name;\n}\n\nmodule.exports = getFuncName;\n\n\n//# sourceURL=webpack:////home/marcello/mdb/Code/olojs/node_modules/get-func-name/index.js?");

/***/ }),

/***/ "../../node_modules/isomorphic-fetch/fetch-npm-browserify.js":
/*!*******************************************************************************************!*\
  !*** /home/marcello/mdb/Code/olojs/node_modules/isomorphic-fetch/fetch-npm-browserify.js ***!
  \*******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// the whatwg-fetch polyfill installs the fetch() function\n// on the global object (window or self)\n//\n// Return that as the export for use in Webpack, Browserify etc.\n__webpack_require__(/*! whatwg-fetch */ \"../../node_modules/whatwg-fetch/fetch.js\");\nmodule.exports = self.fetch.bind(self);\n\n\n//# sourceURL=webpack:////home/marcello/mdb/Code/olojs/node_modules/isomorphic-fetch/fetch-npm-browserify.js?");

/***/ }),

/***/ "../../node_modules/path-browserify/index.js":
/*!***************************************************************************!*\
  !*** /home/marcello/mdb/Code/olojs/node_modules/path-browserify/index.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(process) {// .dirname, .basename, and .extname methods are extracted from Node.js v8.11.1,\n// backported and transplited with Babel, with backwards-compat fixes\n\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// resolves . and .. elements in a path array with directory names there\n// must be no slashes, empty elements, or device names (c:\\) in the array\n// (so also no leading and trailing slashes - it does not distinguish\n// relative and absolute paths)\nfunction normalizeArray(parts, allowAboveRoot) {\n  // if the path tries to go above the root, `up` ends up > 0\n  var up = 0;\n  for (var i = parts.length - 1; i >= 0; i--) {\n    var last = parts[i];\n    if (last === '.') {\n      parts.splice(i, 1);\n    } else if (last === '..') {\n      parts.splice(i, 1);\n      up++;\n    } else if (up) {\n      parts.splice(i, 1);\n      up--;\n    }\n  }\n\n  // if the path is allowed to go above the root, restore leading ..s\n  if (allowAboveRoot) {\n    for (; up--; up) {\n      parts.unshift('..');\n    }\n  }\n\n  return parts;\n}\n\n// path.resolve([from ...], to)\n// posix version\nexports.resolve = function() {\n  var resolvedPath = '',\n      resolvedAbsolute = false;\n\n  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n    var path = (i >= 0) ? arguments[i] : process.cwd();\n\n    // Skip empty and invalid entries\n    if (typeof path !== 'string') {\n      throw new TypeError('Arguments to path.resolve must be strings');\n    } else if (!path) {\n      continue;\n    }\n\n    resolvedPath = path + '/' + resolvedPath;\n    resolvedAbsolute = path.charAt(0) === '/';\n  }\n\n  // At this point the path should be resolved to a full absolute path, but\n  // handle relative paths to be safe (might happen when process.cwd() fails)\n\n  // Normalize the path\n  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {\n    return !!p;\n  }), !resolvedAbsolute).join('/');\n\n  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';\n};\n\n// path.normalize(path)\n// posix version\nexports.normalize = function(path) {\n  var isAbsolute = exports.isAbsolute(path),\n      trailingSlash = substr(path, -1) === '/';\n\n  // Normalize the path\n  path = normalizeArray(filter(path.split('/'), function(p) {\n    return !!p;\n  }), !isAbsolute).join('/');\n\n  if (!path && !isAbsolute) {\n    path = '.';\n  }\n  if (path && trailingSlash) {\n    path += '/';\n  }\n\n  return (isAbsolute ? '/' : '') + path;\n};\n\n// posix version\nexports.isAbsolute = function(path) {\n  return path.charAt(0) === '/';\n};\n\n// posix version\nexports.join = function() {\n  var paths = Array.prototype.slice.call(arguments, 0);\n  return exports.normalize(filter(paths, function(p, index) {\n    if (typeof p !== 'string') {\n      throw new TypeError('Arguments to path.join must be strings');\n    }\n    return p;\n  }).join('/'));\n};\n\n\n// path.relative(from, to)\n// posix version\nexports.relative = function(from, to) {\n  from = exports.resolve(from).substr(1);\n  to = exports.resolve(to).substr(1);\n\n  function trim(arr) {\n    var start = 0;\n    for (; start < arr.length; start++) {\n      if (arr[start] !== '') break;\n    }\n\n    var end = arr.length - 1;\n    for (; end >= 0; end--) {\n      if (arr[end] !== '') break;\n    }\n\n    if (start > end) return [];\n    return arr.slice(start, end - start + 1);\n  }\n\n  var fromParts = trim(from.split('/'));\n  var toParts = trim(to.split('/'));\n\n  var length = Math.min(fromParts.length, toParts.length);\n  var samePartsLength = length;\n  for (var i = 0; i < length; i++) {\n    if (fromParts[i] !== toParts[i]) {\n      samePartsLength = i;\n      break;\n    }\n  }\n\n  var outputParts = [];\n  for (var i = samePartsLength; i < fromParts.length; i++) {\n    outputParts.push('..');\n  }\n\n  outputParts = outputParts.concat(toParts.slice(samePartsLength));\n\n  return outputParts.join('/');\n};\n\nexports.sep = '/';\nexports.delimiter = ':';\n\nexports.dirname = function (path) {\n  if (typeof path !== 'string') path = path + '';\n  if (path.length === 0) return '.';\n  var code = path.charCodeAt(0);\n  var hasRoot = code === 47 /*/*/;\n  var end = -1;\n  var matchedSlash = true;\n  for (var i = path.length - 1; i >= 1; --i) {\n    code = path.charCodeAt(i);\n    if (code === 47 /*/*/) {\n        if (!matchedSlash) {\n          end = i;\n          break;\n        }\n      } else {\n      // We saw the first non-path separator\n      matchedSlash = false;\n    }\n  }\n\n  if (end === -1) return hasRoot ? '/' : '.';\n  if (hasRoot && end === 1) {\n    // return '//';\n    // Backwards-compat fix:\n    return '/';\n  }\n  return path.slice(0, end);\n};\n\nfunction basename(path) {\n  if (typeof path !== 'string') path = path + '';\n\n  var start = 0;\n  var end = -1;\n  var matchedSlash = true;\n  var i;\n\n  for (i = path.length - 1; i >= 0; --i) {\n    if (path.charCodeAt(i) === 47 /*/*/) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string, stop now\n        if (!matchedSlash) {\n          start = i + 1;\n          break;\n        }\n      } else if (end === -1) {\n      // We saw the first non-path separator, mark this as the end of our\n      // path component\n      matchedSlash = false;\n      end = i + 1;\n    }\n  }\n\n  if (end === -1) return '';\n  return path.slice(start, end);\n}\n\n// Uses a mixed approach for backwards-compatibility, as ext behavior changed\n// in new Node.js versions, so only basename() above is backported here\nexports.basename = function (path, ext) {\n  var f = basename(path);\n  if (ext && f.substr(-1 * ext.length) === ext) {\n    f = f.substr(0, f.length - ext.length);\n  }\n  return f;\n};\n\nexports.extname = function (path) {\n  if (typeof path !== 'string') path = path + '';\n  var startDot = -1;\n  var startPart = 0;\n  var end = -1;\n  var matchedSlash = true;\n  // Track the state of characters (if any) we see before our first dot and\n  // after any path separator we find\n  var preDotState = 0;\n  for (var i = path.length - 1; i >= 0; --i) {\n    var code = path.charCodeAt(i);\n    if (code === 47 /*/*/) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string, stop now\n        if (!matchedSlash) {\n          startPart = i + 1;\n          break;\n        }\n        continue;\n      }\n    if (end === -1) {\n      // We saw the first non-path separator, mark this as the end of our\n      // extension\n      matchedSlash = false;\n      end = i + 1;\n    }\n    if (code === 46 /*.*/) {\n        // If this is our first dot, mark it as the start of our extension\n        if (startDot === -1)\n          startDot = i;\n        else if (preDotState !== 1)\n          preDotState = 1;\n    } else if (startDot !== -1) {\n      // We saw a non-dot and non-path separator before our dot, so we should\n      // have a good chance at having a non-empty extension\n      preDotState = -1;\n    }\n  }\n\n  if (startDot === -1 || end === -1 ||\n      // We saw a non-dot character immediately before the dot\n      preDotState === 0 ||\n      // The (right-most) trimmed path component is exactly '..'\n      preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n    return '';\n  }\n  return path.slice(startDot, end);\n};\n\nfunction filter (xs, f) {\n    if (xs.filter) return xs.filter(f);\n    var res = [];\n    for (var i = 0; i < xs.length; i++) {\n        if (f(xs[i], i, xs)) res.push(xs[i]);\n    }\n    return res;\n}\n\n// String.prototype.substr - negative index don't work in IE8\nvar substr = 'ab'.substr(-1) === 'b'\n    ? function (str, start, len) { return str.substr(start, len) }\n    : function (str, start, len) {\n        if (start < 0) start = str.length + start;\n        return str.substr(start, len);\n    }\n;\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../process/browser.js */ \"../../node_modules/process/browser.js\")))\n\n//# sourceURL=webpack:////home/marcello/mdb/Code/olojs/node_modules/path-browserify/index.js?");

/***/ }),

/***/ "../../node_modules/pathval/index.js":
/*!*******************************************************************!*\
  !*** /home/marcello/mdb/Code/olojs/node_modules/pathval/index.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/* !\n * Chai - pathval utility\n * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n * @see https://github.com/logicalparadox/filtr\n * MIT Licensed\n */\n\n/**\n * ### .hasProperty(object, name)\n *\n * This allows checking whether an object has own\n * or inherited from prototype chain named property.\n *\n * Basically does the same thing as the `in`\n * operator but works properly with null/undefined values\n * and other primitives.\n *\n *     var obj = {\n *         arr: ['a', 'b', 'c']\n *       , str: 'Hello'\n *     }\n *\n * The following would be the results.\n *\n *     hasProperty(obj, 'str');  // true\n *     hasProperty(obj, 'constructor');  // true\n *     hasProperty(obj, 'bar');  // false\n *\n *     hasProperty(obj.str, 'length'); // true\n *     hasProperty(obj.str, 1);  // true\n *     hasProperty(obj.str, 5);  // false\n *\n *     hasProperty(obj.arr, 'length');  // true\n *     hasProperty(obj.arr, 2);  // true\n *     hasProperty(obj.arr, 3);  // false\n *\n * @param {Object} object\n * @param {String|Symbol} name\n * @returns {Boolean} whether it exists\n * @namespace Utils\n * @name hasProperty\n * @api public\n */\n\nfunction hasProperty(obj, name) {\n  if (typeof obj === 'undefined' || obj === null) {\n    return false;\n  }\n\n  // The `in` operator does not work with primitives.\n  return name in Object(obj);\n}\n\n/* !\n * ## parsePath(path)\n *\n * Helper function used to parse string object\n * paths. Use in conjunction with `internalGetPathValue`.\n *\n *      var parsed = parsePath('myobject.property.subprop');\n *\n * ### Paths:\n *\n * * Can be infinitely deep and nested.\n * * Arrays are also valid using the formal `myobject.document[3].property`.\n * * Literal dots and brackets (not delimiter) must be backslash-escaped.\n *\n * @param {String} path\n * @returns {Object} parsed\n * @api private\n */\n\nfunction parsePath(path) {\n  var str = path.replace(/([^\\\\])\\[/g, '$1.[');\n  var parts = str.match(/(\\\\\\.|[^.]+?)+/g);\n  return parts.map(function mapMatches(value) {\n    var regexp = /^\\[(\\d+)\\]$/;\n    var mArr = regexp.exec(value);\n    var parsed = null;\n    if (mArr) {\n      parsed = { i: parseFloat(mArr[1]) };\n    } else {\n      parsed = { p: value.replace(/\\\\([.\\[\\]])/g, '$1') };\n    }\n\n    return parsed;\n  });\n}\n\n/* !\n * ## internalGetPathValue(obj, parsed[, pathDepth])\n *\n * Helper companion function for `.parsePath` that returns\n * the value located at the parsed address.\n *\n *      var value = getPathValue(obj, parsed);\n *\n * @param {Object} object to search against\n * @param {Object} parsed definition from `parsePath`.\n * @param {Number} depth (nesting level) of the property we want to retrieve\n * @returns {Object|Undefined} value\n * @api private\n */\n\nfunction internalGetPathValue(obj, parsed, pathDepth) {\n  var temporaryValue = obj;\n  var res = null;\n  pathDepth = (typeof pathDepth === 'undefined' ? parsed.length : pathDepth);\n\n  for (var i = 0; i < pathDepth; i++) {\n    var part = parsed[i];\n    if (temporaryValue) {\n      if (typeof part.p === 'undefined') {\n        temporaryValue = temporaryValue[part.i];\n      } else {\n        temporaryValue = temporaryValue[part.p];\n      }\n\n      if (i === (pathDepth - 1)) {\n        res = temporaryValue;\n      }\n    }\n  }\n\n  return res;\n}\n\n/* !\n * ## internalSetPathValue(obj, value, parsed)\n *\n * Companion function for `parsePath` that sets\n * the value located at a parsed address.\n *\n *  internalSetPathValue(obj, 'value', parsed);\n *\n * @param {Object} object to search and define on\n * @param {*} value to use upon set\n * @param {Object} parsed definition from `parsePath`\n * @api private\n */\n\nfunction internalSetPathValue(obj, val, parsed) {\n  var tempObj = obj;\n  var pathDepth = parsed.length;\n  var part = null;\n  // Here we iterate through every part of the path\n  for (var i = 0; i < pathDepth; i++) {\n    var propName = null;\n    var propVal = null;\n    part = parsed[i];\n\n    // If it's the last part of the path, we set the 'propName' value with the property name\n    if (i === (pathDepth - 1)) {\n      propName = typeof part.p === 'undefined' ? part.i : part.p;\n      // Now we set the property with the name held by 'propName' on object with the desired val\n      tempObj[propName] = val;\n    } else if (typeof part.p !== 'undefined' && tempObj[part.p]) {\n      tempObj = tempObj[part.p];\n    } else if (typeof part.i !== 'undefined' && tempObj[part.i]) {\n      tempObj = tempObj[part.i];\n    } else {\n      // If the obj doesn't have the property we create one with that name to define it\n      var next = parsed[i + 1];\n      // Here we set the name of the property which will be defined\n      propName = typeof part.p === 'undefined' ? part.i : part.p;\n      // Here we decide if this property will be an array or a new object\n      propVal = typeof next.p === 'undefined' ? [] : {};\n      tempObj[propName] = propVal;\n      tempObj = tempObj[propName];\n    }\n  }\n}\n\n/**\n * ### .getPathInfo(object, path)\n *\n * This allows the retrieval of property info in an\n * object given a string path.\n *\n * The path info consists of an object with the\n * following properties:\n *\n * * parent - The parent object of the property referenced by `path`\n * * name - The name of the final property, a number if it was an array indexer\n * * value - The value of the property, if it exists, otherwise `undefined`\n * * exists - Whether the property exists or not\n *\n * @param {Object} object\n * @param {String} path\n * @returns {Object} info\n * @namespace Utils\n * @name getPathInfo\n * @api public\n */\n\nfunction getPathInfo(obj, path) {\n  var parsed = parsePath(path);\n  var last = parsed[parsed.length - 1];\n  var info = {\n    parent: parsed.length > 1 ? internalGetPathValue(obj, parsed, parsed.length - 1) : obj,\n    name: last.p || last.i,\n    value: internalGetPathValue(obj, parsed),\n  };\n  info.exists = hasProperty(info.parent, info.name);\n\n  return info;\n}\n\n/**\n * ### .getPathValue(object, path)\n *\n * This allows the retrieval of values in an\n * object given a string path.\n *\n *     var obj = {\n *         prop1: {\n *             arr: ['a', 'b', 'c']\n *           , str: 'Hello'\n *         }\n *       , prop2: {\n *             arr: [ { nested: 'Universe' } ]\n *           , str: 'Hello again!'\n *         }\n *     }\n *\n * The following would be the results.\n *\n *     getPathValue(obj, 'prop1.str'); // Hello\n *     getPathValue(obj, 'prop1.att[2]'); // b\n *     getPathValue(obj, 'prop2.arr[0].nested'); // Universe\n *\n * @param {Object} object\n * @param {String} path\n * @returns {Object} value or `undefined`\n * @namespace Utils\n * @name getPathValue\n * @api public\n */\n\nfunction getPathValue(obj, path) {\n  var info = getPathInfo(obj, path);\n  return info.value;\n}\n\n/**\n * ### .setPathValue(object, path, value)\n *\n * Define the value in an object at a given string path.\n *\n * ```js\n * var obj = {\n *     prop1: {\n *         arr: ['a', 'b', 'c']\n *       , str: 'Hello'\n *     }\n *   , prop2: {\n *         arr: [ { nested: 'Universe' } ]\n *       , str: 'Hello again!'\n *     }\n * };\n * ```\n *\n * The following would be acceptable.\n *\n * ```js\n * var properties = require('tea-properties');\n * properties.set(obj, 'prop1.str', 'Hello Universe!');\n * properties.set(obj, 'prop1.arr[2]', 'B');\n * properties.set(obj, 'prop2.arr[0].nested.value', { hello: 'universe' });\n * ```\n *\n * @param {Object} object\n * @param {String} path\n * @param {Mixed} value\n * @api private\n */\n\nfunction setPathValue(obj, path, val) {\n  var parsed = parsePath(path);\n  internalSetPathValue(obj, val, parsed);\n  return obj;\n}\n\nmodule.exports = {\n  hasProperty: hasProperty,\n  getPathInfo: getPathInfo,\n  getPathValue: getPathValue,\n  setPathValue: setPathValue,\n};\n\n\n//# sourceURL=webpack:////home/marcello/mdb/Code/olojs/node_modules/pathval/index.js?");

/***/ }),

/***/ "../../node_modules/process/browser.js":
/*!*********************************************************************!*\
  !*** /home/marcello/mdb/Code/olojs/node_modules/process/browser.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n//# sourceURL=webpack:////home/marcello/mdb/Code/olojs/node_modules/process/browser.js?");

/***/ }),

/***/ "../../node_modules/type-detect/type-detect.js":
/*!*****************************************************************************!*\
  !*** /home/marcello/mdb/Code/olojs/node_modules/type-detect/type-detect.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global) {(function (global, factory) {\n\t true ? module.exports = factory() :\n\tundefined;\n}(this, (function () { 'use strict';\n\n/* !\n * type-detect\n * Copyright(c) 2013 jake luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\nvar promiseExists = typeof Promise === 'function';\n\n/* eslint-disable no-undef */\nvar globalObject = typeof self === 'object' ? self : global; // eslint-disable-line id-blacklist\n\nvar symbolExists = typeof Symbol !== 'undefined';\nvar mapExists = typeof Map !== 'undefined';\nvar setExists = typeof Set !== 'undefined';\nvar weakMapExists = typeof WeakMap !== 'undefined';\nvar weakSetExists = typeof WeakSet !== 'undefined';\nvar dataViewExists = typeof DataView !== 'undefined';\nvar symbolIteratorExists = symbolExists && typeof Symbol.iterator !== 'undefined';\nvar symbolToStringTagExists = symbolExists && typeof Symbol.toStringTag !== 'undefined';\nvar setEntriesExists = setExists && typeof Set.prototype.entries === 'function';\nvar mapEntriesExists = mapExists && typeof Map.prototype.entries === 'function';\nvar setIteratorPrototype = setEntriesExists && Object.getPrototypeOf(new Set().entries());\nvar mapIteratorPrototype = mapEntriesExists && Object.getPrototypeOf(new Map().entries());\nvar arrayIteratorExists = symbolIteratorExists && typeof Array.prototype[Symbol.iterator] === 'function';\nvar arrayIteratorPrototype = arrayIteratorExists && Object.getPrototypeOf([][Symbol.iterator]());\nvar stringIteratorExists = symbolIteratorExists && typeof String.prototype[Symbol.iterator] === 'function';\nvar stringIteratorPrototype = stringIteratorExists && Object.getPrototypeOf(''[Symbol.iterator]());\nvar toStringLeftSliceLength = 8;\nvar toStringRightSliceLength = -1;\n/**\n * ### typeOf (obj)\n *\n * Uses `Object.prototype.toString` to determine the type of an object,\n * normalising behaviour across engine versions & well optimised.\n *\n * @param {Mixed} object\n * @return {String} object type\n * @api public\n */\nfunction typeDetect(obj) {\n  /* ! Speed optimisation\n   * Pre:\n   *   string literal     x 3,039,035 ops/sec 1.62% (78 runs sampled)\n   *   boolean literal    x 1,424,138 ops/sec 4.54% (75 runs sampled)\n   *   number literal     x 1,653,153 ops/sec 1.91% (82 runs sampled)\n   *   undefined          x 9,978,660 ops/sec 1.92% (75 runs sampled)\n   *   function           x 2,556,769 ops/sec 1.73% (77 runs sampled)\n   * Post:\n   *   string literal     x 38,564,796 ops/sec 1.15% (79 runs sampled)\n   *   boolean literal    x 31,148,940 ops/sec 1.10% (79 runs sampled)\n   *   number literal     x 32,679,330 ops/sec 1.90% (78 runs sampled)\n   *   undefined          x 32,363,368 ops/sec 1.07% (82 runs sampled)\n   *   function           x 31,296,870 ops/sec 0.96% (83 runs sampled)\n   */\n  var typeofObj = typeof obj;\n  if (typeofObj !== 'object') {\n    return typeofObj;\n  }\n\n  /* ! Speed optimisation\n   * Pre:\n   *   null               x 28,645,765 ops/sec 1.17% (82 runs sampled)\n   * Post:\n   *   null               x 36,428,962 ops/sec 1.37% (84 runs sampled)\n   */\n  if (obj === null) {\n    return 'null';\n  }\n\n  /* ! Spec Conformance\n   * Test: `Object.prototype.toString.call(window)``\n   *  - Node === \"[object global]\"\n   *  - Chrome === \"[object global]\"\n   *  - Firefox === \"[object Window]\"\n   *  - PhantomJS === \"[object Window]\"\n   *  - Safari === \"[object Window]\"\n   *  - IE 11 === \"[object Window]\"\n   *  - IE Edge === \"[object Window]\"\n   * Test: `Object.prototype.toString.call(this)``\n   *  - Chrome Worker === \"[object global]\"\n   *  - Firefox Worker === \"[object DedicatedWorkerGlobalScope]\"\n   *  - Safari Worker === \"[object DedicatedWorkerGlobalScope]\"\n   *  - IE 11 Worker === \"[object WorkerGlobalScope]\"\n   *  - IE Edge Worker === \"[object WorkerGlobalScope]\"\n   */\n  if (obj === globalObject) {\n    return 'global';\n  }\n\n  /* ! Speed optimisation\n   * Pre:\n   *   array literal      x 2,888,352 ops/sec 0.67% (82 runs sampled)\n   * Post:\n   *   array literal      x 22,479,650 ops/sec 0.96% (81 runs sampled)\n   */\n  if (\n    Array.isArray(obj) &&\n    (symbolToStringTagExists === false || !(Symbol.toStringTag in obj))\n  ) {\n    return 'Array';\n  }\n\n  // Not caching existence of `window` and related properties due to potential\n  // for `window` to be unset before tests in quasi-browser environments.\n  if (typeof window === 'object' && window !== null) {\n    /* ! Spec Conformance\n     * (https://html.spec.whatwg.org/multipage/browsers.html#location)\n     * WhatWG HTML$7.7.3 - The `Location` interface\n     * Test: `Object.prototype.toString.call(window.location)``\n     *  - IE <=11 === \"[object Object]\"\n     *  - IE Edge <=13 === \"[object Object]\"\n     */\n    if (typeof window.location === 'object' && obj === window.location) {\n      return 'Location';\n    }\n\n    /* ! Spec Conformance\n     * (https://html.spec.whatwg.org/#document)\n     * WhatWG HTML$3.1.1 - The `Document` object\n     * Note: Most browsers currently adher to the W3C DOM Level 2 spec\n     *       (https://www.w3.org/TR/DOM-Level-2-HTML/html.html#ID-26809268)\n     *       which suggests that browsers should use HTMLTableCellElement for\n     *       both TD and TH elements. WhatWG separates these.\n     *       WhatWG HTML states:\n     *         > For historical reasons, Window objects must also have a\n     *         > writable, configurable, non-enumerable property named\n     *         > HTMLDocument whose value is the Document interface object.\n     * Test: `Object.prototype.toString.call(document)``\n     *  - Chrome === \"[object HTMLDocument]\"\n     *  - Firefox === \"[object HTMLDocument]\"\n     *  - Safari === \"[object HTMLDocument]\"\n     *  - IE <=10 === \"[object Document]\"\n     *  - IE 11 === \"[object HTMLDocument]\"\n     *  - IE Edge <=13 === \"[object HTMLDocument]\"\n     */\n    if (typeof window.document === 'object' && obj === window.document) {\n      return 'Document';\n    }\n\n    if (typeof window.navigator === 'object') {\n      /* ! Spec Conformance\n       * (https://html.spec.whatwg.org/multipage/webappapis.html#mimetypearray)\n       * WhatWG HTML$8.6.1.5 - Plugins - Interface MimeTypeArray\n       * Test: `Object.prototype.toString.call(navigator.mimeTypes)``\n       *  - IE <=10 === \"[object MSMimeTypesCollection]\"\n       */\n      if (typeof window.navigator.mimeTypes === 'object' &&\n          obj === window.navigator.mimeTypes) {\n        return 'MimeTypeArray';\n      }\n\n      /* ! Spec Conformance\n       * (https://html.spec.whatwg.org/multipage/webappapis.html#pluginarray)\n       * WhatWG HTML$8.6.1.5 - Plugins - Interface PluginArray\n       * Test: `Object.prototype.toString.call(navigator.plugins)``\n       *  - IE <=10 === \"[object MSPluginsCollection]\"\n       */\n      if (typeof window.navigator.plugins === 'object' &&\n          obj === window.navigator.plugins) {\n        return 'PluginArray';\n      }\n    }\n\n    if ((typeof window.HTMLElement === 'function' ||\n        typeof window.HTMLElement === 'object') &&\n        obj instanceof window.HTMLElement) {\n      /* ! Spec Conformance\n      * (https://html.spec.whatwg.org/multipage/webappapis.html#pluginarray)\n      * WhatWG HTML$4.4.4 - The `blockquote` element - Interface `HTMLQuoteElement`\n      * Test: `Object.prototype.toString.call(document.createElement('blockquote'))``\n      *  - IE <=10 === \"[object HTMLBlockElement]\"\n      */\n      if (obj.tagName === 'BLOCKQUOTE') {\n        return 'HTMLQuoteElement';\n      }\n\n      /* ! Spec Conformance\n       * (https://html.spec.whatwg.org/#htmltabledatacellelement)\n       * WhatWG HTML$4.9.9 - The `td` element - Interface `HTMLTableDataCellElement`\n       * Note: Most browsers currently adher to the W3C DOM Level 2 spec\n       *       (https://www.w3.org/TR/DOM-Level-2-HTML/html.html#ID-82915075)\n       *       which suggests that browsers should use HTMLTableCellElement for\n       *       both TD and TH elements. WhatWG separates these.\n       * Test: Object.prototype.toString.call(document.createElement('td'))\n       *  - Chrome === \"[object HTMLTableCellElement]\"\n       *  - Firefox === \"[object HTMLTableCellElement]\"\n       *  - Safari === \"[object HTMLTableCellElement]\"\n       */\n      if (obj.tagName === 'TD') {\n        return 'HTMLTableDataCellElement';\n      }\n\n      /* ! Spec Conformance\n       * (https://html.spec.whatwg.org/#htmltableheadercellelement)\n       * WhatWG HTML$4.9.9 - The `td` element - Interface `HTMLTableHeaderCellElement`\n       * Note: Most browsers currently adher to the W3C DOM Level 2 spec\n       *       (https://www.w3.org/TR/DOM-Level-2-HTML/html.html#ID-82915075)\n       *       which suggests that browsers should use HTMLTableCellElement for\n       *       both TD and TH elements. WhatWG separates these.\n       * Test: Object.prototype.toString.call(document.createElement('th'))\n       *  - Chrome === \"[object HTMLTableCellElement]\"\n       *  - Firefox === \"[object HTMLTableCellElement]\"\n       *  - Safari === \"[object HTMLTableCellElement]\"\n       */\n      if (obj.tagName === 'TH') {\n        return 'HTMLTableHeaderCellElement';\n      }\n    }\n  }\n\n  /* ! Speed optimisation\n  * Pre:\n  *   Float64Array       x 625,644 ops/sec 1.58% (80 runs sampled)\n  *   Float32Array       x 1,279,852 ops/sec 2.91% (77 runs sampled)\n  *   Uint32Array        x 1,178,185 ops/sec 1.95% (83 runs sampled)\n  *   Uint16Array        x 1,008,380 ops/sec 2.25% (80 runs sampled)\n  *   Uint8Array         x 1,128,040 ops/sec 2.11% (81 runs sampled)\n  *   Int32Array         x 1,170,119 ops/sec 2.88% (80 runs sampled)\n  *   Int16Array         x 1,176,348 ops/sec 5.79% (86 runs sampled)\n  *   Int8Array          x 1,058,707 ops/sec 4.94% (77 runs sampled)\n  *   Uint8ClampedArray  x 1,110,633 ops/sec 4.20% (80 runs sampled)\n  * Post:\n  *   Float64Array       x 7,105,671 ops/sec 13.47% (64 runs sampled)\n  *   Float32Array       x 5,887,912 ops/sec 1.46% (82 runs sampled)\n  *   Uint32Array        x 6,491,661 ops/sec 1.76% (79 runs sampled)\n  *   Uint16Array        x 6,559,795 ops/sec 1.67% (82 runs sampled)\n  *   Uint8Array         x 6,463,966 ops/sec 1.43% (85 runs sampled)\n  *   Int32Array         x 5,641,841 ops/sec 3.49% (81 runs sampled)\n  *   Int16Array         x 6,583,511 ops/sec 1.98% (80 runs sampled)\n  *   Int8Array          x 6,606,078 ops/sec 1.74% (81 runs sampled)\n  *   Uint8ClampedArray  x 6,602,224 ops/sec 1.77% (83 runs sampled)\n  */\n  var stringTag = (symbolToStringTagExists && obj[Symbol.toStringTag]);\n  if (typeof stringTag === 'string') {\n    return stringTag;\n  }\n\n  var objPrototype = Object.getPrototypeOf(obj);\n  /* ! Speed optimisation\n  * Pre:\n  *   regex literal      x 1,772,385 ops/sec 1.85% (77 runs sampled)\n  *   regex constructor  x 2,143,634 ops/sec 2.46% (78 runs sampled)\n  * Post:\n  *   regex literal      x 3,928,009 ops/sec 0.65% (78 runs sampled)\n  *   regex constructor  x 3,931,108 ops/sec 0.58% (84 runs sampled)\n  */\n  if (objPrototype === RegExp.prototype) {\n    return 'RegExp';\n  }\n\n  /* ! Speed optimisation\n  * Pre:\n  *   date               x 2,130,074 ops/sec 4.42% (68 runs sampled)\n  * Post:\n  *   date               x 3,953,779 ops/sec 1.35% (77 runs sampled)\n  */\n  if (objPrototype === Date.prototype) {\n    return 'Date';\n  }\n\n  /* ! Spec Conformance\n   * (http://www.ecma-international.org/ecma-262/6.0/index.html#sec-promise.prototype-@@tostringtag)\n   * ES6$25.4.5.4 - Promise.prototype[@@toStringTag] should be \"Promise\":\n   * Test: `Object.prototype.toString.call(Promise.resolve())``\n   *  - Chrome <=47 === \"[object Object]\"\n   *  - Edge <=20 === \"[object Object]\"\n   *  - Firefox 29-Latest === \"[object Promise]\"\n   *  - Safari 7.1-Latest === \"[object Promise]\"\n   */\n  if (promiseExists && objPrototype === Promise.prototype) {\n    return 'Promise';\n  }\n\n  /* ! Speed optimisation\n  * Pre:\n  *   set                x 2,222,186 ops/sec 1.31% (82 runs sampled)\n  * Post:\n  *   set                x 4,545,879 ops/sec 1.13% (83 runs sampled)\n  */\n  if (setExists && objPrototype === Set.prototype) {\n    return 'Set';\n  }\n\n  /* ! Speed optimisation\n  * Pre:\n  *   map                x 2,396,842 ops/sec 1.59% (81 runs sampled)\n  * Post:\n  *   map                x 4,183,945 ops/sec 6.59% (82 runs sampled)\n  */\n  if (mapExists && objPrototype === Map.prototype) {\n    return 'Map';\n  }\n\n  /* ! Speed optimisation\n  * Pre:\n  *   weakset            x 1,323,220 ops/sec 2.17% (76 runs sampled)\n  * Post:\n  *   weakset            x 4,237,510 ops/sec 2.01% (77 runs sampled)\n  */\n  if (weakSetExists && objPrototype === WeakSet.prototype) {\n    return 'WeakSet';\n  }\n\n  /* ! Speed optimisation\n  * Pre:\n  *   weakmap            x 1,500,260 ops/sec 2.02% (78 runs sampled)\n  * Post:\n  *   weakmap            x 3,881,384 ops/sec 1.45% (82 runs sampled)\n  */\n  if (weakMapExists && objPrototype === WeakMap.prototype) {\n    return 'WeakMap';\n  }\n\n  /* ! Spec Conformance\n   * (http://www.ecma-international.org/ecma-262/6.0/index.html#sec-dataview.prototype-@@tostringtag)\n   * ES6$24.2.4.21 - DataView.prototype[@@toStringTag] should be \"DataView\":\n   * Test: `Object.prototype.toString.call(new DataView(new ArrayBuffer(1)))``\n   *  - Edge <=13 === \"[object Object]\"\n   */\n  if (dataViewExists && objPrototype === DataView.prototype) {\n    return 'DataView';\n  }\n\n  /* ! Spec Conformance\n   * (http://www.ecma-international.org/ecma-262/6.0/index.html#sec-%mapiteratorprototype%-@@tostringtag)\n   * ES6$23.1.5.2.2 - %MapIteratorPrototype%[@@toStringTag] should be \"Map Iterator\":\n   * Test: `Object.prototype.toString.call(new Map().entries())``\n   *  - Edge <=13 === \"[object Object]\"\n   */\n  if (mapExists && objPrototype === mapIteratorPrototype) {\n    return 'Map Iterator';\n  }\n\n  /* ! Spec Conformance\n   * (http://www.ecma-international.org/ecma-262/6.0/index.html#sec-%setiteratorprototype%-@@tostringtag)\n   * ES6$23.2.5.2.2 - %SetIteratorPrototype%[@@toStringTag] should be \"Set Iterator\":\n   * Test: `Object.prototype.toString.call(new Set().entries())``\n   *  - Edge <=13 === \"[object Object]\"\n   */\n  if (setExists && objPrototype === setIteratorPrototype) {\n    return 'Set Iterator';\n  }\n\n  /* ! Spec Conformance\n   * (http://www.ecma-international.org/ecma-262/6.0/index.html#sec-%arrayiteratorprototype%-@@tostringtag)\n   * ES6$22.1.5.2.2 - %ArrayIteratorPrototype%[@@toStringTag] should be \"Array Iterator\":\n   * Test: `Object.prototype.toString.call([][Symbol.iterator]())``\n   *  - Edge <=13 === \"[object Object]\"\n   */\n  if (arrayIteratorExists && objPrototype === arrayIteratorPrototype) {\n    return 'Array Iterator';\n  }\n\n  /* ! Spec Conformance\n   * (http://www.ecma-international.org/ecma-262/6.0/index.html#sec-%stringiteratorprototype%-@@tostringtag)\n   * ES6$21.1.5.2.2 - %StringIteratorPrototype%[@@toStringTag] should be \"String Iterator\":\n   * Test: `Object.prototype.toString.call(''[Symbol.iterator]())``\n   *  - Edge <=13 === \"[object Object]\"\n   */\n  if (stringIteratorExists && objPrototype === stringIteratorPrototype) {\n    return 'String Iterator';\n  }\n\n  /* ! Speed optimisation\n  * Pre:\n  *   object from null   x 2,424,320 ops/sec 1.67% (76 runs sampled)\n  * Post:\n  *   object from null   x 5,838,000 ops/sec 0.99% (84 runs sampled)\n  */\n  if (objPrototype === null) {\n    return 'Object';\n  }\n\n  return Object\n    .prototype\n    .toString\n    .call(obj)\n    .slice(toStringLeftSliceLength, toStringRightSliceLength);\n}\n\nreturn typeDetect;\n\n})));\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ \"../../node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack:////home/marcello/mdb/Code/olojs/node_modules/type-detect/type-detect.js?");

/***/ }),

/***/ "../../node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n\n\n//# sourceURL=webpack:///(webpack)/buildin/global.js?");

/***/ }),

/***/ "../../node_modules/whatwg-fetch/fetch.js":
/*!************************************************************************!*\
  !*** /home/marcello/mdb/Code/olojs/node_modules/whatwg-fetch/fetch.js ***!
  \************************************************************************/
/*! exports provided: Headers, Request, Response, DOMException, fetch */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Headers\", function() { return Headers; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Request\", function() { return Request; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Response\", function() { return Response; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DOMException\", function() { return DOMException; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fetch\", function() { return fetch; });\nvar global =\n  (typeof globalThis !== 'undefined' && globalThis) ||\n  (typeof self !== 'undefined' && self) ||\n  (typeof global !== 'undefined' && global)\n\nvar support = {\n  searchParams: 'URLSearchParams' in global,\n  iterable: 'Symbol' in global && 'iterator' in Symbol,\n  blob:\n    'FileReader' in global &&\n    'Blob' in global &&\n    (function() {\n      try {\n        new Blob()\n        return true\n      } catch (e) {\n        return false\n      }\n    })(),\n  formData: 'FormData' in global,\n  arrayBuffer: 'ArrayBuffer' in global\n}\n\nfunction isDataView(obj) {\n  return obj && DataView.prototype.isPrototypeOf(obj)\n}\n\nif (support.arrayBuffer) {\n  var viewClasses = [\n    '[object Int8Array]',\n    '[object Uint8Array]',\n    '[object Uint8ClampedArray]',\n    '[object Int16Array]',\n    '[object Uint16Array]',\n    '[object Int32Array]',\n    '[object Uint32Array]',\n    '[object Float32Array]',\n    '[object Float64Array]'\n  ]\n\n  var isArrayBufferView =\n    ArrayBuffer.isView ||\n    function(obj) {\n      return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1\n    }\n}\n\nfunction normalizeName(name) {\n  if (typeof name !== 'string') {\n    name = String(name)\n  }\n  if (/[^a-z0-9\\-#$%&'*+.^_`|~!]/i.test(name) || name === '') {\n    throw new TypeError('Invalid character in header field name')\n  }\n  return name.toLowerCase()\n}\n\nfunction normalizeValue(value) {\n  if (typeof value !== 'string') {\n    value = String(value)\n  }\n  return value\n}\n\n// Build a destructive iterator for the value list\nfunction iteratorFor(items) {\n  var iterator = {\n    next: function() {\n      var value = items.shift()\n      return {done: value === undefined, value: value}\n    }\n  }\n\n  if (support.iterable) {\n    iterator[Symbol.iterator] = function() {\n      return iterator\n    }\n  }\n\n  return iterator\n}\n\nfunction Headers(headers) {\n  this.map = {}\n\n  if (headers instanceof Headers) {\n    headers.forEach(function(value, name) {\n      this.append(name, value)\n    }, this)\n  } else if (Array.isArray(headers)) {\n    headers.forEach(function(header) {\n      this.append(header[0], header[1])\n    }, this)\n  } else if (headers) {\n    Object.getOwnPropertyNames(headers).forEach(function(name) {\n      this.append(name, headers[name])\n    }, this)\n  }\n}\n\nHeaders.prototype.append = function(name, value) {\n  name = normalizeName(name)\n  value = normalizeValue(value)\n  var oldValue = this.map[name]\n  this.map[name] = oldValue ? oldValue + ', ' + value : value\n}\n\nHeaders.prototype['delete'] = function(name) {\n  delete this.map[normalizeName(name)]\n}\n\nHeaders.prototype.get = function(name) {\n  name = normalizeName(name)\n  return this.has(name) ? this.map[name] : null\n}\n\nHeaders.prototype.has = function(name) {\n  return this.map.hasOwnProperty(normalizeName(name))\n}\n\nHeaders.prototype.set = function(name, value) {\n  this.map[normalizeName(name)] = normalizeValue(value)\n}\n\nHeaders.prototype.forEach = function(callback, thisArg) {\n  for (var name in this.map) {\n    if (this.map.hasOwnProperty(name)) {\n      callback.call(thisArg, this.map[name], name, this)\n    }\n  }\n}\n\nHeaders.prototype.keys = function() {\n  var items = []\n  this.forEach(function(value, name) {\n    items.push(name)\n  })\n  return iteratorFor(items)\n}\n\nHeaders.prototype.values = function() {\n  var items = []\n  this.forEach(function(value) {\n    items.push(value)\n  })\n  return iteratorFor(items)\n}\n\nHeaders.prototype.entries = function() {\n  var items = []\n  this.forEach(function(value, name) {\n    items.push([name, value])\n  })\n  return iteratorFor(items)\n}\n\nif (support.iterable) {\n  Headers.prototype[Symbol.iterator] = Headers.prototype.entries\n}\n\nfunction consumed(body) {\n  if (body.bodyUsed) {\n    return Promise.reject(new TypeError('Already read'))\n  }\n  body.bodyUsed = true\n}\n\nfunction fileReaderReady(reader) {\n  return new Promise(function(resolve, reject) {\n    reader.onload = function() {\n      resolve(reader.result)\n    }\n    reader.onerror = function() {\n      reject(reader.error)\n    }\n  })\n}\n\nfunction readBlobAsArrayBuffer(blob) {\n  var reader = new FileReader()\n  var promise = fileReaderReady(reader)\n  reader.readAsArrayBuffer(blob)\n  return promise\n}\n\nfunction readBlobAsText(blob) {\n  var reader = new FileReader()\n  var promise = fileReaderReady(reader)\n  reader.readAsText(blob)\n  return promise\n}\n\nfunction readArrayBufferAsText(buf) {\n  var view = new Uint8Array(buf)\n  var chars = new Array(view.length)\n\n  for (var i = 0; i < view.length; i++) {\n    chars[i] = String.fromCharCode(view[i])\n  }\n  return chars.join('')\n}\n\nfunction bufferClone(buf) {\n  if (buf.slice) {\n    return buf.slice(0)\n  } else {\n    var view = new Uint8Array(buf.byteLength)\n    view.set(new Uint8Array(buf))\n    return view.buffer\n  }\n}\n\nfunction Body() {\n  this.bodyUsed = false\n\n  this._initBody = function(body) {\n    /*\n      fetch-mock wraps the Response object in an ES6 Proxy to\n      provide useful test harness features such as flush. However, on\n      ES5 browsers without fetch or Proxy support pollyfills must be used;\n      the proxy-pollyfill is unable to proxy an attribute unless it exists\n      on the object before the Proxy is created. This change ensures\n      Response.bodyUsed exists on the instance, while maintaining the\n      semantic of setting Request.bodyUsed in the constructor before\n      _initBody is called.\n    */\n    this.bodyUsed = this.bodyUsed\n    this._bodyInit = body\n    if (!body) {\n      this._bodyText = ''\n    } else if (typeof body === 'string') {\n      this._bodyText = body\n    } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {\n      this._bodyBlob = body\n    } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {\n      this._bodyFormData = body\n    } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n      this._bodyText = body.toString()\n    } else if (support.arrayBuffer && support.blob && isDataView(body)) {\n      this._bodyArrayBuffer = bufferClone(body.buffer)\n      // IE 10-11 can't handle a DataView body.\n      this._bodyInit = new Blob([this._bodyArrayBuffer])\n    } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {\n      this._bodyArrayBuffer = bufferClone(body)\n    } else {\n      this._bodyText = body = Object.prototype.toString.call(body)\n    }\n\n    if (!this.headers.get('content-type')) {\n      if (typeof body === 'string') {\n        this.headers.set('content-type', 'text/plain;charset=UTF-8')\n      } else if (this._bodyBlob && this._bodyBlob.type) {\n        this.headers.set('content-type', this._bodyBlob.type)\n      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n        this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8')\n      }\n    }\n  }\n\n  if (support.blob) {\n    this.blob = function() {\n      var rejected = consumed(this)\n      if (rejected) {\n        return rejected\n      }\n\n      if (this._bodyBlob) {\n        return Promise.resolve(this._bodyBlob)\n      } else if (this._bodyArrayBuffer) {\n        return Promise.resolve(new Blob([this._bodyArrayBuffer]))\n      } else if (this._bodyFormData) {\n        throw new Error('could not read FormData body as blob')\n      } else {\n        return Promise.resolve(new Blob([this._bodyText]))\n      }\n    }\n\n    this.arrayBuffer = function() {\n      if (this._bodyArrayBuffer) {\n        var isConsumed = consumed(this)\n        if (isConsumed) {\n          return isConsumed\n        }\n        if (ArrayBuffer.isView(this._bodyArrayBuffer)) {\n          return Promise.resolve(\n            this._bodyArrayBuffer.buffer.slice(\n              this._bodyArrayBuffer.byteOffset,\n              this._bodyArrayBuffer.byteOffset + this._bodyArrayBuffer.byteLength\n            )\n          )\n        } else {\n          return Promise.resolve(this._bodyArrayBuffer)\n        }\n      } else {\n        return this.blob().then(readBlobAsArrayBuffer)\n      }\n    }\n  }\n\n  this.text = function() {\n    var rejected = consumed(this)\n    if (rejected) {\n      return rejected\n    }\n\n    if (this._bodyBlob) {\n      return readBlobAsText(this._bodyBlob)\n    } else if (this._bodyArrayBuffer) {\n      return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))\n    } else if (this._bodyFormData) {\n      throw new Error('could not read FormData body as text')\n    } else {\n      return Promise.resolve(this._bodyText)\n    }\n  }\n\n  if (support.formData) {\n    this.formData = function() {\n      return this.text().then(decode)\n    }\n  }\n\n  this.json = function() {\n    return this.text().then(JSON.parse)\n  }\n\n  return this\n}\n\n// HTTP methods whose capitalization should be normalized\nvar methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT']\n\nfunction normalizeMethod(method) {\n  var upcased = method.toUpperCase()\n  return methods.indexOf(upcased) > -1 ? upcased : method\n}\n\nfunction Request(input, options) {\n  if (!(this instanceof Request)) {\n    throw new TypeError('Please use the \"new\" operator, this DOM object constructor cannot be called as a function.')\n  }\n\n  options = options || {}\n  var body = options.body\n\n  if (input instanceof Request) {\n    if (input.bodyUsed) {\n      throw new TypeError('Already read')\n    }\n    this.url = input.url\n    this.credentials = input.credentials\n    if (!options.headers) {\n      this.headers = new Headers(input.headers)\n    }\n    this.method = input.method\n    this.mode = input.mode\n    this.signal = input.signal\n    if (!body && input._bodyInit != null) {\n      body = input._bodyInit\n      input.bodyUsed = true\n    }\n  } else {\n    this.url = String(input)\n  }\n\n  this.credentials = options.credentials || this.credentials || 'same-origin'\n  if (options.headers || !this.headers) {\n    this.headers = new Headers(options.headers)\n  }\n  this.method = normalizeMethod(options.method || this.method || 'GET')\n  this.mode = options.mode || this.mode || null\n  this.signal = options.signal || this.signal\n  this.referrer = null\n\n  if ((this.method === 'GET' || this.method === 'HEAD') && body) {\n    throw new TypeError('Body not allowed for GET or HEAD requests')\n  }\n  this._initBody(body)\n\n  if (this.method === 'GET' || this.method === 'HEAD') {\n    if (options.cache === 'no-store' || options.cache === 'no-cache') {\n      // Search for a '_' parameter in the query string\n      var reParamSearch = /([?&])_=[^&]*/\n      if (reParamSearch.test(this.url)) {\n        // If it already exists then set the value with the current time\n        this.url = this.url.replace(reParamSearch, '$1_=' + new Date().getTime())\n      } else {\n        // Otherwise add a new '_' parameter to the end with the current time\n        var reQueryString = /\\?/\n        this.url += (reQueryString.test(this.url) ? '&' : '?') + '_=' + new Date().getTime()\n      }\n    }\n  }\n}\n\nRequest.prototype.clone = function() {\n  return new Request(this, {body: this._bodyInit})\n}\n\nfunction decode(body) {\n  var form = new FormData()\n  body\n    .trim()\n    .split('&')\n    .forEach(function(bytes) {\n      if (bytes) {\n        var split = bytes.split('=')\n        var name = split.shift().replace(/\\+/g, ' ')\n        var value = split.join('=').replace(/\\+/g, ' ')\n        form.append(decodeURIComponent(name), decodeURIComponent(value))\n      }\n    })\n  return form\n}\n\nfunction parseHeaders(rawHeaders) {\n  var headers = new Headers()\n  // Replace instances of \\r\\n and \\n followed by at least one space or horizontal tab with a space\n  // https://tools.ietf.org/html/rfc7230#section-3.2\n  var preProcessedHeaders = rawHeaders.replace(/\\r?\\n[\\t ]+/g, ' ')\n  preProcessedHeaders.split(/\\r?\\n/).forEach(function(line) {\n    var parts = line.split(':')\n    var key = parts.shift().trim()\n    if (key) {\n      var value = parts.join(':').trim()\n      headers.append(key, value)\n    }\n  })\n  return headers\n}\n\nBody.call(Request.prototype)\n\nfunction Response(bodyInit, options) {\n  if (!(this instanceof Response)) {\n    throw new TypeError('Please use the \"new\" operator, this DOM object constructor cannot be called as a function.')\n  }\n  if (!options) {\n    options = {}\n  }\n\n  this.type = 'default'\n  this.status = options.status === undefined ? 200 : options.status\n  this.ok = this.status >= 200 && this.status < 300\n  this.statusText = 'statusText' in options ? options.statusText : ''\n  this.headers = new Headers(options.headers)\n  this.url = options.url || ''\n  this._initBody(bodyInit)\n}\n\nBody.call(Response.prototype)\n\nResponse.prototype.clone = function() {\n  return new Response(this._bodyInit, {\n    status: this.status,\n    statusText: this.statusText,\n    headers: new Headers(this.headers),\n    url: this.url\n  })\n}\n\nResponse.error = function() {\n  var response = new Response(null, {status: 0, statusText: ''})\n  response.type = 'error'\n  return response\n}\n\nvar redirectStatuses = [301, 302, 303, 307, 308]\n\nResponse.redirect = function(url, status) {\n  if (redirectStatuses.indexOf(status) === -1) {\n    throw new RangeError('Invalid status code')\n  }\n\n  return new Response(null, {status: status, headers: {location: url}})\n}\n\nvar DOMException = global.DOMException\ntry {\n  new DOMException()\n} catch (err) {\n  DOMException = function(message, name) {\n    this.message = message\n    this.name = name\n    var error = Error(message)\n    this.stack = error.stack\n  }\n  DOMException.prototype = Object.create(Error.prototype)\n  DOMException.prototype.constructor = DOMException\n}\n\nfunction fetch(input, init) {\n  return new Promise(function(resolve, reject) {\n    var request = new Request(input, init)\n\n    if (request.signal && request.signal.aborted) {\n      return reject(new DOMException('Aborted', 'AbortError'))\n    }\n\n    var xhr = new XMLHttpRequest()\n\n    function abortXhr() {\n      xhr.abort()\n    }\n\n    xhr.onload = function() {\n      var options = {\n        status: xhr.status,\n        statusText: xhr.statusText,\n        headers: parseHeaders(xhr.getAllResponseHeaders() || '')\n      }\n      options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL')\n      var body = 'response' in xhr ? xhr.response : xhr.responseText\n      setTimeout(function() {\n        resolve(new Response(body, options))\n      }, 0)\n    }\n\n    xhr.onerror = function() {\n      setTimeout(function() {\n        reject(new TypeError('Network request failed'))\n      }, 0)\n    }\n\n    xhr.ontimeout = function() {\n      setTimeout(function() {\n        reject(new TypeError('Network request failed'))\n      }, 0)\n    }\n\n    xhr.onabort = function() {\n      setTimeout(function() {\n        reject(new DOMException('Aborted', 'AbortError'))\n      }, 0)\n    }\n\n    function fixUrl(url) {\n      try {\n        return url === '' && global.location.href ? global.location.href : url\n      } catch (e) {\n        return url\n      }\n    }\n\n    xhr.open(request.method, fixUrl(request.url), true)\n\n    if (request.credentials === 'include') {\n      xhr.withCredentials = true\n    } else if (request.credentials === 'omit') {\n      xhr.withCredentials = false\n    }\n\n    if ('responseType' in xhr) {\n      if (support.blob) {\n        xhr.responseType = 'blob'\n      } else if (\n        support.arrayBuffer &&\n        request.headers.get('Content-Type') &&\n        request.headers.get('Content-Type').indexOf('application/octet-stream') !== -1\n      ) {\n        xhr.responseType = 'arraybuffer'\n      }\n    }\n\n    if (init && typeof init.headers === 'object' && !(init.headers instanceof Headers)) {\n      Object.getOwnPropertyNames(init.headers).forEach(function(name) {\n        xhr.setRequestHeader(name, normalizeValue(init.headers[name]))\n      })\n    } else {\n      request.headers.forEach(function(value, name) {\n        xhr.setRequestHeader(name, value)\n      })\n    }\n\n    if (request.signal) {\n      request.signal.addEventListener('abort', abortXhr)\n\n      xhr.onreadystatechange = function() {\n        // DONE (success or failure)\n        if (xhr.readyState === 4) {\n          request.signal.removeEventListener('abort', abortXhr)\n        }\n      }\n    }\n\n    xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit)\n  })\n}\n\nfetch.polyfill = true\n\nif (!global.fetch) {\n  global.fetch = fetch\n  global.Headers = Headers\n  global.Request = Request\n  global.Response = Response\n}\n\n\n//# sourceURL=webpack:////home/marcello/mdb/Code/olojs/node_modules/whatwg-fetch/fetch.js?");

/***/ }),

/***/ "../document.js":
/*!**********************!*\
  !*** ../document.js ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("\nvar expect = __webpack_require__(/*! chai */ \"../../node_modules/chai/index.js\").expect;\nvar swan = __webpack_require__(/*! @onlabsorg/swan-js */ \"../../node_modules/@onlabsorg/swan-js/index.js\");\n\nvar document = __webpack_require__(/*! ../lib/document */ \"../../lib/document.js\");\n\n\ndescribe(\"document\", () => {\n    \n    describe(\"context = document.createContext(namespace)\", () => {\n        \n        it(\"should be an expression context\", () => {\n            var expContext = swan.createContext();\n            var docContext = document.createContext();\n            for (let name in expContext) {\n                expect(docContext[name]).to.equal(expContext[name]);\n            }\n        });\n        \n        it(\"should contain the passed namespace properties as own properties\", () => {\n            var namespace = {a:1,b:2};\n            var docContext = document.createContext(namespace);\n            var ownProps = Object.assign({}, docContext);\n            expect(ownProps).to.deep.equal(namespace);\n        });\n    });    \n    \n    describe(\"evaluateDocument = document.parse(source)\", () => {\n        \n        it(\"should be a function\", () => {\n            var source = `<%a=10%><%b=a+10%>a + b = <%a+b%>`;\n            var evaluate = document.parse(source);\n            expect(evaluate).to.be.a(\"function\");            \n        });\n        \n        describe(\"docns = await evaluateDocument(context)\", () => {\n            \n            it(\"should be an object\", async () => {\n                var evaluate = document.parse(\"document source ...\");\n                var context = swan.createContext();\n                var namespace = await evaluate(context);\n                expect(namespace).to.be.an(\"object\");                \n            });\n            \n            it(\"should contain all the names defined in the swan expressions\", async () => {\n                var source = `<%a=10%><%b=a+10%>`;\n                var evaluate = document.parse(source);\n                var context = document.createContext({});\n                var namespace = await evaluate(context);\n                expect(namespace.a).to.equal(10);\n                expect(namespace.b).to.equal(20);\n            });\n            \n            it(\"should strngify to the text obtained replacing the swan expressions with their stringified return value\", async () => {\n                var source = `<%a=10%><%b=a+10%>a + b = <%a+b%>`;\n                var evaluate = document.parse(source);\n                var context = document.createContext();\n                var namespace = await evaluate(context);\n                expect(await context.str(namespace)).to.equal(\"a + b = 30\");\n            });\n        });        \n    });\n});\n\n\n//# sourceURL=webpack:///../document.js?");

/***/ }),

/***/ "../expression.js":
/*!************************!*\
  !*** ../expression.js ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var expect = __webpack_require__(/*! chai */ \"../../node_modules/chai/index.js\").expect;\nvar expression = __webpack_require__(/*! ../lib/expression */ \"../../lib/expression.js\");\n\n__webpack_require__(/*! @onlabsorg/swan-js/test/index */ \"../../node_modules/@onlabsorg/swan-js/test/index.js\");\n\ndescribe(\"olojs expression stdlib\", () => {\n\n    describe(\"markdown module\", () => {\n\n        it(\"should expose a function that converts markdown to HTML\", async () => {\n            var evaluate = expression.parse(`{\n                markdown = require 'markdown',\n                html = markdown '*bold*'\n            }.html`);\n            var html = await evaluate(expression.createContext())\n            expect(html).to.equal(\"<p><em>bold</em></p>\\n\");\n        });\n    });\n});\n\n\n//# sourceURL=webpack:///../expression.js?");

/***/ }),

/***/ "../memory-store.js":
/*!**************************!*\
  !*** ../memory-store.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var expect = __webpack_require__(/*! chai */ \"../../node_modules/chai/index.js\").expect;\nvar MemoryStore = __webpack_require__(/*! ../lib/memory-store */ \"../../lib/memory-store.js\");\n\n\n\ndescribe(\"MemoryStore\", () => {\n\n    describe(\"source = await memoryStore.read(path)\", () => {\n\n        it(\"should return the document source mapped to the given path\", async () => {\n            var memStore = new MemoryStore({\n                \"/path/to/doc1\": \"doc1 source\",\n                \"doc2\": \"doc2 source\",\n            });\n\n            expect(await memStore.read(\"/path/to/doc1\")).to.equal(\"doc1 source\");\n            expect(await memStore.read(\"path/to/doc1\")).to.equal(\"doc1 source\");\n            expect(await memStore.read(\"/path/to/../to/./doc1\")).to.equal(\"doc1 source\");\n\n            expect(await memStore.read(\"/doc2\")).to.equal(\"doc2 source\");\n            expect(await memStore.read(\"doc2\")).to.equal(\"doc2 source\");\n            expect(await memStore.read(\"/path/to/../../doc2\")).to.equal(\"doc2 source\");\n        });\n\n        it(\"should return an empty string if the path doesn't exist\", async () => {\n            var memStore = new MemoryStore();\n            expect(await memStore.read('/path/to/doc')).to.equal(\"\")\n        });\n    });\n\n    describe(\"names = await memoryStore.list(path)\", () => {\n\n        it(\"should return an array containing the list of the child items of the given path\", async () => {\n            var memStore = new MemoryStore({\n                \"/path/to/doc1\": \"...\",\n                \"/path/to/doc2\": \"...\",\n                \"/path/to/dir1/\": \"...\",\n                \"/path/to/dir1/doc1\": \"...\",\n                \"/path/to/dir1/doc2\": \"...\",\n                \"/path/to/dir2/\": \"...\",\n            });\n\n            expect((await memStore.list(\"/path/to/\")).sort()).to.deep.equal(['dir1/', 'dir2/', 'doc1', 'doc2']);\n            expect((await memStore.list(\"path/to/\")).sort()).to.deep.equal(['dir1/', 'dir2/', 'doc1', 'doc2']);\n            expect((await memStore.list(\"path/to\")).sort()).to.deep.equal(['dir1/', 'dir2/', 'doc1', 'doc2']);\n            expect((await memStore.list(\"/path/../path/to\")).sort()).to.deep.equal(['dir1/', 'dir2/', 'doc1', 'doc2']);\n\n            expect(await memStore.list(\"/path/\")).to.deep.equal(['to/']);\n            expect(await memStore.list(\"path/\")).to.deep.equal(['to/']);\n            expect(await memStore.list(\"path\")).to.deep.equal(['to/']);\n            expect(await memStore.list(\"/path/\")).to.deep.equal(['to/']);\n\n            expect(await memStore.list(\"/\")).to.deep.equal(['path/']);\n            expect(await memStore.list(\"\")).to.deep.equal(['path/']);\n            expect(await memStore.list(\"/path/..\")).to.deep.equal(['path/']);\n            \n            expect((await memStore.list(\"/path/to/dir1/\")).sort()).to.deep.equal(['', 'doc1', 'doc2']);\n        });\n\n        it(\"should return an empty array if the given path doesn't exist\", async () => {\n            var memStore = new MemoryStore({\n                \"/path/to/doc1\": \"...\",\n                \"/path/to/doc2\": \"...\",\n                \"/path/to/dir1/\": \"...\",\n                \"/path/to/dir1/doc1\": \"...\",\n                \"/path/to/dir1/doc2\": \"...\",\n                \"/path/to/dir2/\": \"...\",\n            });\n            expect(await memStore.list(\"/path/to/dir3/\")).to.deep.equal([]);\n        });\n    });\n\n    describe(\"await memoryStore.write(path, source)\", () => {\n\n        it(\"should map the given source to the given path\", async () => {\n            var memStore = new MemoryStore();\n            await memStore.write(\"/path/to/doc1\", \"doc1 source\");\n            await memStore.write(\"doc2\", \"doc2 source\");\n\n            expect(await memStore.read(\"/path/to/doc1\")).to.equal(\"doc1 source\");\n            expect(await memStore.read(\"/doc2\")).to.equal(\"doc2 source\");\n        });\n    });\n\n    describe(\"await memoryStore.delete(path)\", () => {\n        it(\"should remove the mappng to the given path, if it exists\", async () => {\n            var memStore = new MemoryStore({\n                \"/path/to/doc1\": \"doc1 source\",\n                \"doc2\": \"doc2 source\",\n            });\n\n            expect(await memStore.read(\"/path/to/doc1\")).to.equal(\"doc1 source\");\n            await memStore.delete(\"/path/to/doc1\");\n            expect(await memStore.read(\"/path/to/doc1\")).to.equal(\"\");\n\n            expect(await memStore.read(\"/doc2\")).to.equal(\"doc2 source\");\n            await memStore.delete(\"/path/to/../../doc2\");\n            expect(await memStore.read(\"/doc2\")).to.equal(\"\");\n        });\n    });\n\n    describe(\"await memoryStore.deleteAll(path)\", () => {\n        it(\"should remove all the mappng matching the given path\", async () => {\n            var memStore = new MemoryStore({\n                \"/path/to/doc1\": \"doc @ /path/to/doc1\",\n                \"/path/to/dir/\": \"doc @ /path/to/dir/\",\n                \"/path/to/dir/doc2\": \"doc @ /path/to/dir/doc2\",\n            });\n\n            expect(await memStore.read(\"/path/to/doc1\")).to.equal(\"doc @ /path/to/doc1\");\n            expect(await memStore.read(\"/path/to/dir/\")).to.equal(\"doc @ /path/to/dir/\");\n            expect(await memStore.read(\"/path/to/dir/doc2\")).to.equal(\"doc @ /path/to/dir/doc2\");\n\n            await memStore.deleteAll('/path/to/dir/');\n\n            expect(await memStore.read(\"/path/to/doc1\")).to.equal(\"doc @ /path/to/doc1\");\n            expect(await memStore.read(\"/path/to/dir/\")).to.equal(\"\");\n            expect(await memStore.read(\"/path/to/dir/doc2\")).to.equal(\"\");\n        });\n    });\n});\n\n\n//# sourceURL=webpack:///../memory-store.js?");

/***/ }),

/***/ "../router.js":
/*!********************!*\
  !*** ../router.js ***!
  \********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var expect = __webpack_require__(/*! chai */ \"../../node_modules/chai/index.js\").expect;\nvar document = __webpack_require__(/*! ../lib/document */ \"../../lib/document.js\");\nvar MemoryStore = __webpack_require__(/*! ../lib/memory-store */ \"../../lib/memory-store.js\");\nvar Router = __webpack_require__(/*! ../lib/router */ \"../../lib/router.js\");\n\n\n\ndescribe(\"Router\", () => {\n\n    describe(\"[store, subPath] = router.match(path)\", () => {\n\n        it(\"should return store mounted at the route matching the path and the subPath relative to that route\", () => {\n            var routes = {\n                \"path/to\": new MemoryStore(),\n                \"/path/to/store2\": new MemoryStore(),\n                \"/\": new MemoryStore()\n            }\n            var router = new Router(routes);\n            expect(router.match('/path/to/')).to.deep.equal([routes['path/to'], \"/\"]);\n            expect(router.match('/path/to/doc')).to.deep.equal([routes['path/to'], \"/doc\"]);\n            expect(router.match('/path/to/store2/path/to/doc')).to.deep.equal([routes['/path/to/store2'], \"/path/to/doc\"]);\n            expect(router.match('/path/to/store2/')).to.deep.equal([routes['/path/to/store2'], \"/\"]);\n            expect(router.match('/path_to/doc')).to.deep.equal([routes['/'], \"/path_to/doc\"]);\n        });\n\n        it(\"should return [null, path] if no match is found\", () => {\n            var routes = {\n                \"/path/to/s1\": new MemoryStore(),\n                \"/path/to/s2\": new MemoryStore(),\n            }\n            var router = new Router(routes);\n            expect(router.match('/path/to/s3/doc')).to.deep.equal([null, \"/path/to/s3/doc\"]);\n        });\n    });\n\n    describe(`source = router.read(path)`, () => {\n\n        it(\"should delegate to the matching mounted store\", async () => {\n            var router = new Router({\n                \"path/to\": new MemoryStore({\n                    \"/\"    : \"doc @ store1:/\",\n                    \"doc\"  : \"doc @ store1:/path/to/doc\"\n                }),\n                \"/path/to/store2\": new MemoryStore({\n                    \"/\"             : \"doc @ store2:/\",\n                    \"/path/to/doc\"  : \"doc @ store2:/path/to/doc\"\n                }),\n                \"/\": new MemoryStore({\n                    \"/path/to/doc\"  : \"doc @ root:/path/to/doc\",\n                    \"/path_to/doc\"  : \"doc @ root:/path_to/doc\"\n                }),\n            });\n            expect(await router.read('/path/to/')).to.equal(\"doc @ store1:/\");\n            expect(await router.read('/path/to/doc')).to.equal(\"doc @ store1:/path/to/doc\");\n            expect(await router.read('/path/to/store2/path/to/doc')).to.equal(\"doc @ store2:/path/to/doc\");\n            expect(await router.read('/path/to/store2/')).to.equal(\"doc @ store2:/\");\n            expect(await router.read('/path_to/doc')).to.equal(\"doc @ root:/path_to/doc\");\n        });\n\n        it(\"should return an empty document if no match is found\", async () => {\n            var router = new Router({\n                \"path/to\": new MemoryStore({\n                    \"/\"    : \"doc @ store1:/\",\n                    \"doc\"  : \"doc @ store1:/path/to/doc\"\n                }),\n                \"/path/to/store2\": new MemoryStore({\n                    \"/\"             : \"doc @ store2:/\",\n                    \"/path/to/doc\"  : \"doc @ store2:/path/to/doc\"\n                }),\n            });\n            expect(await router.read('/path_to/doc')).to.equal(\"\");\n        })\n    });\n\n    describe(`entries = router.list(id)`, () => {\n\n        it(\"should delegate to the matching mounted store\", async () => {\n            var memStore = new MemoryStore({\n                \"/path/to/doc1\": \"...\",\n                \"/path/to/doc2\": \"...\",\n                \"/path/to/dir1/\": \"...\",\n                \"/path/to/dir1/doc1\": \"...\",\n                \"/path/to/dir1/doc2\": \"...\",\n                \"/path/to/dir2/\": \"...\",\n            });\n            var router = new Router({\n                '/stores/mem': memStore\n            })\n\n            expect((await router.list(\"/stores/mem/path/to/\")).sort()).to.deep.equal(['dir1/', 'dir2/', 'doc1', 'doc2']);\n            expect(await router.list(\"/stores/mem/path/\")).to.deep.equal(['to/']);\n            expect(await router.list(\"/stores/mem/\")).to.deep.equal(['path/']);\n            expect(await router.list(\"/stores/mem\")).to.deep.equal(['path/']);\n        });\n\n        it(\"should return an empty array if no match is found\", async () => {\n            var memStore = new MemoryStore({\n                \"/path/to/doc1\": \"...\",\n                \"/path/to/doc2\": \"...\",\n                \"/path/to/dir1/\": \"...\",\n                \"/path/to/dir1/doc1\": \"...\",\n                \"/path/to/dir1/doc2\": \"...\",\n                \"/path/to/dir2/\": \"...\",\n            });\n            var router = new Router({\n                '/stores/mem': memStore\n            })\n            expect(await router.list(\"/path/to/dir\")).to.deep.equal([]);\n        });\n\n        it(\"should include mounted routes in the entries list\", async () => {\n            var router = new Router({\n                '/store': new MemoryStore({\n                    \"/path/to/doc1\": \"...\",\n                    \"/path/to/doc2\": \"...\",\n                }),\n                '/store/path': new MemoryStore({\n                    \"/to/doc1\": \"...\",\n                    \"/to/doc3\": \"...\",\n                    \"/to/dir1/doc\": \"...\",\n                }),\n                '/': new MemoryStore({\n                    \"/store/path/to/doc1\": \"...\",\n                    \"/store/path/to/doc4\": \"...\",\n                    \"/doc5\": \"...\",\n                }),\n                '/store/path/to/dir2/': new MemoryStore(),\n                '/store/path/to/dir2/dir/': new MemoryStore(),\n                '/path/to/dir3': new MemoryStore(),\n            })\n            expect((await router.list(\"/store/path/to/\")).sort()).to.deep.equal(['dir1/', 'dir2/', 'doc1', 'doc2', 'doc3', 'doc4']);\n            expect((await router.list(\"/\")).sort()).to.deep.equal(['doc5', 'path/', 'store/']);\n        });\n    });\n\n    describe(`source = router.write(id, source)`, () => {\n\n        it(\"should delegate to the matching mounted store\", async () => {\n            var store1 = new MemoryStore();\n            var store2 = new MemoryStore();\n            var router = new Router({\n                s1: store1,\n                s2: store2,\n            });\n            await router.write('/s1/path/to/doc', \"doc @ store1\");\n            await router.write('s2/path/to/doc', \"doc @ store2\");\n            expect(await store1.read('/path/to/doc')).to.equal(\"doc @ store1\");\n            expect(await store2.read('/path/to/doc')).to.equal(\"doc @ store2\");\n        });\n\n        it(\"should throw an error if no match is found\", async () => {\n            var router = new Router();\n            try {\n                await router.write('/s1/path/to/doc', \"...\");\n                throw new Error(\"Id did not throw\");\n            } catch (error) {\n                expect(error).to.be.instanceof(Router.WriteOperationNotAllowedError);\n                expect(error.message).to.equal('Operation not allowed: WRITE /s1/path/to/doc')\n            }\n        });\n    });\n\n    describe(`source = router.delete(id)`, () => {\n\n        it(\"should delegate to the matching mounted store\", async () => {\n            var store1 = new MemoryStore();\n            var store2 = new MemoryStore();\n            var router = new Router({\n                s1: store1,\n                s2: store2,\n            });\n\n            await store1.write('/path/to/doc', \"doc @ store1\");\n            await router.delete('/s1/path/to/doc');\n            expect(store1.read('/path/to/doc')).to.equal(\"\");\n        });\n\n        it(\"should throw an error if no match is found\", async () => {\n            var router = new Router();\n            try {\n                await router.delete('/s1/path/to/doc');\n                throw new Error(\"Id did not throw\");\n            } catch (error) {\n                expect(error).to.be.instanceof(Router.WriteOperationNotAllowedError);\n                expect(error.message).to.equal('Operation not allowed: WRITE /s1/path/to/doc')\n            }\n        })\n    });\n\n    describe(`source = router.deleteAll(id)`, () => {\n\n        it(\"should delegate to the matching mounted store\", async () => {\n            var store1 = new MemoryStore();\n            var store2 = new MemoryStore();\n            var router = new Router({\n                s1: store1,\n                s2: store2,\n            });\n\n            var called = \"\";\n            store1.deleteAll = path => {\n                called = `store1.deleteAll ${path}`;\n            }\n\n            await router.deleteAll('/s1/path/to/dir');\n\n            expect(called).to.equal(\"store1.deleteAll /path/to/dir\");\n        });\n\n        it(\"should throw an error if no match is found\", async () => {\n            var router = new Router();\n            try {\n                await router.deleteAll('/s1/path/to/doc');\n                throw new Error(\"Id did not throw\");\n            } catch (error) {\n                expect(error).to.be.instanceof(Router.WriteOperationNotAllowedError);\n                expect(error.message).to.equal('Operation not allowed: WRITE /s1/path/to/doc')\n            }\n        })\n    });\n});\n\n\n//# sourceURL=webpack:///../router.js?");

/***/ }),

/***/ "../store.js":
/*!*******************!*\
  !*** ../store.js ***!
  \*******************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var expect = __webpack_require__(/*! chai */ \"../../node_modules/chai/index.js\").expect;\nvar document = __webpack_require__(/*! ../lib/document */ \"../../lib/document.js\");\nvar Store = __webpack_require__(/*! ../lib/store */ \"../../lib/store.js\");\n\n\ndescribe(\"Store\", () => {\n\n    describe(\"source = await store.read(path)\", () => {\n\n        describe(`when a document path is passed`, () => {\n            it(\"should always return an empty string\", async () => {\n                var store = new Store();\n                expect(await store.read(\"/pathh/to/doc1\")).to.equal(\"\");\n                expect(await store.read(\"/pathh/to/doc2\")).to.equal(\"\");\n                expect(await store.read(\"/pathh/to/../to/doc3/../doc4\")).to.equal(\"\");\n            });\n        });\n\n        describe(`when a directory path is passed`, () => {\n            it(\"should always return an empty string\", async () => {\n                var store = new Store();\n                expect(await store.read(\"/pathh/to/dir1/\")).to.equal(\"\");\n                expect(await store.read(\"/pathh/to/dir2/\")).to.equal(\"\");\n                expect(await store.read(\"/pathh/to/../to/doc3/../dir4/\")).to.equal(\"\");\n            });\n        });\n    });\n\n    describe(\"entries = await store.list(path)\", () => {\n        it(\"should return an empty array\", async () => {\n            var store = new Store();\n            expect(await store.list(\"/pathh/to/dir1/\")).to.deep.equal([]);\n            expect(await store.list(\"/pathh/to/dir2/\")).to.deep.equal([]);\n            expect(await store.list(\"/pathh/to/../to/doc3/../dir4/\")).to.deep.equal([]);\n        });\n    });\n\n    describe(\"await store.write(path, source)\", () => {\n        it(\"should throw a `WriteOperationNotAllowed` error\", async () => {\n            var store = new Store();\n            try {\n                await store.write(\"/path/to/doc1\", \"source of doc 1\");\n                throw new Error(\"Id didn't throw\");\n            } catch (error) {\n                expect(error).to.be.instanceof(Store.WriteOperationNotAllowedError);\n                expect(error.message).to.equal(\"Operation not allowed: WRITE /path/to/doc1\");\n            }\n        });\n    });\n\n    describe(\"await store.delete(path)\", () => {\n        it(\"should throw a `WriteOperationNotAllowed` error\", async () => {\n            var store = new Store();\n            try {\n                await store.delete(\"/path/to/doc1\");\n                throw new Error(\"Id didn't throw\");\n            } catch (error) {\n                expect(error).to.be.instanceof(Store.WriteOperationNotAllowedError);\n                expect(error.message).to.equal(\"Operation not allowed: WRITE /path/to/doc1\");\n            }\n        });\n    });\n\n    describe(\"await store.deleteAll(path)\", () => {\n        it(\"should throw a `WriteOperationNotAllowed` error\", async () => {\n            var store = new Store();\n            try {\n                await store.deleteAll(\"/path/to/\");\n                throw new Error(\"Id didn't throw\");\n            } catch (error) {\n                expect(error).to.be.instanceof(Store.WriteOperationNotAllowedError);\n                expect(error.message).to.equal(\"Operation not allowed: WRITE /path/to/\");\n            }\n        });\n    });\n\n    describe('Store.parseId', () => {\n\n        it(\"should return {path, argns}\", () => {\n            var pid = Store.parseId('/path/to/doc?x=1;y=2&s=abc;bool');\n            expect(pid).to.deep.equal({\n                path:   '/path/to/doc',\n                argns:  {x:1, y:2, s:\"abc\", bool:true},\n            });\n        });\n\n        it(\"should default to `/` if the path is missing\", () => {\n            expect(Store.parseId('?x=1;y=2&s=abc;bool')).to.deep.equal({\n                path:  '/',\n                argns:  {x:1, y:2, s:\"abc\", bool:true},\n            });\n        });\n\n        it(\"should report an empty argns if the query part is missing\", () => {\n            expect(Store.parseId('/path/to/doc')).to.deep.equal({\n                path:   '/path/to/doc',\n                argns:  {},\n            });\n            expect(Store.parseId('/path/to/doc?')).to.deep.equal({\n                path:   '/path/to/doc',\n                argns:  {},\n            });\n        });\n\n        it(\"should normalize the path\", () => {\n            expect(Store.parseId('/path/to/../doc?x=1;y=2&s=abc;bool')).to.deep.equal({\n                path:   '/path/doc',\n                argns:  {x:1, y:2, s:\"abc\", bool:true},\n            });\n            expect(Store.parseId('/../path/to/doc?x=1;y=2&s=abc;bool')).to.deep.equal({\n                path:   '/path/to/doc',\n                argns:  {x:1, y:2, s:\"abc\", bool:true},\n            });\n            expect(Store.parseId('path/to/doc?x=1;y=2&s=abc;bool')).to.deep.equal({\n                path:   '/path/to/doc',\n                argns:  {x:1, y:2, s:\"abc\", bool:true},\n            });\n            expect(Store.parseId('../path/to/doc?x=1;y=2&s=abc;bool')).to.deep.equal({\n                path:   '/path/to/doc',\n                argns:  {x:1, y:2, s:\"abc\", bool:true},\n            });\n        });\n    });\n\n    describe('context = store.createContext(docId)', () => {\n\n        it(\"should return a document context\", () => {\n            var store = new Store();\n            var context = store.createContext(\"/path/to/doc\");\n            var docContext = document.createContext();\n            for (let name in docContext) {\n                expect(context[name]).to.equal(docContext[name]);\n            }\n        });\n\n        it(\"should contain include the store.globals object\", () => {\n            var store = new Store();\n            Object.assign(store.globals, {x:10, y:20});\n            var context = store.createContext(\"/path/to/doc\");\n            for (let name in store.globals) {\n                expect(context[name]).to.equal(store.globals[name]);\n            }\n\n        });\n\n        describe(\"context.__path__\", () => {\n            it(\"should contain the normalize path portion of the docId\", () => {\n                var store = new Store();\n\n                var context = store.createContext(\"/path/to/doc?x=10;y=20\");\n                expect(context.__path__).to.equal(\"/path/to/doc\");\n\n                var context = store.createContext(\"path/to/doc?x=10;y=20\");\n                expect(context.__path__).to.equal(\"/path/to/doc\");\n\n                var context = store.createContext(\"?x=10;y=20\");\n                expect(context.__path__).to.equal(\"/\");\n\n                var context = store.createContext(\"..?x=10;y=20\");\n                expect(context.__path__).to.equal(\"/\");\n            });\n        });\n\n        describe(\"context.argns\", () => {\n            it(\"should contain the key-value pairs passed via the query string\", () => {\n                var store = new Store();\n                var context = store.createContext(\"/path/to/doc?x=1;y=2&s=abc;bool\");\n                expect(context.argns).to.deep.equal({x:1, y:2, s:\"abc\", bool:true});\n            });\n        });\n\n        describe(\"docns = context.import(id)\", () => {\n\n            it(\"should be a function\", () => {\n                const store = new Store();\n                var context = store.createContext(\"/path/to/doc\");\n                expect(context.import).to.be.a(\"function\");\n            });\n\n            it(\"should return the namespace of the document mapped to the passed id\", async () => {\n                var store = new Store();\n                store.read = path => `<% p = \"${path}\" %>`\n\n                var context = store.createContext(\"/path/to/doc?x=10\");\n\n                var doc1_ns = await context.import('/path/to/doc1');\n                expect(doc1_ns.p).to.equal('/path/to/doc1');\n                expect(doc1_ns.argns.x).to.be.undefined;\n\n                var doc1_ns = await context.import('/path/to/doc1?x=20');\n                expect(doc1_ns.p).to.equal('/path/to/doc1');\n                expect(doc1_ns.argns.x).to.equal(20);\n                \n                var dir_ns = await context.import('/path/to/dir/');\n                expect(dir_ns.p).to.equal('/path/to/dir/');\n                expect(dir_ns.argns.x).to.be.undefined;                \n            });\n\n            it(\"should resolve ids relative to doc.path\", async () => {\n                const store = new Store();\n                store.read = path => `<% p = \"${path}\" %>`\n\n                var ctx = store.createContext(\"/path/to/doc?x=10\");\n                expect((await ctx.import('doc1')).p).to.equal('/path/to/doc1');\n                expect((await ctx.import('../doc2')).p).to.equal('/path/doc2');\n                expect((await ctx.import('../doc2?x=20')).argns.x).to.equal(20);\n                expect((await ctx.import('../doc2')).argns.x).to.be.undefined;\n\n                var ctx = store.createContext(\"/path/to/\");\n                expect((await ctx.import('./doc1')).p).to.equal('/path/to/doc1');\n            });\n\n            it(\"should cache the documents and load them only once\", async () => {\n                var count = 0;\n                const store = new Store();\n                store.read = path => {\n                    count += 1;\n                    return `doc @ ${path}`;\n                }\n                var ctx = store.createContext(\"/path/to/doc\");\n\n                var ns = await ctx.import(\"/path/to/doc\");\n                expect(count).to.equal(1);\n\n                var ns = await ctx.import(\"/path/to/doc?x=10\");\n                expect(count).to.equal(1);\n\n                var ns = await ctx.import(\"/path/to/doc2\");\n                expect(count).to.equal(2);\n\n                var ns = await ctx.import(\"/path/to/doc2\");\n                expect(count).to.equal(2);\n            });\n        });\n    });\n\n    describe('doc = await store.load(docId)', () => {\n        it(\"should return an object containing the document source, context, namespace and rendered text\", async () => {\n            var store = new Store();\n            store.read = path => `p = <% p: \"${path}\" %>, x = <% argns.x %>`;\n            var doc = await store.load('/path/to/doc?x=10');\n            expect(doc.source).to.equal(`p = <% p: \"/path/to/doc\" %>, x = <% argns.x %>`);\n            expect(doc.context.__path__).to.equal(\"/path/to/doc\");\n            expect(doc.context.argns).to.deep.equal({x:10});\n            expect(doc.namespace.p).to.equal(\"/path/to/doc\");\n            expect(doc.namespace.argns).to.deep.equal({x:10});\n            expect(doc.text).to.equal(`p = /path/to/doc, x = 10`);\n        });\n    });\n});\n\n\n//# sourceURL=webpack:///../store.js?");

/***/ }),

/***/ "./index.js":
/*!******************!*\
  !*** ./index.js ***!
  \******************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const expect = __webpack_require__(/*! chai */ \"../../node_modules/chai/index.js\").expect;\nconst olojs = __webpack_require__(/*! ../../browser */ \"../../browser.js\");\n\n\ndescribe(\"olojs\", () => {\n\n    it(\"should export the `expression` module\", () => {\n        expect(olojs.expression).to.equal(__webpack_require__(/*! ../../lib/expression */ \"../../lib/expression.js\"));\n        expect(olojs.expression).to.equal(__webpack_require__(/*! @onlabsorg/swan-js */ \"../../node_modules/@onlabsorg/swan-js/index.js\"));\n    });\n\n    it(\"should export the `document` module\", () => {\n        expect(olojs.document).to.equal(__webpack_require__(/*! ../../lib/document */ \"../../lib/document.js\"));\n    });\n\n    it(\"should export the `Store` class\", () => {\n        expect(olojs.Store).to.equal(__webpack_require__(/*! ../../lib/store */ \"../../lib/store.js\"));\n    });\n\n    it(\"should export the `MemoryStore` class\", () => {\n        expect(olojs.MemoryStore).to.equal(__webpack_require__(/*! ../../lib/memory-store */ \"../../lib/memory-store.js\"));\n    });\n\n    it(\"should export the `HTTPStore` class\", () => {\n        expect(olojs.HTTPStore).to.equal(__webpack_require__(/*! ../../lib/http-store */ \"../../lib/http-store.js\"));\n    });\n\n    it(\"should export the `Router` class\", () => {\n        expect(olojs.Router).to.equal(__webpack_require__(/*! ../../lib/router */ \"../../lib/router.js\"));\n    });\n\n    __webpack_require__(/*! ../expression */ \"../expression.js\");\n    __webpack_require__(/*! ../document */ \"../document.js\");\n    __webpack_require__(/*! ../store */ \"../store.js\");\n    __webpack_require__(/*! ../memory-store */ \"../memory-store.js\");\n    // require(\"./http-store\");\n    __webpack_require__(/*! ../router */ \"../router.js\");\n});\n\n\n//# sourceURL=webpack:///./index.js?");

/***/ })

/******/ });